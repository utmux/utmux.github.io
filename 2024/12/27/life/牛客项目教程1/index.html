<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：好   第一部分：Linux编程基础知识  makefile 两个函数： 12$(wildcard .c .&#x2F;sub&#x2F;.c) # 用于子目录模式匹配$(patsubst %.c, %.o, x.c bar.c) # 用于字符串模式替换  gdb 补充两个东西 12345678l 文件名:函数&#x2F;行数set listsize： 设置每次打印的行数display ： 持久打印，使用un">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客项目教程1">
<meta property="og:url" content="https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：好   第一部分：Linux编程基础知识  makefile 两个函数： 12$(wildcard .c .&#x2F;sub&#x2F;.c) # 用于子目录模式匹配$(patsubst %.c, %.o, x.c bar.c) # 用于字符串模式替换  gdb 补充两个东西 12345678l 文件名:函数&#x2F;行数set listsize： 设置每次打印的行数display ： 持久打印，使用un">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/1993ec4652399734caf3fcdea61b0c0a.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/07b1b507f9e0e7c1ac399cdc0a382c98.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/a708b6d808bfdd3e95548424c4b2b1df.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/2a2645c398a2f25faba300cb5ba4745e.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/c48a7ce261e8f6c65b84e0d896cd1f5b.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/a7d33c49e8d4cd9acbb63c007ea88c4c.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/06381ce8988069afd5aa103fbea8f2f0.png">
<meta property="article:published_time" content="2024-12-27T07:01:26.000Z">
<meta property="article:modified_time" content="2025-05-10T06:40:59.858Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/1993ec4652399734caf3fcdea61b0c0a.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>牛客项目教程1</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/01/04/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B2/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/12/12/life/STL_7/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&text=牛客项目教程1"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&is_video=false&description=牛客项目教程1"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=牛客项目教程1&body=Check out this article: https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&name=牛客项目教程1&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&t=牛客项目教程1"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86linux%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text"> 第一部分：Linux编程基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile"><span class="toc-number">1.1.</span> <span class="toc-text"> makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb"><span class="toc-number">1.2.</span> <span class="toc-text"> gdb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text"> 静态库和动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text"> 虚拟地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text"> 文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Capi"><span class="toc-number">1.6.</span> <span class="toc-text"> 常见的linux文件操作api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Capi"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 文件操作api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7api"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 文件属性api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86api"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 目录遍历api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%BF%AE%E6%94%B9"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 文件描述符修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text"> 第二部分：操作系统知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text"> 进程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-2"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 单道多道程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pcb%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.2.5.</span> <span class="toc-text"> PCB(进程控制块)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">2.2.6.</span> <span class="toc-text"> 进程的状态切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.7.</span> <span class="toc-text"> Linux查看进程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">2.2.8.</span> <span class="toc-text"> 进程号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.9.</span> <span class="toc-text"> 进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gbd%E8%B0%83%E8%AF%95%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.10.</span> <span class="toc-text"> GBD调试多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">2.2.11.</span> <span class="toc-text"> exec函数族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-number">2.2.12.</span> <span class="toc-text"> 进程退出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.</span> <span class="toc-text"> 进程回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 孤儿进程和僵尸进程的回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 匿名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 有名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.4.</span> <span class="toc-text"> 信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.5.</span> <span class="toc-text"> 信号相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">2.4.6.</span> <span class="toc-text"> 信号捕捉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigchld%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.7.</span> <span class="toc-text"> SIGCHLD信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text"> 共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 共享内存的使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 共享内存和内存映射的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%BC%9A%E8%AF%9D"><span class="toc-number">2.6.</span> <span class="toc-text"> 进程和进程组以及会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 守护进程</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        牛客项目教程1
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-12-27T07:01:26.000Z" class="dt-published" itemprop="datePublished">2024-12-27</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/life/">life</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：好</p>
<hr />
<h2 id="第一部分linux编程基础知识"><a class="markdownIt-Anchor" href="#第一部分linux编程基础知识"></a> 第一部分：Linux编程基础知识</h2>
<h3 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> makefile</h3>
<p>两个函数：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> .c ./sub/.c)</span> <span class="comment"># 用于子目录模式匹配</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, x.c bar.c)</span> <span class="comment"># 用于字符串模式替换</span></span><br></pre></td></tr></table></figure>
<h3 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> gdb</h3>
<p>补充两个东西</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l 文件名:函数/行数</span><br><span class="line">set listsize： 设置每次打印的行数</span><br><span class="line">display ： 持久打印，使用undisplay取消</span><br><span class="line">until： 退出循环</span><br><span class="line">break结合if使用</span><br><span class="line">info display/w/b 查看</span><br><span class="line">d n 删除断点等</span><br><span class="line">dis n 失能断点等</span><br></pre></td></tr></table></figure>
<h3 id="静态库和动态库"><a class="markdownIt-Anchor" href="#静态库和动态库"></a> 静态库和动态库</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o // 注意以lib开头</span><br><span class="line">// 链接的时候就不加lib，如下所示</span><br><span class="line">gcc -o main main.c -l. -lcalc -i .</span><br><span class="line">// 对于动态库</span><br><span class="line">// 1.生成.o文件</span><br><span class="line">gcc -c –fpic/-fpic a.c b.c</span><br><span class="line">// 2.生成动态库</span><br><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br><span class="line">// 3.使用动态库（链接的时候和上面类似加了一个-shared选项）</span><br><span class="line">gcc -o main main.c -l. -lcalc -i .</span><br></pre></td></tr></table></figure>
<h3 id="虚拟地址"><a class="markdownIt-Anchor" href="#虚拟地址"></a> 虚拟地址</h3>
<ol>
<li>虚拟地址分为内核空间和用户空间, 其通过mmu进行映射到实际的物理地址</li>
<li>32位的机器中，虚拟地址的大小为4gb，64位的为4tb</li>
<li>实际中的虚拟地址布局如下所示：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">|        4g 内核区       |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| |   linux kernel     | |</span><br><span class="line">| |  - 内存管理        | |</span><br><span class="line">| |  - 进程管理        | |</span><br><span class="line">| |  - 设备和文件管理  | |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">|        保护地址区      |</span><br><span class="line">+------------------------+</span><br><span class="line">|        3g 用户区       |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| | 环境变量           | |</span><br><span class="line">| | 命令行参数         | |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| |      栈空间 (小)   | |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| |      共享库        | |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| |      堆空间 (大)   | |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">| |.bss (未初始化变量) | |</span><br><span class="line">| |.data (已初始化变量)| |</span><br><span class="line">| |.text (代码段)      | |</span><br><span class="line">| +--------------------+ |</span><br><span class="line">|    受保护的地址(0~4k)  |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h3>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/1993ec4652399734caf3fcdea61b0c0a.jpg" alt="c语言和底层文件描述符的交互" /></p>
<h3 id="常见的linux文件操作api"><a class="markdownIt-Anchor" href="#常见的linux文件操作api"></a> 常见的linux文件操作api</h3>
<h4 id="文件操作api"><a class="markdownIt-Anchor" href="#文件操作api"></a> 文件操作api</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># man 2是系统api的手册</span></span><br><span class="line"><span class="meta"># man 3是库函数的手册</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br></pre></td></tr></table></figure>
<p>其中stat中的stat结构体的结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span> st_dev; <span class="comment">// 文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino; <span class="comment">// 节点</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode; <span class="comment">// 文件的类型和存取的权限</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink; <span class="comment">// 连到该文件的硬连接数目</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid; <span class="comment">// 用户id</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid; <span class="comment">// 组id</span></span><br><span class="line">    <span class="type">dev_t</span> st_rdev; <span class="comment">// 设备文件的设备编号</span></span><br><span class="line">    <span class="type">off_t</span> st_size; <span class="comment">// 文件字节数(文件大小)</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize; <span class="comment">// 块大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span> st_blocks; <span class="comment">// 块数</span></span><br><span class="line">    <span class="type">time_t</span> st_atime; <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime; <span class="comment">// 最后一次修改时间</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime; <span class="comment">// 最后一次改变时间(指属性</span></span><br><span class="line">&#125;</span><br><span class="line">``` c</span><br><span class="line">其中st_mode变量如下，其各个位的解释如下：</span><br><span class="line">+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">| 文件类型 | 特殊权限位 |           user           |          group          |          others         |</span><br><span class="line">+---------+---------+----+----+----+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|   <span class="number">15</span>    |   <span class="number">14</span>    | <span class="number">13</span> | <span class="number">12</span> | <span class="number">11</span> | <span class="number">10</span> |  <span class="number">9</span> |  <span class="number">8</span> |  <span class="number">7</span> |  <span class="number">6</span> |  <span class="number">5</span> |  <span class="number">4</span> |  <span class="number">3</span> |  <span class="number">2</span> |</span><br><span class="line">|         |         |  g |  u |  s | rwx| rwx| rwx|    rwx (权限定义)          |</span><br><span class="line">+---------+---------+----+----+----+----+----+</span><br></pre></td></tr></table></figure>
<p>具体的解释如下:<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/07b1b507f9e0e7c1ac399cdc0a382c98.jpg" alt="各个位的具体解释" /></p>
<ol>
<li>其中特殊权限位是linux中的特殊权限，其含义为：
<ul>
<li>s_isuid: 设置uid位，如果设置了这个位，当文件被执行时，文件拥有者的uid会被作为uid运行这个文件。</li>
<li>s_isgid: 设置gid位，如果设置了这个位，当文件被执行时，文件拥有者的gid会被作为gid运行这个文件。</li>
<li>s_isvtx: 设置sticky位，如果设置了这个位，只有文件拥有者或者root用户才能删除或者修改文件。</li>
</ul>
</li>
<li>如上图所示，其判断方法是通过和宏定义进行位运算来看是否有权限，如s_irusr，s_iwusr，s_ixusr，s_irgrp，s_iwgrp，s_ixgrp，s_iroth，s_iwoth，s_ixoth，s_isuid，s_isgid，s_isvtx进行位运算，如果结果为0，则没有权限，否则有权限。</li>
</ol>
<h4 id="文件属性api"><a class="markdownIt-Anchor" href="#文件属性api"></a> 文件属性api</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>大致说一下上面的函数的作用：</p>
<ul>
<li><code>access</code>函数用于判断文件是否可执行，可读，可写等。</li>
<li><code>chmod</code>函数用于修改文件的权限，其mode参数为文件权限的八进制表示，如0644。</li>
<li><code>chown</code>函数用于修改文件的所有者和组所有者。</li>
<li><code>truncate</code>函数用于截断文件，即将文件截断为指定长度。</li>
<li>截断文件时，如果文件长度大于指定长度，则截断文件，如果文件长度小于指定长度，则扩展文件。<br />
其中指的一说的是<code>mode</code>，这里的<code>mode</code>最终会和<code>umask</code>进行位运算，得到最终的权限。</li>
</ul>
<ol>
<li><code>umask</code>函数用于设置文件权限的掩码，其作用是屏蔽掉一些权限，如0666，表示可读可写可执行，如果umask为0022，则表示屏蔽掉0022，即屏蔽掉可执行权限，最终权限为0664。</li>
<li><code>chmod</code>函数的参数为文件权限的八进制表示，如0644，表示可读可写可执行，如果chmod为0022，则表示屏蔽掉0022，即屏蔽掉可执行权限，最终权限为0664。</li>
</ol>
<h4 id="目录遍历api"><a class="markdownIt-Anchor" href="#目录遍历api"></a> 目录遍历api</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dir *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(dir *dirp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(dir *dirp)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，结构体<code>DIR</code>的成员定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 此目录进入点的inode</span></span><br><span class="line"><span class="type">ino_t</span> d_ino;</span><br><span class="line"><span class="comment">// 目录文件开头至此目录进入点的位移</span></span><br><span class="line"><span class="type">off_t</span> d_off;</span><br><span class="line"><span class="comment">// d_name 的长度, 不包含NULL字符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> d_reclen;</span><br><span class="line"><span class="comment">// d_name 所指的文件类型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d_type;</span><br><span class="line"><span class="comment">// 文件名</span></span><br><span class="line"><span class="type">char</span> d_name[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>d_type</code>的值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d_type</span><br><span class="line">DT_BLK - 块设备</span><br><span class="line">DT_CHR - 字符设备</span><br><span class="line">DT_DIR - 目录</span><br><span class="line">DT_LNK - 软连接</span><br><span class="line">DT_FIFO - 管道</span><br><span class="line">DT_REG - 普通文件</span><br><span class="line">DT_SOCK - 套接字</span><br><span class="line">DT_UNKNOWN - 未知</span><br></pre></td></tr></table></figure>
<h4 id="文件描述符修改"><a class="markdownIt-Anchor" href="#文件描述符修改"></a> 文件描述符修改</h4>
<p>我们可以对文件描述符进行复制，重定向等操作。其使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于文件描述符，其存储再PCB的fd数组中，每次创建一个文件描述符，寻找空闲且序号最小的数组中的项</span></span><br><span class="line"><span class="comment">// 复制文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 重定向文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，dup函数会复制一个文件描述符，返回一个新的文件描述符，如果oldfd已经关闭，则返回-1。dup2函数会复制一个文件描述符，返回一个新的文件描述符，如果oldfd已经关闭，则返回-1，如果newfd已经打开，则关闭newfd，并将oldfd复制到newfd。</p>
<p>我们可以通过<code>fcntl</code>函数来修改文件描述符，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制文件描述符、设置/获取文件的状态标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>其中，cmd的值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">F_DUPFD - 复制文件描述符</span><br><span class="line">F_GETFD - 获取文件的状态标志</span><br><span class="line">F_SETFD - 设置文件的状态标志</span><br><span class="line">F_GETFL - 获取文件的访问模式和状态标志</span><br><span class="line">F_SETFL - 设置文件的访问模式和状态标志</span><br><span class="line">F_GETLK - 获取文件锁信息</span><br><span class="line">F_SETLK - 设置文件锁信息</span><br><span class="line">F_SETLKW - 设置文件锁信息，并等待</span><br><span class="line">F_GETOWN - 获取文件所有者</span><br><span class="line">F_SETOWN - 设置文件所有者</span><br><span class="line">F_GETSIG - 获取文件信号</span><br><span class="line">F_SETSIG - 设置文件信号</span><br><span class="line">F_GETPIPE_SZ - 获取管道大小</span><br><span class="line">F_SETPIPE_SZ - 设置管道大小</span><br><span class="line">F_GET_RW_HINT - 获取文件读写提示</span><br><span class="line">F_SET_RW_HINT - 设置文件读写提示</span><br><span class="line">F_GET_FILE_RW_HINT - 获取文件读写提示</span><br><span class="line">F_SET_FILE_RW_HINT - 设置文件读写提示</span><br><span class="line">F_ADD_SEALS - 添加文件封印</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>常见的使用函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制文件描述符</span></span><br><span class="line"><span class="type">int</span> newfd = fnctl(oldfd, F_DUPFD, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置文件的状态标志</span></span><br><span class="line"><span class="type">int</span> flags = fcntl(fd, F_GETFL); <span class="comment">// 获取文件状态标志</span></span><br><span class="line">flags |= O_NONBLOCK;   <span class="comment">// 设置文件状态标志为非阻塞</span></span><br><span class="line">fcntl(fd, F_SETFL, flags); <span class="comment">// 设置文件状态标志</span></span><br></pre></td></tr></table></figure>
<h2 id="第二部分操作系统知识"><a class="markdownIt-Anchor" href="#第二部分操作系统知识"></a> 第二部分：操作系统知识</h2>
<h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
<h3 id="进程的基本概念"><a class="markdownIt-Anchor" href="#进程的基本概念"></a> 进程的基本概念</h3>
<h4 id="程序"><a class="markdownIt-Anchor" href="#程序"></a> 程序</h4>
<p>首先我们要区别程序和进程，对于程序，其为一个二进制文件，包括如下内容：</p>
<ul>
<li>二进制格式标识符：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</li>
<li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li>
</ul>
<h4 id="进程-2"><a class="markdownIt-Anchor" href="#进程-2"></a> 进程</h4>
<p>对于进程，其存在于内存中，而不是硬盘中，其包括如下内容：</p>
<ul>
<li>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li>
<li>它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li>
<li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。</li>
<li>从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li>
<li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li>
<li>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li>
</ul>
<h4 id="单道多道程序设计"><a class="markdownIt-Anchor" href="#单道多道程序设计"></a> 单道多道程序设计</h4>
<ul>
<li>
<p>单道程序，即在计算机内存中只允许一个的程序运行。</p>
</li>
<li>
<p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</p>
</li>
<li>
<p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</p>
</li>
<li>
<p>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p>
</li>
</ul>
<h4 id="并行与并发"><a class="markdownIt-Anchor" href="#并行与并发"></a> 并行与并发</h4>
<p>并行（parallelism）和并发（concurrency）是计算机科学中两个非常不同的概念。<br />
并行（parallelism）是指多个任务同时运行，而并发（concurrency）是指多个任务在某一个时间点上同时发生。</p>
<h4 id="pcb进程控制块"><a class="markdownIt-Anchor" href="#pcb进程控制块"></a> PCB(进程控制块)</h4>
<p>PCB（Process Control Block）进程控制块，是操作系统中用来管理进程的运行状态和资源的数据结构。<br />
对于<code>Linux</code>，PCB特指<code>task_struct</code>结构体，其定义在<code>include/linux/sched.h</code>中。该结构体成员很多，我们只关注下面这几个：</p>
<ul>
<li>进程ID</li>
<li>进程的状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器</li>
<li>进程的虚拟空间信息</li>
<li>描述控制终端的信息</li>
<li>当前工作目录</li>
<li>umask工作掩码</li>
<li>文件描述符表，包含很多指向 file 结构体的指针</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（Session）和进程组</li>
<li>进程可以使用的资源上限（Resource Limit）</li>
</ul>
<h4 id="进程的状态切换"><a class="markdownIt-Anchor" href="#进程的状态切换"></a> 进程的状态切换</h4>
<p>在简化的情况下，进程状态切换分为以下几种：</p>
<ul>
<li>运行态：进程正在运行，可以执行指令。</li>
<li>阻塞态：进程因为等待资源、等待信号、等待I/O等，处于阻塞状态。</li>
<li>停止态：进程因为暂停、挂起等，处于停止状态。</li>
</ul>
<p>其转化关系可以用下图来表示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/a708b6d808bfdd3e95548424c4b2b1df.jpg" alt="状态转化图" /></p>
<p>可以看出，对于阻塞态，当阻塞事件结束后，其不能直接返回到运行态，需要先进入就绪态进行排队。</p>
<p>上面是经过简化后的三种状态，实际的操作系统中，状态会有新建和终止这两种状态，其独立于上面所说的三种状态，如下图所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/2a2645c398a2f25faba300cb5ba4745e.jpg" alt="状态转化图" /></p>
<h4 id="linux查看进程状态"><a class="markdownIt-Anchor" href="#linux查看进程状态"></a> Linux查看进程状态</h4>
<p>在Linux中，我们可以使用<code>ps</code>命令来查看进程的一些基础状态和进程的父进程，进程组和会话信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps aux <span class="comment"># 显示所有进程的基本信息</span></span><br><span class="line">ps ajx <span class="comment"># 显示进程的父进程，进程组和会话信息</span></span><br><span class="line"><span class="comment"># a：显示终端上的所有进程，包括其他用户的进程</span></span><br><span class="line"><span class="comment"># u：显示进程的详细信息</span></span><br><span class="line"><span class="comment"># x：显示没有控制终端的进程</span></span><br><span class="line"><span class="comment"># j：列出与作业控制相关的信息</span></span><br></pre></td></tr></table></figure>
<p>其中，如果我们使用<code>ps aux</code>命令，其输出的结果中有一个<code>STAT</code>项，其表示的状态如下表所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D 不可中断 Uninterruptible（usually IO）</span><br><span class="line">R 正在运行，或在队列中的进程</span><br><span class="line">S 处于休眠状态</span><br><span class="line">T 停止或被追踪</span><br><span class="line">Z 僵尸进程</span><br><span class="line">W 进入内存交换（从内核2.6开始无效）</span><br><span class="line">X 死掉的进程</span><br><span class="line">&lt; 高优先级</span><br><span class="line">N 低优先级</span><br><span class="line">s 包含子进程</span><br><span class="line">+ 位于前台的进程组</span><br></pre></td></tr></table></figure>
<p><code>top</code>指令也可用于实时查看进程状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top -d 1 <span class="comment"># 显示1秒的进程状态,其中-d参数表示刷新间隔时间</span></span><br><span class="line">top  <span class="comment"># 显示实时进程状态</span></span><br><span class="line"><span class="comment"># 其中在使用top命令后，我们可以进一步按下按键来使得top命令改变排序，相应的指令如下所示：</span></span><br><span class="line"><span class="comment"># 1. M 按内存排序</span></span><br><span class="line"><span class="comment"># 2. P 按PID排序</span></span><br><span class="line"><span class="comment"># 3. T 按照CPU运行时间排序</span></span><br><span class="line"><span class="comment"># 4. U 按照用户名进行筛选</span></span><br><span class="line"><span class="comment"># 5. K 选择kill某个进程</span></span><br></pre></td></tr></table></figure>
<p>使用Kill命令可以杀死进程，常见的kill命令如下所示（所谓的杀死进程其实是给进程发送各种signal，而不是真的杀死进程）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] pid</span><br><span class="line"><span class="built_in">kill</span> –l 列出所有信号， 即所有可以发送的信号</span><br><span class="line"><span class="built_in">kill</span> –SIGKILL 进程ID</span><br><span class="line"><span class="built_in">kill</span> -9 进程ID，和上面这个命令是一样的</span><br><span class="line">killall name 根据进程名杀死进程</span><br></pre></td></tr></table></figure>
<h4 id="进程号"><a class="markdownIt-Anchor" href="#进程号"></a> 进程号</h4>
<p>任何进程的进程号都是唯一的，进程号的方位是0~32767。任何进程，除了init进程，都有父进程。父进程对应的进程号叫做PPID，进程组代表一个进程的集合，默认情况下，当前的进程号就是他的进程组号。<br />
相关获取进程的pid和ppid以及父进程的pid的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid(void);</span><br><span class="line">pid_t getppid(void);</span><br><span class="line">pid_t getpgid(pid_t pid);</span><br></pre></td></tr></table></figure>
<h4 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h4>
<p>进程的创建，即<code>fork</code>函数，<code>fork</code>函数会创建一个新进程，新进程和原进程是完全隔离的，新进程的父进程是原进程。</p>
<p><code>fork</code>函数针对父进程和子进程有两个不同的返回值，对于子进程，其返回0，对于父进程，其返回子进程的PID，如果<code>fork</code>函数返回-1，则表示创建失败。</p>
<p>进行fork后，子进程的相关虚拟地址空间会和父进程相同，但是进程号会不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以<br />
推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。<br />
注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p>
<p>总结：父子进程的共同点和不同点<br />
共同点：虚拟地址空间一样，未写的变量，此时也是一样。<br />
不同点：父子进程的进程号不一样，父子进程的父进程号不一样，父子进程的进程组号不一样。当变量进行写入时，此时父子进程的变量值不一样。</p>
<h4 id="gbd调试多进程"><a class="markdownIt-Anchor" href="#gbd调试多进程"></a> GBD调试多进程</h4>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>作用</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>info inferiors</code></td>
<td>显示当前调试的所有进程（inferior）的列表及状态。</td>
<td><code>info inferiors</code></td>
</tr>
<tr>
<td><code>inferior &lt;id&gt;</code></td>
<td>切换到指定的进程（inferior）。</td>
<td><code>inferior 2</code></td>
</tr>
<tr>
<td><code>detach inferior &lt;id&gt;</code></td>
<td>分离指定进程，使其继续独立运行而不再受 GDB 控制。</td>
<td><code>detach inferior 2</code></td>
</tr>
<tr>
<td><code>detach</code></td>
<td>分离当前调试的进程，使其继续运行而不受 GDB 控制。</td>
<td><code>detach</code></td>
</tr>
<tr>
<td><code>set follow-fork-mode &lt;mode&gt;</code></td>
<td>设置在 fork 时是否跟踪父进程或子进程。选项为：<code>parent</code>（跟踪父进程）或 <code>child</code>（跟踪子进程）。</td>
<td><code>set follow-fork-mode child</code></td>
</tr>
<tr>
<td><code>show follow-fork-mode</code></td>
<td>显示当前的 fork 跟踪模式（父进程或子进程）。</td>
<td><code>show follow-fork-mode</code></td>
</tr>
<tr>
<td><code>set detach-on-fork &lt;on/off&gt;</code></td>
<td>设置 fork 后是否自动分离未被跟踪的进程。<code>on</code> 表示分离，<code>off</code> 表示保留在 GDB 中。</td>
<td><code>set detach-on-fork off</code></td>
</tr>
<tr>
<td><code>show detach-on-fork</code></td>
<td>显示当前的 fork 分离设置（是否分离未跟踪的进程）。</td>
<td><code>show detach-on-fork</code></td>
</tr>
<tr>
<td><code>kill</code></td>
<td>终止当前调试的进程。</td>
<td><code>kill</code></td>
</tr>
<tr>
<td><code>kill inferior &lt;id&gt;</code></td>
<td>终止指定的进程（inferior）。</td>
<td><code>kill inferior 2</code></td>
</tr>
<tr>
<td><code>quit</code></td>
<td>退出 GDB（如果当前有正在调试的进程，会提示是否终止进程）。</td>
<td><code>quit</code></td>
</tr>
</tbody>
</table>
<h4 id="exec函数族"><a class="markdownIt-Anchor" href="#exec函数族"></a> exec函数族</h4>
<p>所谓函数族，是指函数名不同，但是功能近似的函数。<br />
exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。<br />
exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char * const</span></span></span><br><span class="line"><span class="comment"><span class="params">envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>上面的函数的功能都是近似的，只不过传入的参数有点不同。如下所示：</p>
<ul>
<li>l(list) 参数地址列表，以空指针结尾</li>
<li>v(vector) 存有各参数地址的指针数组的地址</li>
<li>p(path) 按 PATH 环境变量指定的目录搜索可执行文件</li>
<li>e(environment) 存有环境变量字符串地址的指针数组的地址</li>
</ul>
<h4 id="进程退出"><a class="markdownIt-Anchor" href="#进程退出"></a> 进程退出</h4>
<p>退出有两个函数，第一个是exit，第二个是_exit。前者是C语言中的函数，后者是Linux中的函数。<br />
其中exit函数会在执行一系列C语言中的退出处理操作后再调用_exit函数。其关系如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  进程运行         |</span><br><span class="line">+------------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+------------------+</span><br><span class="line">| 调用退出处理函数 |</span><br><span class="line">+------------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+---------------------------+</span><br><span class="line">| 刷新I/O缓冲，关闭文件描述符 |</span><br><span class="line">+---------------------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+------------------+</span><br><span class="line">| 调用_exit()系统调用 |</span><br><span class="line">+------------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+------------------+</span><br><span class="line">|  进程终止运行     |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<h3 id="进程回收"><a class="markdownIt-Anchor" href="#进程回收"></a> 进程回收</h3>
<h4 id="孤儿进程"><a class="markdownIt-Anchor" href="#孤儿进程"></a> 孤儿进程</h4>
<p>当父进程退出，而没有释放掉子进程的资源时，此时子进程就叫做孤儿进程，操作系统会默认将孤儿进程的父进程设为init进程(pid=1)，让init进程来管理孤儿进程。<br />
init进程会循环<code>wait</code>检查子进程是否结束，如果结束，此时会负责回收子进程的资源，并继续<code>wait</code>检查下一个子进程是否结束。</p>
<h4 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h4>
<p>子进程终止时，父进程尚未回收，子进程残留资源（PCB）。此时称为僵尸进程。<br />
僵尸进程不能被<code>kill -9</code>杀死。<br />
僵尸进程可以通过杀死父进程，此时子进程会被init进程接管，并回收子进程的资源。</p>
<h4 id="孤儿进程和僵尸进程的回收"><a class="markdownIt-Anchor" href="#孤儿进程和僵尸进程的回收"></a> 孤儿进程和僵尸进程的回收</h4>
<p>父进程通过<code>wait</code>和<code>waitpid</code>函数进行子进程回收，两个的功能是一样的，不同的是<code>waitpid</code>可以设置为非阻塞状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; <span class="comment">// status为子进程状态</span></span><br><span class="line"><span class="comment">// 成功返回子进程的pid，失败返回-1（代表所有子进程都已经结束）</span></span><br><span class="line"><span class="comment">// 调用wait函数时，会阻塞当前进程，直到有子进程结束。</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 其中pid参数有下面这几种情况:</span></span><br><span class="line"><span class="comment">// pid &lt; -1：表示只等待子进程中组进程的绝对值等于pid的绝对值的</span></span><br><span class="line"><span class="comment">// pid = -1：表示等待所有子进程</span></span><br><span class="line"><span class="comment">// pid = 0：只等待子进程中的组进程等于calling process的进程ID的子进程</span></span><br><span class="line"><span class="comment">// pid &gt; 0：只等待pid的子进程</span></span><br><span class="line"><span class="comment">// options参数有下面这几种情况:</span></span><br><span class="line"><span class="comment">// 默认情况下waitpid只会监测进程被terminated才返回，对于stop和continue状态的进程不会返回。</span></span><br><span class="line"><span class="comment">// 0：阻塞情况，不会立即返回</span></span><br><span class="line"><span class="comment">// WNOHANG：如果子进程没有结束，则立即返回，不阻塞。</span></span><br><span class="line"><span class="comment">// WUNTRACED：如果子进程被暂停，则立即返回，不阻塞。</span></span><br><span class="line"><span class="comment">// WCONTINUED：如果子进程被恢复，则立即返回，不阻塞。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面两个函数都有一个参数status，这个参数用来保存子进程的状态。我们可以通过下面这些宏对状态进行解读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status) 非<span class="number">0</span>，进程正常退出</span><br><span class="line">WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（<span class="built_in">exit</span>的参数）</span><br><span class="line">WIFSIGNALED(status) 非<span class="number">0</span>，进程异常终止</span><br><span class="line">WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号</span><br><span class="line">WIFSTOPPED(status) 非<span class="number">0</span>，进程处于暂停状态</span><br><span class="line">WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号</span><br><span class="line">WIFCONTINUED(status) 非<span class="number">0</span>，进程暂停后已经继续运行</span><br></pre></td></tr></table></figure>
<h3 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h3>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/c48a7ce261e8f6c65b84e0d896cd1f5b.jpg" alt="Linux进程通信方式" /></p>
<h4 id="匿名管道"><a class="markdownIt-Anchor" href="#匿名管道"></a> 匿名管道</h4>
<p>管道是进程间通信的一种方式，它允许两个进程之间进行通信。管道是半双工的，即只能用于进程间的单向通信。<br />
管道是内核中一个匿名缓冲区，子进程和父进程使用管道沟通的方式如下，首先父进程创建一个管道，使用<code>pipe</code>函数。<br />
然后父进程使用<code>fork</code>函数，创建子进程。<br />
管道的数据传输方向是单向的，且读取操作是一次性操作，一旦被读取即会被删除。这意味着无法使用<code>lseek</code>这类进行随机读取。<br />
前面提到过，父进程和子进程的文件描述符是一样的，都是打开同一个内核缓冲区，这意味着管道只能在拥有公共祖先的进程之间进行。<br />
为了防止管道读取混乱，管道读取和写入之间遵循一定的关系如下：</p>
<ol>
<li>写入引用为0，此时读取会返回0，表示EOF</li>
<li>读取引入为0，此时写入会触发SIGPIPE信号，导致子进程退出</li>
<li>读取引入非0，此时写入，首先会写入缓冲区，如果缓冲区满了，会导致阻塞，直到缓冲区有空闲位置，此时写入会返回实际写入的字节数<br />
相关函数如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">// 查看管道缓冲区大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="comment">// 查看当前内核中管道缓冲区最大限制</span></span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>
<p>使用方法，首先管道是单工的，故只能一端设置为读，一端设置为写，我们可以在子进程中关闭读端，在父进程中关闭写端。<br />
然后使用write方法写入，使用read方法读取。</p>
<h4 id="有名管道"><a class="markdownIt-Anchor" href="#有名管道"></a> 有名管道</h4>
<p>有名管道(FIFO)是内核中的特殊文件，它和普通文件不同，它的数据保存在内核中，而不是文件系统。<br />
FIFO故名思意，即先入先出，但是其并不支持<code>lseek</code>这种随机访问函数。<br />
有名管道和前面的匿名管道类似：</p>
<ol>
<li>有名管道文件的读引用或者写引用为0时，此时写或者读取会被阻塞。</li>
<li>当两端引用不是0时，开始读取和写入，此时和匿名管道类似。</li>
</ol>
<p>使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建有名管道，其中mode就是0666和上面的文件属性api传入的参数一样</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">// 读取，使用open函数readonly模式打开，再read</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 写，使用open函数writeonly模式打开，再write</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="内存映射"><a class="markdownIt-Anchor" href="#内存映射"></a> 内存映射</h4>
<p>将磁盘文件映射到内存之中，通过修改内存即可改变磁盘文件。<br />
内存映射函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="comment">// addr：映射到内存的起始地址，一般使用NULL，表示系统自动选择地址。</span></span><br><span class="line"><span class="comment">// length：映射的长度。</span></span><br><span class="line"><span class="comment">// prot：映射的权限，PROT_READ表示可读，PROT_WRITE表示可写， PROT_EXEC表示可执行, PROT_NONE表示不可读不可写不可执行。</span></span><br><span class="line"><span class="comment">// flags：映射的类型，MAP_SHARED表示映射区会同步文件，MAP_PRIVATE表示映射文件不会被修改。</span></span><br><span class="line"><span class="comment">// fd：文件描述符，通过open函数打开的文件描述符。注意，文件大小不能为0，且fd的权限和flags的权限不应冲突。</span></span><br><span class="line"><span class="comment">// offset：文件偏移量，从文件偏移量开始映射。</span></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 成功返回映射区的起始地址，失败返回MAP_FAILED。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<ul>
<li>对于有关系的进程，在<code>fork</code>之前，创建一个映射。</li>
<li>对于没有关系的，准备一个大小不为0的文件，创建一个映射。</li>
</ul>
<p>除此外，我们可以使用匿名映射，此时只可以用于父子进程间通信，或者兄弟进程之间的通信。我们只需要设置上面的mmap函数中：</p>
<ul>
<li>flags设置要或上<code>MAP_ANONYMOUS</code>标志，表示匿名映射。</li>
<li>offset设置为0。</li>
<li>fd设置为-1。</li>
</ul>
<h4 id="信号"><a class="markdownIt-Anchor" href="#信号"></a> 信号</h4>
<p>信号是Linux中最古老的一种机制，又称作软件中断，可以导致一个正在运行的进程被另一个正在运行的异步进程中断。<br />
信号的产生有下面这几类：</p>
<ol>
<li>对于前台程序：用于可以通过输入特殊中断字符来给进程发送特定的中断。</li>
<li>硬件发生异常，此时硬件会检测到一个错误指令，此时会发送给软件。</li>
<li>系统状态发生变化，比如alarm定时器，引起SIGALRM信号。或者进程超过时间限制，或者进程的某个子进程退出。</li>
<li>运行kill命令，此时会向进程发送信号。</li>
</ol>
<p><strong>信号的作用</strong><br />
对于信号其有两个作用，第一个是通知应用程序事件的发生，第二个是触发应用程序针对信号的中断处理程序。</p>
<p><strong>信号的特点</strong><br />
相比于其他进程通信手段，信号的特点如下：</p>
<ol>
<li>简单</li>
<li>轻量级，不能发送太多信息</li>
<li>满足某个特定条件才能发送</li>
<li>在系统的优先级比较高</li>
</ol>
<p>具体使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 7 signal</span><br></pre></td></tr></table></figure>
<p>Linux针对信号，有5中默认操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Term   Default action is to terminate the process.</span><br><span class="line">Ign    Default action is to ignore the signal.</span><br><span class="line">Core   Default action is to terminate the process and dump core (see core(5)).</span><br><span class="line">Stop   Default action is to stop the process.</span><br><span class="line">Cont   Default action is to <span class="built_in">continue</span> the process <span class="keyword">if</span> it is currently stopped.</span><br></pre></td></tr></table></figure>
<p>其中值得注意的是<code>core</code>信号，我们可以设置系统是否产生<code>coredump</code>文件用于辅助gdb调试错误，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ulimited -a 查看系统限制中的core参数是否允许生成core文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line"><span class="comment"># 设置允许的core文件大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"><span class="comment"># 使用gdb 调试程序</span></span><br><span class="line">gcc test.c -g -o <span class="built_in">test</span></span><br><span class="line">gdb ./test</span><br><span class="line">core_file = <span class="string">&quot;/tmp/core_%p&quot;</span> <span class="comment"># 设置core文件保存路径，一般在当前目录</span></span><br></pre></td></tr></table></figure>
<h4 id="信号相关函数"><a class="markdownIt-Anchor" href="#信号相关函数"></a> 信号相关函数</h4>
<p>信号相关的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">// 给进程或者进程组发送任何信号，具体查看man 2 kill</span></span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="comment">// pid: -1代表所有进程，除了init进程，常用于检查权限。小于-1的pid代表进程组，常用于检查权限。0代表当前进程。0代表当前进程所在进程组的其他进程，大于1表示指定进程。</span></span><br><span class="line"><span class="comment">// sig: 信号值，参考man 7 signal，其中sig可以为0，此时仅会检查权限。</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1，错误码保存在errno中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">// 给当前进程发送信号sig。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 杀死当前进程，并产生SIGABRT信号。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">// 设置定时器，参数seconds为秒数。</span></span><br><span class="line"><span class="comment">// 取消定时器使用alarm(0);</span></span><br><span class="line"><span class="comment">// 第一次设置alarm后，如果要查看剩余事件，再次调用alarm参数为非0即可。</span></span><br><span class="line"><span class="comment">// 定时器会触发SIGALRM信号，注意不要和sleep混淆，后者也会触发SIGALRM。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_val, <span class="keyword">struct</span> itimerval</span></span><br><span class="line"><span class="params">*old_value)</span>;</span><br><span class="line"><span class="comment">// 定时器和进程的状态无关，不论进程是就绪还是终止，alarm都会计时。</span></span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="comment">// which: ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF分别表示不同的时钟类型，真实时间（包括用户，内核，还有挂起时间）, 虚拟时间（包括用户内核+内核时间)，进程时间。</span></span><br><span class="line"><span class="comment">// new_val: struct itimerval *new_val new_val结构体指针，new_val-&gt;it_value表示定时器的初始值，new_val-&gt;it_interval表示定时器的间隔值。</span></span><br><span class="line"><span class="comment">// old_value: struct itimerval *old_value old_value结构体指针，old_value-&gt;it_value表示定时器的剩余时间，old_value-&gt;it_interval表示定时器的间隔值。一般设置为NULL</span></span><br></pre></td></tr></table></figure>
<h4 id="信号捕捉"><a class="markdownIt-Anchor" href="#信号捕捉"></a> 信号捕捉</h4>
<p>通过信号捕捉，可以实现对信号的处理。注意的是，对于SIGKILL和SIGSTOP信号，无法被捕捉，无法被屏蔽，无法被忽略。常用的信号捕捉函数有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>; <span class="comment">// man手册中，说这个函数是被废弃的，建议使用sigaction，只适合将信号设置为默认处理方式或者忽略。</span></span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="comment">// signum：要捕捉的信号</span></span><br><span class="line"><span class="comment">// handler：要设置的信号处理函数：1.SIG_DFL：默认信号处理方式；2.SIG_IGN：忽略信号；3.自定义函数指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>; <span class="comment">// man推荐使用的信号捕捉函数，具有可移植性</span></span><br><span class="line"><span class="comment">// 用于捕获信号集</span></span><br><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line"><span class="comment">// signum: 要捕捉的信号</span></span><br><span class="line"><span class="comment">// act: struct sigaction结构体指针，用于设置信号处理函数</span></span><br><span class="line"><span class="comment">// oldact: struct sigaction结构体指针，用于获取信号处理函数</span></span><br><span class="line"><span class="comment">// 其中struct sigaction结构体如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">        <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>); <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">        <span class="type">int</span>        sa_flags;</span><br><span class="line">        <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// sa_handler: 指向信号处理函数的指针</span></span><br><span class="line"><span class="comment">// sa_sigaction: 指向信号处理函数的指针 和上面类似，一般使用上面这个</span></span><br><span class="line"><span class="comment">// sa_mask: 指定信号处理函数执行时屏蔽的信号集</span></span><br><span class="line"><span class="comment">// sa_flags: 信号处理函数的标志，具体看man手册，一般为0</span></span><br><span class="line"><span class="comment">// sa_restorer: 指向信号处理函数执行完毕时恢复的函数，废弃</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">阻塞信号集，最阻塞信号机进行修改函数如下：</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line"><span class="comment">// 自定义信号集修改</span></span><br><span class="line"><span class="comment">// 例如 sigset_t set;使用下面的函数对其初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">// 判断信号是否在信号集中</span></span><br><span class="line"><span class="comment">// 对于内核中的信号集，我们不能直接进行修改，而需要靠下面的函数将需要设置的信号set置到内核中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; <span class="comment">// 设置阻塞信号集，对内核中的阻塞信号集进行操作</span></span><br><span class="line"><span class="comment">// 参数列表</span></span><br><span class="line"><span class="comment">// how: SIG_BLOCK(|set), SIG_UNBLOCK(&amp;!set), SIG_SETMASK(=set) // 设置方式</span></span><br><span class="line"><span class="comment">// set: 需要设置的信号集</span></span><br><span class="line"><span class="comment">// oldset: 旧的信号集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 获取内核中未决信号集中的数据</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/a7d33c49e8d4cd9acbb63c007ea88c4c.jpg" alt="内核捕捉信号" /></p>
<h4 id="sigchld信号"><a class="markdownIt-Anchor" href="#sigchld信号"></a> SIGCHLD信号</h4>
<p><strong>SIGCHLD信号产生的条件</strong><br />
SIGCHLD信号是子进程发送给父进程的信号，默认情况下父进程会对该信号进行省略。</p>
<ol>
<li>子进程结束</li>
<li>子进程接受到SIGSTOP信号</li>
<li>子进程接受到SIGCONT信号</li>
</ol>
<p><strong>SIGCHLD信号的处理方式</strong><br />
在默认条件下，子进程会默认发送SIGCHLD信号给父进程，父进程会默认忽略该信号。<br />
通过在父进程监听该信号，可以解决僵尸进程问题。</p>
<p>值得注意的是，由于子进程和父进程之间的阻塞信号集有继承的关系，且需要考虑父进程和子进程两种不同情况的处理时的竟态条件，所以需要在<code>fork</code>之前阻塞所有信号，等到<code>fork</code>之后再开放需要监听的信号集合。</p>
<h3 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h3>
<ul>
<li>共享内存是一种进程间通信方式，它允许多个进程间通过共享内存进行通信。相比于管道和消息队列，共享内存具有更高的效率，因为不需要通过系统调用进行通信。</li>
<li>共享内存的实现原理是，在系统内核中创建一块内存区域，多个进程都可以访问该内存区域，从而实现进程间通信。</li>
<li>使用共享内存，需要考虑到进程同步问题和互斥的问题。</li>
<li>共享内存在用户空间中，而不像管道存在于内核空间中，故其操作效率更加快。</li>
</ul>
<h4 id="共享内存的使用步骤"><a class="markdownIt-Anchor" href="#共享内存的使用步骤"></a> 共享内存的使用步骤</h4>
<p>共享内存的使用步骤如下：</p>
<ul>
<li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</li>
<li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要</li>
<li>使用由 shmat()调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li>
<li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>; <span class="comment">// 创建共享内存段</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>; <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line"><span class="comment">// 参数：shmid - 共享内存段的标识符，shmaddr - 指向共享内存段的指针，一般设置为NULL，由内核指定地址，shmflg - 创建共享内存段时使用的标志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>; <span class="comment">// 将共享内存段从进程的地址空间分离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>; <span class="comment">// 控制共享内存段，可以获取，设置共享内存属性，或者标记删除共享内存</span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>; <span class="comment">// 根据指定的路径名和一个int值创建一个键值,可以给上面的共享内存使用</span></span><br></pre></td></tr></table></figure>
<p>在Linux系统中，可以查看/proc/sysvipc/shm目录下的内容，可以查看共享内存的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享内存操作命令</span></span><br><span class="line"><span class="comment"># ipcs 用法</span></span><br><span class="line">ipcs -a // 打印当前系统中所有的进程间通信方式的信息</span><br><span class="line">ipcs -m // 打印出使用共享内存进行进程间通信的信息</span><br><span class="line">ipcs -q // 打印出使用消息队列进行进程间通信的信息</span><br><span class="line">ipcs -s // 打印出使用信号进行进程间通信的信息</span><br><span class="line"><span class="comment"># ipcrm 用法</span></span><br><span class="line">ipcrm -M shmkey // 移除用shmkey创建的共享内存段</span><br><span class="line">ipcrm -m shmid // 移除用shmid标识的共享内存段</span><br><span class="line">ipcrm -Q msgkey // 移除用msqkey创建的消息队列</span><br><span class="line">ipcrm -q msqid // 移除用msqid标识的消息队列</span><br><span class="line">ipcrm -S semkey // 移除用semkey创建的信号</span><br><span class="line">ipcrm -s semid // 移除用semid标识的信号</span><br></pre></td></tr></table></figure>
<h4 id="共享内存和内存映射的区别"><a class="markdownIt-Anchor" href="#共享内存和内存映射的区别"></a> 共享内存和内存映射的区别</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>共享内存</th>
<th>磁盘映射</th>
<th>匿名内存映射</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用途</strong></td>
<td>进程间通信</td>
<td>文件 I/O 或进程间通信</td>
<td>动态内存分配或父子进程共享</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td><code>shmget</code>/<code>shmat</code></td>
<td><code>mmap</code>（映射文件）</td>
<td><code>mmap</code>（<code>MAP_ANONYMOUS</code>）</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>独立于进程</td>
<td>与文件关联</td>
<td>与进程相关</td>
</tr>
<tr>
<td><strong>共享范围</strong></td>
<td>多个进程</td>
<td>多个进程（映射同一文件）</td>
<td>父子进程</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>非常高</td>
<td>较高</td>
<td>较高</td>
</tr>
<tr>
<td><strong>同步机制</strong></td>
<td>需要（如信号量）</td>
<td>需要（如信号量）</td>
<td>需要（如信号量）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高性能进程间通信</td>
<td>大文件访问或进程间通信</td>
<td>动态内存分配或父子进程共享</td>
</tr>
</tbody>
</table>
<h3 id="进程和进程组以及会话"><a class="markdownIt-Anchor" href="#进程和进程组以及会话"></a> 进程和进程组以及会话</h3>
<p><strong>进程</strong>是操作系统中的一个独立执行单元，每个进程有自己的地址空间和资源。<strong>进程组</strong>是一组相关进程的集合，通常由一个父进程及其创建的子进程组成，共享同一个进程组 ID（PGID）。<strong>会话</strong>是一个或多个进程组的集合，通常由一个终端启动，每个会话有一个唯一的会话 ID（SID），并且可以包含一个前台进程组和多个后台进程组。简单来说，进程属于进程组，进程组属于会话，三者是层层包含的关系。</p>
<ul>
<li>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</li>
<li>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</li>
<li>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</li>
<li><code>TTY</code> 是一个设备，负责处理输入和输出。</li>
<li>Shell 是一个运行在 <code>TTY</code> 上的程序，负责解析命令并启动其他程序。</li>
<li>运行的程序 会继承 Shell 的<code>PCB</code> 信息，从而可以控制会话中的进程组。</li>
<li>Shell 作为会话的控制进程，管理着会话中的进程组，并通过控制终端（TTY）与用户交互。</li>
<li>所有控制终端都是 TTY 设备，但并非所有 TTY 设备都是控制终端。</li>
<li>一个 TTY 设备只有在被某个会话关联后，才能称为该会话的控制终端。</li>
<li>TTY 设备 是终端设备的统称，可以是物理终端或伪终端。</li>
<li>控制终端 是一个被会话独占使用的 TTY 设备，用于处理会话的输入和输出。</li>
<li>一个 TTY 设备只有在被某个会话关联后，才能称为该会话的控制终端。<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/06381ce8988069afd5aa103fbea8f2f0.png" alt="会话和控制终端的关系" /></li>
</ul>
<p>相关的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="守护进程"><a class="markdownIt-Anchor" href="#守护进程"></a> 守护进程</h4>
<p>守护进程（daemon process）其相比其他进程：</p>
<ul>
<li>
<ol>
<li>运行在后台，不与任何会话关联。</li>
</ol>
</li>
<li>
<ol start="2">
<li>没有控制终端。</li>
</ol>
</li>
</ul>
<p>守护进程的创建方式：</p>
<ul>
<li>执行一个 <code>fork()</code>，之后父进程退出，子进程继续执行。</li>
<li>子进程调用 setsid() 开启一个新会话。</li>
<li>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</li>
<li>修改进程的当前工作目录，通常会改为根目录（/）。</li>
<li>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</li>
<li>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2()使所有这些描述符指向这个设备。</li>
<li>核心业务逻辑</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86linux%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text"> 第一部分：Linux编程基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile"><span class="toc-number">1.1.</span> <span class="toc-text"> makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb"><span class="toc-number">1.2.</span> <span class="toc-text"> gdb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text"> 静态库和动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text"> 虚拟地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text"> 文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Capi"><span class="toc-number">1.6.</span> <span class="toc-text"> 常见的linux文件操作api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Capi"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 文件操作api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7api"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 文件属性api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86api"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 目录遍历api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%BF%AE%E6%94%B9"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 文件描述符修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text"> 第二部分：操作系统知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text"> 进程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-2"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 单道多道程序设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pcb%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.2.5.</span> <span class="toc-text"> PCB(进程控制块)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">2.2.6.</span> <span class="toc-text"> 进程的状态切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.7.</span> <span class="toc-text"> Linux查看进程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">2.2.8.</span> <span class="toc-text"> 进程号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.9.</span> <span class="toc-text"> 进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gbd%E8%B0%83%E8%AF%95%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.10.</span> <span class="toc-text"> GBD调试多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">2.2.11.</span> <span class="toc-text"> exec函数族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-number">2.2.12.</span> <span class="toc-text"> 进程退出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.</span> <span class="toc-text"> 进程回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 孤儿进程和僵尸进程的回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 匿名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 有名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.4.</span> <span class="toc-text"> 信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.5.</span> <span class="toc-text"> 信号相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">2.4.6.</span> <span class="toc-text"> 信号捕捉</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigchld%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.4.7.</span> <span class="toc-text"> SIGCHLD信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text"> 共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 共享内存的使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 共享内存和内存映射的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%BB%A5%E5%8F%8A%E4%BC%9A%E8%AF%9D"><span class="toc-number">2.6.</span> <span class="toc-text"> 进程和进程组以及会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 守护进程</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&text=牛客项目教程1"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&is_video=false&description=牛客项目教程1"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=牛客项目教程1&body=Check out this article: https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&title=牛客项目教程1"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&name=牛客项目教程1&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/12/27/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B1/&t=牛客项目教程1"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
