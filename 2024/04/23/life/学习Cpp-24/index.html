<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：一般  根本看不完啊，明天继续，我一定要看完这本书。 Tips：使用成员初始化列表的构造函数将覆盖相应的类内初始化。  伪私有方法 使用伪私有方法，能够阻止编译器生成默认的一些函数，而且此时由于是私有方法，这些默认函数就无法被公共调用，比如下面这个： 123456class Queue&#123;private：	Queue(const Queue &amp; q) : qsiz">
<meta property="og:type" content="article">
<meta property="og:title" content="学习Cpp-24">
<meta property="og:url" content="https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：一般  根本看不完啊，明天继续，我一定要看完这本书。 Tips：使用成员初始化列表的构造函数将覆盖相应的类内初始化。  伪私有方法 使用伪私有方法，能够阻止编译器生成默认的一些函数，而且此时由于是私有方法，这些默认函数就无法被公共调用，比如下面这个： 123456class Queue&#123;private：	Queue(const Queue &amp; q) : qsiz">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-23T12:40:26.000Z">
<meta property="article:modified_time" content="2025-05-14T08:49:03.142Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>学习Cpp-24</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/04/24/life/%E5%AD%A6%E4%B9%A0Cpp-25/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/04/22/tick/C++%E5%A4%84%E7%90%86%E5%90%8C%E4%B8%80%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&text=学习Cpp-24"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&is_video=false&description=学习Cpp-24"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=学习Cpp-24&body=Check out this article: https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&name=学习Cpp-24&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&t=学习Cpp-24"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%AA%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text"> 伪私有方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text"> 类继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tips"><span class="toc-number">3.</span> <span class="toc-text"> Tips</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text"> 派生类与基类的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFis-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text"> 继承：is-a 关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text"> 多态公有继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> 虚析构函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">8.</span> <span class="toc-text"> 静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text"> 虚函数的工作原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.</span> <span class="toc-text"> 关于虚函数的注意事项</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        学习Cpp-24
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-04-23T12:40:26.000Z" class="dt-published" itemprop="datePublished">2024-04-23</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/life/">life</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：一般</p>
<hr />
<p>根本看不完啊，明天继续，我一定要看完这本书。</p>
<p>Tips：使用成员初始化列表的构造函数将覆盖相应的类内初始化。</p>
<h5 id="伪私有方法"><a class="markdownIt-Anchor" href="#伪私有方法"></a> 伪私有方法</h5>
<p>使用伪私有方法，能够阻止编译器生成默认的一些函数，而且此时由于是私有方法，这些默认函数就无法被公共调用，比如下面这个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">	<span class="built_in">Queue</span>(<span class="type">const</span> Queue &amp; q) : <span class="built_in">qsize</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 抢占式定义</span></span><br><span class="line">	Queue &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue &amp;q)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125; <span class="comment">// 该函数并没有实现，但是防止未来错误调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="类继承"><a class="markdownIt-Anchor" href="#类继承"></a> 类继承</h5>
<p>不在厂商提供的的源码上直接修改，防止引入错误，而是利用继承 wrap 来进行自定义重用。</p>
<p><strong>公有派生</strong>：</p>
<p>对于一个基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableTennisPlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span></span>;</span><br><span class="line">    string firstname,lastname;</span><br><span class="line">    <span class="type">int</span> hasTable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用公有派生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RatedPlayer</span> : <span class="keyword">public</span> TableTennisPlayer</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 此时继承了private的balance，但是不能直接访问它</span></span><br><span class="line"><span class="comment">//通过继承类的公有方法可以间接访问</span></span><br><span class="line"><span class="comment">// 可以直接范围protect和public方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>公有派生表示将 <code>TableTennisplayer</code> 的 <code>pulic</code> 放到该成员的 public 去（包括方法和接口），而 private 对象也会成为派生类的一部分，但是只能通过基类的公有和保护方法范围（protect 为继承而生）。</p>
<p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，<code>RatedPlayer</code> 构造函数不 能直接设置继承的成员（<code>firstname</code>、<code>lastname</code> 和 <code>hasTable</code>），而必须使用基类的公有方法来访问私有的基类 成员。具体地说，派生类构造函数必须使用基类构造函数。</p>
<p>对于派生的构造函数，结构如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RatedPlayer</span> : <span class="keyword">public</span> TableTennisPlayer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RatedPlayer</span>(usigned <span class="type">int</span> r=<span class="number">0</span>, <span class="type">const</span> string &amp;fn=<span class="string">&quot;none&quot;</span>, <span class="type">const</span> string &amp;ln=<span class="string">&quot;none&quot;</span>, <span class="type">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 第一个直接构造函数</span></span><br><span class="line">	<span class="built_in">RatedPlayer</span>(usigned <span class="type">int</span> r=<span class="number">0</span>, <span class="type">const</span> TableTennisPlayer &amp;tp); <span class="comment">// 第二个是通过基类的构造函数</span></span><br><span class="line">    <span class="comment">// 说明该类可以通过两种方法进行构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义该类的构造函数时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种如下</span></span><br><span class="line"><span class="built_in">RatedPlayer</span>(usigned <span class="type">int</span> r, <span class="type">const</span> string &amp;fn, <span class="type">const</span> string &amp;ln, <span class="type">bool</span> ht)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此时会默认调用基类的默认初始化函数给基类TableTennisPlayer赋值</span></span><br><span class="line">    <span class="comment">// 此时不会智能的将后面三个的参数值传递给TableTennisPlayer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有这样通过列表初始化才能正常传递参数</span></span><br><span class="line"><span class="built_in">RatedPlayer</span>(usigned <span class="type">int</span> r, <span class="type">const</span> string &amp;fn, <span class="type">const</span> string &amp;ln, <span class="type">bool</span> ht): <span class="built_in">TableTennisPlayer</span>(fn, ln, ht)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此时会默认初始化基类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第二个构造函数，我们也需要列表初始化才行。</p>
<p>有关派生类构造函数的要点如下： 首先创建基类对象； 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数； 派生类构造函数应初始化派生类新增的数据成员。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。</p>
<p>要使用派生类，派生类必须能访问到基类，通过 include 或者将两个类放在同一文件即可。</p>
<h5 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h5>
<p>头文件中引用的头文件应该是必须用到的文件，而对于头文件对应的函数需要用到的其他头文件，应该在头文件对应的函数文件中包含。</p>
<h5 id="派生类与基类的关系"><a class="markdownIt-Anchor" href="#派生类与基类的关系"></a> 派生类与基类的关系</h5>
<ol>
<li>
<p>派生类可以使用基类的方法，条件是该方法不是私有的</p>
</li>
<li>
<p>基类指针可以在不进行显示转化的情况下指向派生类对象，对引用也是一样（因为派生类本身就含有基类）。但是反过来不可以，派生类指针不能指向基类（缺失不可以）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时比如下面这种情况</span></span><br><span class="line"><span class="built_in">TableTennis</span>(<span class="type">const</span> TableTennisPlayer &amp;); <span class="comment">//这个构造函数</span></span><br><span class="line"><span class="comment">// 如果传入的是派生类也是可以的</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="继承is-a-关系"><a class="markdownIt-Anchor" href="#继承is-a-关系"></a> 继承：is-a 关系</h5>
<p>C++有三种继承方式，公有继承，保护继承和私有继承。公有继承是一种：is-a 关系。is-a 关系的意思是一个集合从属于另一个集合，即基类的各种成员是派生类的子集，同时派生类含有基类不含有的成员对象。还有一种关系是 has-a 关系，即某个东西有一定的概率在另一个集合里，比如午餐是水果，不代表午餐时水果的基类，这种情况下可以将水果作为午餐的一个成员变量。最后一种关系时 is-like-a 关系，比如人们常说律师是吸血鬼，不代表律师是吸血鬼，这种情况下可以设计一个包括公共特征的关系，然后两者在这个关系上使用 is-a 或者 has-a 关系定义其他的类。</p>
<h5 id="多态公有继承"><a class="markdownIt-Anchor" href="#多态公有继承"></a> 多态公有继承</h5>
<p>在继承中，我们也可以类似于 C++的函数一样，采取多态的方式，不同的是，这里是指同一个方法在不同类中的处理方法不一样，要实现这一点，我们需要采取的步骤如下：</p>
<ol>
<li>在派生类中重新定义基类方法</li>
<li>使用虚方法</li>
</ol>
<p>例如一个系统，对于 VIP 用户的签到和普通用户的签到，同一个方法，有两种不同的处理方式。如下所示，是采用虚方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Brass Account Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string fullName;</span><br><span class="line">        <span class="type">long</span> acctNum;</span><br><span class="line">        <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Brass</span>(<span class="type">const</span> std::string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Brass Plus Account Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span>: <span class="keyword">public</span> Brass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> maxLoan;</span><br><span class="line">    <span class="type">double</span> rate;</span><br><span class="line">    <span class="type">double</span> owesBank;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BrassPlus</span>(<span class="type">const</span> std::string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>,</span><br><span class="line">    <span class="type">double</span> ml = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    <span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp;ba, <span class="type">double</span> ml = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ResetMax</span><span class="params">(<span class="type">double</span> m)</span> </span>&#123;maxLoan = m;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ResetRate</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123;rate = r;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123;owesBank = <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类声明了一个虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数</span></span><br></pre></td></tr></table></figure>
<p>上面的基类和派生类中，两者都定义了方法，是两种方法。（我猜继承的方法会覆盖基类的方法）。而使用 virtual 关键词，如果方法是通过引用或指针而不是对象调用的，它将确定使 用哪一种方法。如果没有使用关键字 virtual，程序将根据引用类型或指针类型选择方法；如果使用了 virtual， 程序将根据引用或指针指向的对象的类型来选择方法。具体说如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;Dominic Banker&quot;</span>, <span class="number">11224</span>, <span class="number">4183.5</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;Dot Banker&quot;</span>, <span class="number">11224</span>, <span class="number">4183.5</span>)</span></span>;</span><br><span class="line">Brass &amp; bl_ref = dom;</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br><span class="line">b1_ref.<span class="built_in">ViewAcct</span>();</span><br><span class="line">b2_ref.<span class="built_in">ViewAcct</span>();</span><br><span class="line"><span class="comment">// 如果没有使用虚方法，上面两个都会使用Brass::ViewAcct()，也就是根据指针类型决定方法</span></span><br><span class="line"><span class="comment">// 而使用虚方法后，一个使用Brass::ViewAcct()，一个使用BrassPlus::ViewAcct()</span></span><br><span class="line"><span class="comment">// 也就是根据指向的对象决定使用方法</span></span><br></pre></td></tr></table></figure>
<p><strong>从上面可以看出，在一般中如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对 象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。</strong></p>
<h5 id="虚析构函数"><a class="markdownIt-Anchor" href="#虚析构函数"></a> 虚析构函数</h5>
<p>如果析构函数不是虚的，则将只调用对应于 <strong>指针类型</strong> 的析构函数。如果析构函数是虚的，将只会调用 <strong>相应对象类型</strong> 的析构函数。无论是否是虚方法，对于派生的类，其会先调用派生类的析构函数，再调用基类的析构函数。因此这里推荐，所有类都采用虚析构函数。</p>
<h5 id="静态联编和动态联编"><a class="markdownIt-Anchor" href="#静态联编和动态联编"></a> 静态联编和动态联编</h5>
<p>在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。然而，虚函数使这项工作变得更困难。使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。</p>
<p>C++中指针和引用的处理过程，如上所示，我们知道了动态联编，下面可以讨论指针和引用。</p>
<p>如下所示，派生类可以按值传递给基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BrassPlus a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pv</span><span class="params">(Brass b)</span></span>;</span><br><span class="line"><span class="built_in">pv</span>(a); <span class="comment">// 此时再pv函数内部调用a的方法会调用Brass的方法，而不是BrassPlus的方法</span></span><br></pre></td></tr></table></figure>
<p>再动态联编时，由于运行环境不同或者说输入不同导致不知道时基类还是派生类，编译器因此不知道该使用哪个方法，因此编译器此时采取动态联编。大多数情况下动态联编工作的都很好。</p>
<p>再默认情况下 C++都采用静态联编，因为动态联编需要额外的开销来跟踪是采取哪个方法，<strong>因此如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。</strong> 这样能节省性能。</p>
<h6 id="虚函数的工作原理"><a class="markdownIt-Anchor" href="#虚函数的工作原理"></a> 虚函数的工作原理</h6>
<p>虚函数的实现是由编译器来实现的，C++的规定只规定了虚函数的规则，具体实现需要看具体的编译器。对于通常的编译器，其实现方法如下所示：</p>
<p>对于定义了虚函数方法的类，其会添加一个隐藏成员，该成员保存了一个指向一个虚函数表，该表存储了该类所有的虚函数的地址。对于基类该表保存了其所有虚函数的函数指针，对于派生类，其表的存储地址于基类的虚函数表无关，保存了包括基类和自身派生的虚函数。</p>
<p>因此，当调用了虚函数时，其会首先再该对象的虚函数表中查表，确认所使用的函数。</p>
<p>这表明，使用虚函数会增大存储空间和性能存好。</p>
<h5 id="关于虚函数的注意事项"><a class="markdownIt-Anchor" href="#关于虚函数的注意事项"></a> 关于虚函数的注意事项</h5>
<ol>
<li>
<p>构造函数不能是虚函数。因为没有意义。</p>
</li>
<li>
<p>对于派生函数，其基类应该是虚函数。比如下面的代码，Singer 时 Employee 的派生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee *pe = <span class="keyword">new</span> Singer;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pe;</span><br><span class="line"><span class="comment">// 此时如果使用默认静态联编，会调用~Employee，而不是~Singer</span></span><br></pre></td></tr></table></figure>
<p>可以看出，对于需要派生的基类，其析构函数采用虚函数是必须的。而对于不需要派生的类，其析构函数也可以定义为虚函数，只是效率有可能会降低。</p>
</li>
<li>
<p>友元不能是虚函数，因为友元不是类成员，只有类成员才能是虚函数。</p>
</li>
<li>
<p>对于派生类中没有重新定义的基类方法（即不会覆盖或者隐藏基类方法），将会使用基类的方法。</p>
</li>
<li>
<p>对于重新定义，只要是同名就会隐藏基函数的方法（编译器会警告），不需要参数也要一致，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperk</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperk</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 会隐藏A的同名，不需要同样的参数列表，编译器会警告</span></span><br><span class="line">&#125;</span><br><span class="line">B test;</span><br><span class="line">test.<span class="built_in">showperks</span>(); <span class="comment">// 有效调用，因为覆盖隐藏了基类函数</span></span><br><span class="line">test.<span class="built_in">showperks</span>(<span class="number">5</span>); <span class="comment">// 无效调用</span></span><br></pre></td></tr></table></figure>
<p>这引出了两条经验规则：<strong>第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。</strong> 如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">showperk</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> B&amp; <span class="title">showperk</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span></span>; <span class="comment">//返回类型的引用不同，但是不会警告</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，这种例外只适用于返回值，而不适用于参数。</strong></p>
</li>
<li>
<p>如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;; <span class="comment">// 该类有三个同名但是不同参数列表的方法，这是合理的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: pulic A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// 需要都定义上面三个方法</span></span><br><span class="line">	<span class="comment">// 如果只定义其中一个，那么再派生类中，只有该类可以使用</span></span><br><span class="line">	<span class="comment">// 其余两个同名类无法使用</span></span><br><span class="line">    <span class="comment">// 如果不想修改其余两个类的功能，可以如下：</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">B::show</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>&#123;A::<span class="built_in">show</span>(a);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">B::show</span><span class="params">(<span class="type">double</span> x)</span><span class="type">const</span> </span>&#123;A::<span class="built_in">show</span>(x);&#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%AA%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text"> 伪私有方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text"> 类继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tips"><span class="toc-number">3.</span> <span class="toc-text"> Tips</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text"> 派生类与基类的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFis-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text"> 继承：is-a 关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text"> 多态公有继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> 虚析构函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">8.</span> <span class="toc-text"> 静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text"> 虚函数的工作原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.</span> <span class="toc-text"> 关于虚函数的注意事项</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&text=学习Cpp-24"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&is_video=false&description=学习Cpp-24"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=学习Cpp-24&body=Check out this article: https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&title=学习Cpp-24"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&name=学习Cpp-24&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/04/23/life/%E5%AD%A6%E4%B9%A0Cpp-24/&t=学习Cpp-24"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
