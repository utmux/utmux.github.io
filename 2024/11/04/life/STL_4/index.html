<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：好   list list 作为双向链表，比 vector 要复杂一点，首先 list 的 node 如下所示： 12345678struct _List_node_base &#123;  _List_node_base* _M_next;  _List_node_base* _M_prev;&#125;;template &lt;class _Tp&gt;struct _Li">
<meta property="og:type" content="article">
<meta property="og:title" content="STL_4">
<meta property="og:url" content="https://utmux.github.io/2024/11/04/life/STL_4/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：好   list list 作为双向链表，比 vector 要复杂一点，首先 list 的 node 如下所示： 12345678struct _List_node_base &#123;  _List_node_base* _M_next;  _List_node_base* _M_prev;&#125;;template &lt;class _Tp&gt;struct _Li">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/688a6ad1a06fa9ca790ab8b1d6083bc6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/40ff21a7c76dec81743b7c4f6e4d7d91.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/80e536e1e09d9d4d2f95c68137f13200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/cc562fc7ba32715979a66fe4a04e7dcd.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/8cf9dfa81b1d0277b5636866c1b03179.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/0c0967abccfe88ea2705c27098ed3a2a.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/80331f289407bebb99758fc403b5820b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/4fd944eccf46fb585d525656f9ac5ad9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/0c46c8b625c653da03e1c7f3b89ead35.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/1ef53d0eec74a7081811a013846b30f8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/4693caa2e9c76cbefee167babc169704.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/e7181cfd1fb07fcf0983b899a218d2f5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/5f4627b49edae25c055d8d67db4dfe25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/6e221fd864b1c58d5640d407bbe61495.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/cf78d26957630ba1cda4051b247914d2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/2e5aa47b54a0839b84e45439ae970c33.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/d972e9de5d601071594f61703624f279.png">
<meta property="article:published_time" content="2024-11-04T02:26:26.000Z">
<meta property="article:modified_time" content="2025-05-14T08:40:13.059Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/688a6ad1a06fa9ca790ab8b1d6083bc6.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>STL_4</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/11/05/life/acwing%E7%AE%97%E6%B3%95_%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/10/29/life/STL_3/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/11/04/life/STL_4/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/11/04/life/STL_4/&text=STL_4"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/11/04/life/STL_4/&is_video=false&description=STL_4"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL_4&body=Check out this article: https://utmux.github.io/2024/11/04/life/STL_4/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/11/04/life/STL_4/&name=STL_4&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/11/04/life/STL_4/&t=STL_4"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">1.</span> <span class="toc-text"> list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> list 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E6%9C%AC%E8%BA%AB%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text"> list 本身实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E7%9A%84%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text"> list 的其他函数实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> deque 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text"> deque 的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">2.2.</span> <span class="toc-text"> deque 的数据成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">3.</span> <span class="toc-text"> stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">4.</span> <span class="toc-text"> queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap"><span class="toc-number">5.</span> <span class="toc-text"> heap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#heap_push"><span class="toc-number">5.1.</span> <span class="toc-text"> heap_push()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop_heap"><span class="toc-number">5.2.</span> <span class="toc-text"> pop_heap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort_heap"><span class="toc-number">5.3.</span> <span class="toc-text"> sort_heap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#make_heap"><span class="toc-number">5.4.</span> <span class="toc-text"> make_heap()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority_queue"><span class="toc-number">6.</span> <span class="toc-text"> priority_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slist"><span class="toc-number">7.</span> <span class="toc-text"> slist</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        STL_4
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-11-04T02:26:26.000Z" class="dt-published" itemprop="datePublished">2024-11-04</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/life/">life</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：好</p>
<hr />
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h3>
<p>list 作为双向链表，比 vector 要复杂一点，首先 list 的 node 如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node_base</span> &#123;</span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span> : <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，分为数据和指针两部分。<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/688a6ad1a06fa9ca790ab8b1d6083bc6.png" alt="image-20241104102658020" /></p>
<h4 id="list-迭代器"><a class="markdownIt-Anchor" href="#list-迭代器"></a> list 迭代器</h4>
<p>list 的迭代器和 vector 不同，应该是双向迭代器（Bidirectional Iterator），1ist 不再能够像 vector 一样以普通指针（新版 GCC 采用模板）作为迭代器，因为其节点不保证在储存空间中连续存在。1ist 选代器必须有能力指向 1ist 的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。所谓“1ist 迭代器正确的递增、递减、取值、成员取用”操作是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取用的是节点的成员。</p>
<p>要对上面这些操作进行实现，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_iterator_base</span> &#123; <span class="comment">// 迭代器的基础属性</span></span><br><span class="line">  <span class="comment">// nested type 声明</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span>                     size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">  _List_node_base* _M_node; <span class="comment">// 原生指针，指向节点</span></span><br><span class="line"></span><br><span class="line">  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  _List_iterator_base() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line">  <span class="type">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> _List_iterator_base&amp; __x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _List_iterator_base&amp; __x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Ref</span>, <span class="keyword">class</span> <span class="title class_">_Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_iterator</span> : <span class="keyword">public</span> _List_iterator_base &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="type">const</span> _Tp&amp;,<span class="type">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</span><br><span class="line"></span><br><span class="line">  _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</span><br><span class="line">  _List_iterator() &#123;&#125;</span><br><span class="line">  _List_iterator(<span class="type">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dereference，获取data</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_incr();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前进一个节点， 后置返回值</span></span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; </span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_incr();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后退一个节点， 前置返回对象</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_decr();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123; </span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_decr();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="list-本身实现"><a class="markdownIt-Anchor" href="#list-本身实现"></a> list 本身实现</h4>
<p>SGI list 不仅是一个双向链表，而且还是个环状双向链表。所以它只需要<br />
一个指针，便可以完整表现整个链表。为了满足 STL 的前闭后开的要求，我们可以将最后一个节点设置为空节点，并在 list 中使用一个指针（即 <code>list.node</code>）始终指向它。</p>
<p>此时可以快速方便的实现下面这些操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> (_Node*)(_M_node-&gt;_M_next); &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (_Node*)(_M_node-&gt;_M_next); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> _M_node; &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _M_node; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _M_node-&gt;_M_next == _M_node; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  size_type __result = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), __result);</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>
<p>list 的操作如下图所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/40ff21a7c76dec81743b7c4f6e4d7d91.png" alt="image-20241104115540036" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 配置一个节点并返回指向该节点的指针</span></span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list_node_allocator::<span class="built_in">allocate</span>();  <span class="comment">// 使用分配器分配一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">        list_node_allocator::<span class="built_in">deallocate</span>(p);  <span class="comment">// 使用分配器释放一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生（配置并构造）一个节点，带有元素值</span></span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        link_type p = <span class="built_in">get_node</span>();  <span class="comment">// 分配一个节点</span></span><br><span class="line">        <span class="built_in">construct</span>(&amp;p-&gt;data, x);    <span class="comment">// 使用全局函数 construct 构造节点中的数据</span></span><br><span class="line">        <span class="keyword">return</span> p;                  <span class="comment">// 返回指向新节点的指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁（析构并释放）一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;p-&gt;data);  <span class="comment">// 使用全局函数 destroy 析构节点中的数据</span></span><br><span class="line">        <span class="built_in">put_node</span>(p);        <span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面是 list 提供的四个接口，用于操作节点，分别是创造和销毁节点这几种方法：</p>
<p>list 的默认构造函数如下（即插入一个节点在空白节点 node 之前）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化一个空链表</span></span><br><span class="line">    <span class="built_in">list</span>() &#123;</span><br><span class="line">        <span class="built_in">empty_initialize</span>();  <span class="comment">// 调用 empty_initialize 函数初始化链表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 初始化一个空链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        node = <span class="built_in">get_node</span>();  <span class="comment">// 配置一个节点空间，令 node 指向它</span></span><br><span class="line">        node-&gt;next = node;  <span class="comment">// 令 node 的 next 指针指向自己</span></span><br><span class="line">        node-&gt;prev = node;  <span class="comment">// 令 node 的 prev 指针指向自己，不设元素值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看出，默认初始化构造方法基本是插入一个节点在 node 之前。</p>
<p>下面来看 <code>insert</code> 函数，list 中的 <code>push_back()</code> 就是通过 insert 来实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>&#123;<span class="built_in">insert</span>(end, x);&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 insert 函数，其存在不同的重载形式，其实现和普通数据结构中双向链表的实现一致：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数目的：在迭代器 position 所指位置插入一个节点，内容为 x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    link_type tmp = <span class="built_in">create_node</span>(x);  <span class="comment">// 产生一个节点（设妥内容为 x）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整双向指针，使 tmp 插入进去</span></span><br><span class="line">    tmp-&gt;next = position.node;</span><br><span class="line">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">    (<span class="built_in">link_type</span>(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">    position.node-&gt;prev = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp);  <span class="comment">// 返回指向新插入节点的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/80e536e1e09d9d4d2f95c68137f13200.png" alt="image-20241104134222625" /></p>
<h4 id="list-的其他函数实现"><a class="markdownIt-Anchor" href="#list-的其他函数实现"></a> list 的其他函数实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个节点，作为头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="built_in">begin</span>(), x);  <span class="comment">// 在链表头部插入一个新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个节点，作为尾节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="built_in">end</span>(), x);  <span class="comment">// 在链表尾部插入一个新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除迭代器 position 所指节点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">    link_type next_node = <span class="built_in">link_type</span>(position.node-&gt;next);</span><br><span class="line">    link_type prev_node = <span class="built_in">link_type</span>(position.node-&gt;prev);</span><br><span class="line">    prev_node-&gt;next = next_node;</span><br><span class="line">    next_node-&gt;prev = prev_node;</span><br><span class="line">    <span class="built_in">destroy_node</span>(position.node);  <span class="comment">// 销毁节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);  <span class="comment">// 返回指向被移除节点的下一个节点的迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">erase</span>(<span class="built_in">begin</span>());  <span class="comment">// 移除链表的第一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = <span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">erase</span>(--tmp);  <span class="comment">// 移除链表的最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有节点（整个链表）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    link_type cur = (link_type) node-&gt;next;  <span class="comment">// begin()</span></span><br><span class="line">    <span class="comment">// 遍历每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != node) &#123;</span><br><span class="line">        link_type tmp = cur;</span><br><span class="line">        cur = (link_type) cur-&gt;next;</span><br><span class="line">        <span class="built_in">destroy_node</span>(tmp);  <span class="comment">// 销毁（析构并释放）一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复 node 原始状态</span></span><br><span class="line">    node-&gt;next = node;</span><br><span class="line">    node-&gt;prev = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值为 value 之所有元素移除</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;  <span class="comment">// 遍历每一个节点</span></span><br><span class="line">        iterator next = first;</span><br><span class="line">        ++next;</span><br><span class="line">        <span class="comment">// 找到就移除</span></span><br><span class="line">        <span class="keyword">if</span> (*first == value) <span class="built_in">erase</span>(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除数值相同的连续元素。注意，只有“连续而相同的元素”，才会被移除剩一个</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>() &#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 空链表，什么都不必做</span></span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">    iterator next = first;</span><br><span class="line">    <span class="comment">// 遍历每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">        <span class="comment">// 如果在此区段中有相同的元素</span></span><br><span class="line">        <span class="keyword">if</span> (*first == *next)</span><br><span class="line">            <span class="comment">// 移除之</span></span><br><span class="line">            <span class="built_in">erase</span>(next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 调整指针</span></span><br><span class="line">            first = next;</span><br><span class="line">        <span class="comment">// 修正区段范围</span></span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出其实现基本上都是双向链表，可以看出 clear 和 remove 两个函数的区别，一个是清除释放空间，所以传入空间指针等，一个是释放掉值和其空间，所以传入值，基本看一下 erase 函数即可，如下：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/cc562fc7ba32715979a66fe4a04e7dcd.png" alt="image-20241104134746775" /></p>
<p>list 还值得看的一个地方就是 transfer 函数，将某个连续范围（注意左闭右开）迁移到指定的 position 位置。具体代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [first, last) 内的所有元素移动到 position 之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position != last) &#123;</span><br><span class="line">        (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node;  <span class="comment">// (1)</span></span><br><span class="line">        (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node;     <span class="comment">// (2)</span></span><br><span class="line">        (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node; <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line">        link_type tmp = <span class="built_in">link_type</span>((*position.node).prev);         <span class="comment">// (4)</span></span><br><span class="line">        (*position.node).prev = (*last.node).prev;                <span class="comment">// (5)</span></span><br><span class="line">        (*last.node).prev = (*first.node).prev;                   <span class="comment">// (6)</span></span><br><span class="line">        (*first.node).prev = tmp;                                 <span class="comment">// (7)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/8cf9dfa81b1d0277b5636866c1b03179.png" alt="image-20241104140325252" /></p>
<p>transfer 函数可以用于两个不同的链表进行迁移，也可以是一个链表内部进行迁移。</p>
<p>transfer 函数并不是公开的接口，list 中公开的接口是 splice，该接口用于两个链表之间的剪切拼接，如下图所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/0c0967abccfe88ea2705c27098ed3a2a.png" alt="image-20241104141332656" /></p>
<p>splice 的底层就是通过调用 transfer 来实现的，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将 x 接合于 position 所指位置之前。x 必须不同于 *this</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 i 所指元素接合于 position 所指位置之前。position 和 i 可指向同一个 list</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator i)</span> </span>&#123;</span><br><span class="line">        iterator j = i;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">transfer</span>(position, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 [first, last) 内的所有元素接合于 position 所指位置之前</span></span><br><span class="line">    <span class="comment">// position 和 [first, last) 可指向同一个 list，但 position 不能位于 [first, last) 之内</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first != last)</span><br><span class="line">            <span class="built_in">transfer</span>(position, first, last);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除了 transfer，splice 外，list 还提供了 merge，reverse 和 sort 函数，如下所示：<br />
首先是 merge，用于将两个经过排序的链表进行合并：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge() 将 x 合并到 *this 身上。两个 lists 的内容都必须先经过递增排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">    iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">    iterator last2 = x.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：前提是，两个 lists 都已经过递增排序</span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">            iterator next = first2;</span><br><span class="line">            <span class="built_in">transfer</span>(first1, first2, ++next);</span><br><span class="line">            first2 = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++first1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first2 != last2) <span class="built_in">transfer</span>(last1, first2, last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reverse 函数用于将链表翻转（注意看清楚，不是 reserve），具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse() 将 *this 的内容逆向重置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下判断，如果是空链表，或仅有一个元素，就不进行任何操作</span></span><br><span class="line">    <span class="comment">// 使用 size() == 0 或 size() == 1 来判断，虽然也可以，但是比较慢</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>()) &#123;</span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++first;</span><br><span class="line">        <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此外，由于 list 的迭代器不符合 STL 迭代器容器的要求，所以其 sort 函数是单独实现的，STL 的 sort 函数也无法用于 list（Tips: STL 的 sort 方法只接收 Random Access Iterator，而 list 的迭代器是 Bidirectional Iterator）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下判断，如果是空链表，或仅有一个元素，就不进行任何操作</span></span><br><span class="line">    <span class="comment">// 使用 size() == 0 或 size() == 1 来判断，虽然也可以，但是比较慢</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些新的 lists，作为中介数据存放区</span></span><br><span class="line">    list&lt;T, Alloc&gt; carry;</span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);</span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == fill) ++fill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; ++i)</span><br><span class="line">        counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="deque-容器"><a class="markdownIt-Anchor" href="#deque-容器"></a> deque 容器</h3>
<p>deque 的底层是由 list 来实现的，和 vector 对比，vector 仅允许尾部的增删，而 deque 允许两端的增删，由于 deque 是由 list 实现的，所以 deque 和 vector 的最大差异，在于</p>
<ol>
<li>deque 允许在常数时间内对前端进行元素的插入或移除操作</li>
<li>deque 没有所谓容量（capacity）观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector 那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在 deque 是不会发生的。也因此，deque 没有必要提供所谓的空间保留（reserve）功能。</li>
</ol>
<p>deque 采用一块所谓的 <strong>map</strong>（注意，不是 STL 的 map 容器）作为主控。这里所谓的 map 是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是 deque 的储存空间主体。SGI STL 允许我们指定缓冲区大小，默认值 0 表示将使用 512 bytes 缓冲区。</p>
<p>把令人头皮发麻的各种型别定义（为了型别安全，那其实是有必要的）整理一下，我们便可发现，<strong>map</strong> 其实是一个 <code>T**</code>，也就是说它是一个指针，所指之物又是一个指针，指向型别为 T 的一块空间，如图 4-10 所示。</p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/80331f289407bebb99758fc403b5820b.png" alt="image-20241104151028061" /></p>
<p>如上图，也就是说 map 是一个指向指针的数组，且该数组会自动扩充。</p>
<h4 id="deque-的迭代器"><a class="markdownIt-Anchor" href="#deque-的迭代器"></a> deque 的迭代器</h4>
<p>由上面可以知道 deque 的空间是不连续的，所以 deque 的迭代器必须实现 <code>operator++</code> 和 <code>operator--</code> 将其映射到连续的空间上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> Bufsiz&gt; <span class="keyword">struct</span> <span class="title class_">deque_iterator</span> &#123;</span><br><span class="line">    <span class="comment">// 未继承std::iterator，所以必须自行撰写五个必要的迭代器相应型别（第3章）</span></span><br><span class="line">    <span class="keyword">typedef</span> deque_iterator&lt;T, T&amp;, T*, Bufsiz&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, Bufsiz&gt; const_iterator;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">deque_buf_size</span>(Bufsiz, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="comment">// 未继承std::iterator，所以必须自行撰写五个必要的迭代器相应型别（第3章）</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; <span class="comment">// (6)</span></span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> deque_iterator self; <span class="comment">// 保持与容器的联结</span></span><br><span class="line">    <span class="comment">// 此迭代器所指之缓冲区中的现行（current）元素</span></span><br><span class="line">    T* cur;</span><br><span class="line">    <span class="comment">// 此迭代器所指之缓冲区的头</span></span><br><span class="line">    T* first;</span><br><span class="line">    <span class="comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span></span><br><span class="line">    T* last;</span><br><span class="line">    <span class="comment">// 指向管控中心map</span></span><br><span class="line">    map_pointer node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>deque 中的 <code>buffer_size()</code> 函数用来决定缓冲区的大小，其会调用 <code>deque_buf_size()</code>，该函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 n 不为0，传回 n，表示 buffer size 由用户自定义</span></span><br><span class="line"><span class="comment">// 如果 n为0，表示buffer size 使用默认值，那么</span></span><br><span class="line"><span class="comment">// 如果 sz（元素大小，sizeof(value_type)）小于512，传回 512/sz，</span></span><br><span class="line"><span class="comment">// 如果 sz 不小于512，传回 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> _deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/4fd944eccf46fb585d525656f9ac5ad9.png" alt="image-20241104154840961" /></p>
<p>由于 deque 的特殊性，存在二级指针，所以其构造函数需要首先确定二级指针的大小，即 map 数组的大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化deque的map，根据元素数量来设置map的大小</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(<span class="type">size_t</span> __num_elements)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1 </span></span><br><span class="line">  <span class="type">size_t</span> __num_nodes = </span><br><span class="line">    __num_elements / __deque_buf_size(<span class="built_in">sizeof</span>(_Tp)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map要管理几个节点。最少 8个，最多是 “所需节点数加 2” </span></span><br><span class="line">  _M_map_size = <span class="built_in">max</span>((<span class="type">size_t</span>) _S_initial_map_size, __num_nodes + <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 配置出map空间</span></span><br><span class="line">  _M_map = _M_allocate_map(_M_map_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使现有节点在map内居中</span></span><br><span class="line">  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / <span class="number">2</span>;</span><br><span class="line">  _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line">    </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_create_nodes(__nstart, __nfinish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/0c46c8b625c653da03e1c7f3b89ead35.png" alt="image-20241104194340476" /></p>
<p>为了实现在碎片化的内存中能够使得迭代器正常工作，迭代器对下面这几个函数进行了定义如下所示：<br />
首先是，当 deque 的迭代器访问其中一个碎片内存块时，要确保不超过这个碎片内存块，此时我们需要获取该碎片快的大小和起始点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">    <span class="comment">// buffer_size()返回当前内存块的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下各个重载运算符是 deque_iterator&lt;&gt; 成功运作的关键</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较当前内存块的cur指针和x内存块所在的cur指针两者之间的差了多少个值</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">           (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参考 More Effective C++， item 6: Distinguish between prefix and</span></span><br><span class="line"><span class="comment">// postfix forms of increment and decrement operators</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="comment">// 切换至下一个元素</span></span><br><span class="line">    ++cur;</span><br><span class="line">    <span class="comment">// 如果已达所在缓冲区的尾端</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;</span><br><span class="line">        <span class="comment">// 就切换至下一节点（亦即缓冲区）</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 的第一个元素</span></span><br><span class="line">        cur = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">// 后置式，标准写法</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="comment">// 如果已达所在缓冲区的头端</span></span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line">        <span class="comment">// 就切换至前一节点（亦即缓冲区）</span></span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 的最后一个元素</span></span><br><span class="line">        cur = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切换至前一个元素</span></span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123; <span class="comment">// 后置式，标准写法</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下实现随机存取。迭代器可以直接跳跃n个距离</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) &#123;</span><br><span class="line">        <span class="comment">// 目标位置在同一缓冲区内</span></span><br><span class="line">        cur += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 目标位置不在同一缓冲区内</span></span><br><span class="line">        difference_type node_offset =</span><br><span class="line">            offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">                      : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换至正确的节点（亦即缓冲区）</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        <span class="comment">// 切换至正确的元素</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考 More Effective C++, item 22: Consider using op= instead of</span></span><br><span class="line"><span class="comment">// stand-alone op</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> += -n; <span class="comment">// 利用operator+= 来完成 operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考 More Effective C++, item 22: Consider using op= instead of</span></span><br><span class="line"><span class="comment">// stand-alone op.</span></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下实现随机存取。迭代器可以直接跳跃 n 个距离</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"><span class="comment">// 以上调用operator*，operator+</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deque-的数据成员"><a class="markdownIt-Anchor" href="#deque-的数据成员"></a> deque 的数据成员</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Iterators</span></span><br><span class="line"><span class="keyword">typedef</span> _deque_iterator&lt;T, T&amp;, T*, Bufsiz&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Internal typedefs</span></span><br><span class="line"><span class="comment">// 元素的指针的指针（pointer of pointer of T）</span></span><br><span class="line"><span class="keyword">typedef</span> T* pointer; <span class="comment">// 先定义T* pointer</span></span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer; <span class="comment">// 然后定义pointer* map_pointer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Data members</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 表现第一块内存的第一个节点</span></span><br><span class="line">iterator start;</span><br><span class="line"><span class="comment">// 表现最后一块内存的最后一个节点</span></span><br><span class="line">iterator finish;</span><br><span class="line"><span class="comment">// 指向map，map是一块连续空间</span></span><br><span class="line">map_pointer map;</span><br><span class="line"><span class="comment">// 其每个元素都是一个指针，指向一个节点（缓冲区）</span></span><br><span class="line">size_type map_size; <span class="comment">// map内有多少指针</span></span><br></pre></td></tr></table></figure>
<p>deque 的缓冲区扩充操作相当复杂，以下将以分解操作的方式一步一步进行图解说明。程序一开始声明了一个 deque：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">deque&lt;<span class="type">int</span>, allocator, 32&gt; <span class="title">ideg</span><span class="params">(<span class="number">20</span>, <span class="number">9</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其缓冲区大小为 32 字节，并令其保留 20 个元素空间，每个元素初值为 9。<br />
为了指定 deque 的第三个 template 参数（缓冲区大小），我们必须将前两个参数都指明出来（这是 C++语法规则），因此必须明确指定 allocator（第二章）为空间配置器。现在，deque 的情况如图 4-12（该图并未显示每个元素的初值为 9）所示。</p>
<p>deque 中有两个 <code>alloc</code>，分别用于节点和存储节点的数组进行分配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal typedefs</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个指针大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并提供一个 constructor 如下：</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n, <span class="type">const</span> value_type&amp; value)</span><br><span class="line">: <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fill_initialize</span>(n, value);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">fill_initialize</span>(size_type n,</span><br><span class="line"><span class="type">const</span> value_type&amp; value) &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(n); <span class="comment">// 把deque的结构都产生并安排好</span></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    _STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 为每个节点的缓冲区设定初值</span></span><br><span class="line">        <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line">        <span class="comment">// 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值）</span></span><br><span class="line">        <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// 异常处理代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，其指定大小的构造函数首先是用于构造能够映射 n 个节点的 map 数组，在对每个 map 数组所指向的内存段进行赋值。其中 <code>create_map_and_nodes()</code> 负责将 map 数组和其对应 nodes 创建好，并设置好指针的指向关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) &#123;</span><br><span class="line">    <span class="comment">// 需要节点数 = （元素个数 / 每个缓冲区可容纳的元素个数） + 1</span></span><br><span class="line">    <span class="comment">// 如果刚好整除，会多配一个节点</span></span><br><span class="line">    size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 一个map要管理几个节点。最少8个，最多是所需节点数加2&quot;</span></span><br><span class="line">    <span class="comment">// （前后各预留一个，扩充时可用）</span></span><br><span class="line">    size_type map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">    map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line">    <span class="comment">// 以上配置出一个具有 map_size个节点的map</span></span><br><span class="line">    <span class="comment">// 以下令start和finish指向map所拥有之全部节点的最中央区段</span></span><br><span class="line">    <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区</span></span><br><span class="line">    map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">    map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">    map_pointer cur;</span><br><span class="line">    STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 为map内的每个现用节点配置缓冲区。所有缓冲区加起来就是deque的</span></span><br><span class="line">        <span class="comment">// 可用空间（最后一个缓冲区可能留有一些余裕）</span></span><br><span class="line">        <span class="keyword">for</span> (cur = nstart; cur &lt; nfinish; ++cur)</span><br><span class="line">            *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// &quot;commit or rollback&quot;语意：若非全部成功，就一个都不留</span></span><br><span class="line">        <span class="comment">// 这里应该添加释放已分配节点的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为deque内的两个迭代器start和end设定正确内容</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">    <span class="comment">// first，cur都是public</span></span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    finish.cur = finish.first + (num_elements % <span class="built_in">buffer_size</span>());</span><br><span class="line">    <span class="comment">// 前面说过，如果刚好整除，会多配一个节点</span></span><br><span class="line">    <span class="comment">// 此时即令cur指向这多配的一个节点（所对应的缓冲区）的起始处</span></span><br><span class="line">    <span class="comment">// 即 (num_elements % buffer_size()) = 0,代表起始处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/1ef53d0eec74a7081811a013846b30f8.png" alt="image-20241105103245969" /></p>
<p>使用 <code>push_back()</code> 函数，会在 finish 那一端增减（相反 <code>push_front()</code> 从 start 那一端传入值），如果空间不足，此时会调用：<code>push_back_aux()</code> 进行扩容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push_* and pop_*</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后缓冲区尚有一个以上的备用空间</span></span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t); <span class="comment">// 直接在备用空间上构造元素</span></span><br><span class="line">        <span class="comment">// 调整最后缓冲区的使用状态</span></span><br><span class="line">        ++finish.cur;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 最后缓冲区已无（或只剩一个）元素备用空间</span></span><br><span class="line">        <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>push_back_aux()</code> 需要调整 map 数组，重新申请一个 map 数组，并设置 finish 指针指向，并将值填入到新的 finish 内存段中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当 finish.cur == finish.last - 1 时才会被调用</span></span><br><span class="line"><span class="comment">// 也就是说，只有当最后一个缓冲区只剩一个备用元素空间时才会被调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="comment">// 若符合某种条件则必须重换一个map</span></span><br><span class="line">    <span class="built_in">reserve_map_at_back</span>();</span><br><span class="line">    *(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>(); <span class="comment">// 配置一个新节点（缓冲区）;</span></span><br><span class="line">    _STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 针对标的元素设值</span></span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t_copy);</span><br><span class="line">        <span class="comment">// 改变finish，令其指向新节点</span></span><br><span class="line">        finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设定finish的状态</span></span><br><span class="line">        finish.cur = finish.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">STL_UNWIND</span>(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/4693caa2e9c76cbefee167babc169704.png" alt="acd40eac35699ac45a00ae7670f0eb4" /></p>
<p><code>push_front()</code> 和 <code>push_back()</code> 类似，空间不足时会调用 <code>push_front_aux()</code>，该函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当 start.cur == start.first 时才会被调用</span></span><br><span class="line"><span class="comment">// 也就是说，只有当第一个缓冲区没有任何备用元素时才会被调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="comment">// 若符合某种条件则必须重换一个map</span></span><br><span class="line">    <span class="built_in">reserve_map_at_front</span>();</span><br><span class="line">    <span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">    *(start.node - <span class="number">1</span>) = <span class="built_in">allocate_node</span>();</span><br><span class="line">    STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 改变 start，令其指向新节点</span></span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设定 start 的状态</span></span><br><span class="line">        start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 针对标的元素设值</span></span><br><span class="line">        <span class="built_in">construct</span>(start.cur, t_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// &quot;commit or rollback&quot;语意：若非全部成功，就一个不留</span></span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，判断 map 是否需要重新申请空间，是由：<code>reserve_map_at_front()</code> 和 <code>reserve_map_at_back()</code>，其源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map)) &#123;</span><br><span class="line">        <span class="comment">// 如果map尾端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件则必须重换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - map) &#123;</span><br><span class="line">        <span class="comment">// 如果map前端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件则必须重换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add, <span class="type">bool</span> add_at_front) &#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line">    map_pointer new_nstart;</span><br><span class="line">    <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">        new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                    + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 配置一块空间，准备给新map使用</span></span><br><span class="line">        map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                    + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 把原map内容拷贝过来</span></span><br><span class="line">        <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="comment">// 释放原map</span></span><br><span class="line">        map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">        <span class="comment">// 设定新map的起始地址与大小</span></span><br><span class="line">        map = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新设定迭代器 start和 finish</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pop_back 和 pop_front，insert，clear 和 find</p>
<p>上面介绍了 <code>push_back()</code> 和 <code>push_front()</code> 这两个，<code>pop_back()</code> 和 <code>pop_front()</code> 逻辑和上面基本一致。</p>
<p>然后 <code>erase()</code> 是在 <code>pop_back()</code> 和 <code>pop_front()</code> 上实现的，首先将元素移动，再使用 <code>pop_back()</code> 或者 <code>pop_front()</code> 来实现清除元素的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 pos 所指的元素。pos 为清除点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start; <span class="comment">// 清除点之前的元素个数</span></span><br><span class="line">    <span class="comment">// 如果清除点之前的元素比较少，</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 就移动清除点之前的元素</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(start, pos, next);</span><br><span class="line">        <span class="comment">// 移动完毕，最前一个元素空闲，去除之</span></span><br><span class="line">        <span class="built_in">pop_front</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清除点之后的元素比较少，</span></span><br><span class="line">        <span class="comment">// 就移动清除点之后的元素</span></span><br><span class="line">        <span class="built_in">copy</span>(next, finish, pos);</span><br><span class="line">        <span class="comment">// 移动完毕，最后一个元素空闲，去除之</span></span><br><span class="line">        <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要清除一段区间，和 <code>insert()</code> 插入一个区间类似，首先判断剩余空间是否足够，再判断插入点的位置来决定搬移的策略。对于 <code>erase()</code> 首先判断清除的区间靠近哪一端，再将 start 或者 finish 进行移动即可，由于之前实现了 deque 的迭代器操作，所以其移动可以很容易利用迭代器实现，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123; <span class="comment">// 如果清除区间就是整个deque</span></span><br><span class="line">        <span class="comment">// 直接调用clear()即可</span></span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除区间的长度</span></span><br><span class="line">    difference_type n = last - first;</span><br><span class="line">    <span class="comment">// 清除区间前方的元素个数</span></span><br><span class="line">    difference_type elems_before = first - start;</span><br><span class="line">    <span class="comment">// 如果前方的元素比较少，</span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 向后移动前方元素（覆盖清除区间）</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(start, first, last);</span><br><span class="line">        <span class="comment">// 标记deque的新起点</span></span><br><span class="line">        iterator new_start = start + n;</span><br><span class="line">        <span class="comment">// 移动完毕，将余的元素析构</span></span><br><span class="line">        <span class="built_in">destroy</span>(start, new_start);</span><br><span class="line">        <span class="comment">// 以下将余的缓冲区释放</span></span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">        <span class="comment">// 设定deque的新起点</span></span><br><span class="line">        start = new_start;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果清除区间后方的元素比较少</span></span><br><span class="line">        <span class="comment">// 向前移动后方元素（覆盖清除区间）</span></span><br><span class="line">        <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">        <span class="comment">// 标记deque的新尾点</span></span><br><span class="line">        iterator new_finish = finish - n;</span><br><span class="line">        <span class="comment">// 移动完毕，将余的元素析构</span></span><br><span class="line">        <span class="built_in">destroy</span>(new_finish, finish);</span><br><span class="line">        <span class="comment">// 以下将余的缓冲区释放</span></span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">        <span class="comment">// 设定deque的新尾点</span></span><br><span class="line">        finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + elems_before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只需要注意的是 <code>copy_backward()</code>，由于迭代器实现了对 map 的映射操作，所以当 <code>copy_backward()</code> 调用时，对于内存不连续的块也会正常的工作。</p>
<p>和 <code>erase()</code> 类似，<code>insert()</code> 插入一个区间的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, Bufsize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type&amp; x) &#123;</span><br><span class="line">    <span class="comment">// 插入点之前的元素个数</span></span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="comment">// 如果插入点之前的元素个数比较少</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 在最前端加入与第一元素同值的元素</span></span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">// 以下标示记号，然后进行元素移动</span></span><br><span class="line">        iterator front1 = start;</span><br><span class="line">        ++front1;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        ++front2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        ++pos1;</span><br><span class="line">        <span class="comment">// 元素移动</span></span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 插入点之后的元素个数比较少</span></span><br><span class="line">        <span class="comment">// 在最尾端加入与最后元素同值的元素</span></span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        <span class="comment">// 以下标示记号，然后进行元素移动</span></span><br><span class="line">        iterator back1 = finish;</span><br><span class="line">        --back1;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        --back2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        <span class="comment">// 元素移动</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy; <span class="comment">// 在插入点上设定新值</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> stack</h3>
<p>stack 的底层就是一个 <code>deque</code> 值得注意的是，此时 stack 是 <strong>不存在迭代器的</strong> 实现的，其 <strong>不提供随机访问功能</strong>，也不提供迭代器。除了 <code>deque</code> 可以作为 stack 的底层，<code>list</code> 也可以作为 stack 的底层，只需要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; mystack;</span><br></pre></td></tr></table></figure>
<p>其底层调用的就是 <code>deque</code> 或者 <code>list</code> 的函数。</p>
<h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> queue</h3>
<p>queue 作为一种先进先出的队列，默认情况下是使用 <code>deque</code> 作为底层实现的，故其代码也比较简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span> &#123;</span><br><span class="line">    <span class="comment">// 以下 STL_NULL_TMPL_ARGS 会展开为 &lt;&gt;，见1.9.1节</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==_STL_NULL_TMPL_ARGS(<span class="type">const</span> queue&amp; X, <span class="type">const</span> queue&amp; Y);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;_STL_NULL_TMPL_ARGS(<span class="type">const</span> queue&amp; X, <span class="type">const</span> queue&amp; Y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 底层容器</span></span><br><span class="line">    Sequence c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以下完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque是两头可进出，queue是末端进、前端出（所以先进者先出）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 stack 一样，只提供访问队头和队尾的功能，<strong>不提供迭代器，不提供随机访问功能</strong>。</p>
<p>除了 <code>deque</code>，我们也可以指定底层使用 <code>list</code> 实现，</p>
<h3 id="heap"><a class="markdownIt-Anchor" href="#heap"></a> heap</h3>
<p>heap 不属于 STL 容器，它是个幕后英雄，扮演 priority queue（4.8 节）的助手。顾名思义，priority queue 允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）的元素开始取。binary max heap 正是具有这样的特性，适合作为 priority queue 的底层机制。</p>
<p>让我们做一点分析。如果使用 4.3 节的 list 作为 priority queue 的底层机制，元素插入操作可享受常数时间。但是要找到 list 中的极值，却需要对整个 list 进行线性扫描。我们也可以改变做法，让元素插入前先经过排序这一关，使得 list 的元素值总是由小到大（或由大到小），但这么一来，收之东隅却失之桑榆：虽然取得极值以及元素删除操作达到最高效率，可元素的插入却只有线性表现。</p>
<p>比较麻烦的做法是以 binary search tree（如 5.1 节的 RB-tree）作为 priority queue 的底层机制。这么一来，元素的插入和极值的取得就有 O(log N)的表现。但杀鸡用牛刀，未免小题大做，一来 binary search tree 的输入需要足够的随机性，二来 binary search tree 并不容易实现。<strong>priority queue 的复杂度，最好介于 queue 和 binary search tree 之间</strong>，才算适得其所。binary heap（即二叉树）便是这种条件下的适当候选人。使用完全二叉树作为底层架构，能满足插入和查找最大值都是线性时间。</p>
<p>binary heap 分为两种，max heap 和 min heap，如果我们使用 array 来存储二叉树，此时就有左节点为 <code>2i</code>，右节点 <code>2i+1</code>，但是 array 是固定的大小。所以我们一般使用 <strong>vector 作为 binary heap</strong> 的底层架构（如果树的大小恒定，使用 array 应该效率相比更加高）。</p>
<h4 id="heap_push"><a class="markdownIt-Anchor" href="#heap_push"></a> heap_push()</h4>
<p>为了保持二叉树的有序性，需要对其插入的过程保持有序，如下所示，堆中如果节点大于父节点，则交换顺序。<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/e7181cfd1fb07fcf0983b899a218d2f5.png" alt="image-20241105151137106" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，此函数被调用时，新元素应已置于底部容器的最尾端</span></span><br><span class="line">    <span class="built_in">push_heap_aux</span>(first, last, <span class="built_in">distance_type</span>(first),</span><br><span class="line">                  <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap_aux</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator last, Distance*, T*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">push_heap</span>(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 以上是根据 implicit representation heap 的结构特性：新值必置于底部</span></span><br><span class="line">    <span class="comment">// 容器的最尾端，此即第一个洞号：（last - first) - 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 push_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, Distance holeIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">               Distance topIndex, T value)</span> </span>&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找出父节点</span></span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line">        <span class="comment">// 由于以上使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父），</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent); <span class="comment">// 令洞值为父值</span></span><br><span class="line">        holeIndex = parent; <span class="comment">// percolate up：调整洞号，向上提升至父节点</span></span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 新洞的父节点</span></span><br><span class="line">    &#125; <span class="comment">// 持续至顶端，或满足 heap 的次序特性为止</span></span><br><span class="line">    *(first + holeIndex) = value; <span class="comment">// 令洞值为新值，完成插入操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码就是对上图的实现，通过比较子节点和父节点之间的大小，然后进行交换，中间套了一层娃是为了将 first 和 last 提取节点的类型以及提取出父节点和子节点的序号。</p>
<h4 id="pop_heap"><a class="markdownIt-Anchor" href="#pop_heap"></a> pop_heap()</h4>
<p>对于有序排列的堆，pop 都是弹出根节点。为了使得弹出后堆序列仍然有序，其实际是首先将根节点移动到叶子节点，再进行删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                     RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pop_heap_aux</span>(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap_aux</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator last, T*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pop_heap</span>(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)),</span><br><span class="line">             <span class="built_in">distance_type</span>(first));</span><br><span class="line">    <span class="comment">// 以上，根据 implicit representation heap 的次序特性，pop 操作的结果</span></span><br><span class="line">    <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上将迭代器 result 设为 last - 1）·然后重整 [first，last - 1），</span></span><br><span class="line">    <span class="comment">// 使之重新成一个合格的 heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 pop_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                     RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     RandomAccessIterator result,</span></span></span><br><span class="line"><span class="params"><span class="function">                     T value, Distance*)</span> </span>&#123;</span><br><span class="line">    *result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">                     <span class="comment">// 可由客户端稍后再以底层容器之 pop_back() 取出尾值</span></span><br><span class="line">    _adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（源尾值）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这个 adjust_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="comment">// adjust_heap()用于重排指定的子树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> _adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value) &#123;</span><br><span class="line">    Distance topIndex = holeIndex;</span><br><span class="line">    Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>; <span class="comment">// 洞节点之右子节点</span></span><br><span class="line">    <span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line">        <span class="comment">// 比较洞节点之左右两个子值，然后以 secondChild 代表较大子节点</span></span><br><span class="line">        <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">            secondChild--;</span><br><span class="line">        <span class="comment">// Percolate down：令较大子值为洞值，再令洞号下移至较大子节点处</span></span><br><span class="line">        *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">        holeIndex = secondChild;</span><br><span class="line">        <span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line">        secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右子节点超出范围，则检查左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (secondChild == len) &#123;</span><br><span class="line">        *(first + holeIndex) = *(first + (len - <span class="number">1</span>));</span><br><span class="line">        holeIndex = len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后，将调整值放到正确的位置</span></span><br><span class="line">    <span class="comment">// 将欲调整值填入目前的洞号内。注意，此时肯定满足次序特性</span></span><br><span class="line">    <span class="comment">// 依侯捷之见，下面直接改为 *(first + holeIndex) = value; 应该可以</span></span><br><span class="line">    <span class="comment">// FIX:实际上，对于push_back这种情况可以，但是对于下面的make_queue就说不通了</span></span><br><span class="line">    __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/5f4627b49edae25c055d8d67db4dfe25.png" alt="image-20241105191227866" /></p>
<p>如上所示，首先将根节点填入最后一个叶子节点，然后从根节点开始排序到倒数第一个节点（根节点被 pop 了，所以少一个），从上到下，值得注意的是排序时，由于最后一个子树有可能不存在右子树，所以要单独处理。</p>
<h4 id="sort_heap"><a class="markdownIt-Anchor" href="#sort_heap"></a> sort_heap()</h4>
<p>上面的堆只满足了，父母节点一定大于等于子节点这个性质，也就是说根节点一定是最大值，如果我们需要一个从大到小的序列，此时我们就可以利用上面的 <code>pop_heap()</code> 不断弹出最大值，这个就是 <code>sort_heap()</code> 的原理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下这个 sort_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">               RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以下，每执行一次 pop_heap(), 极值（在 STL heap中为极大值）即被放在尾端。</span></span><br><span class="line">    <span class="comment">// 扣除尾端再执行一次 pop_heap(), 次极值又被放在新尾端。一直下去，最后即得</span></span><br><span class="line">    <span class="comment">// 排序结果</span></span><br><span class="line">    <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pop_heap</span>(first, last--); <span class="comment">// 每执行 pop_heap() 一次，操作范围即退缩一格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="make_heap"><a class="markdownIt-Anchor" href="#make_heap"></a> make_heap()</h4>
<p>如果我们需要将一组无序数据转化为一个 heap，使用 <code>make_heap()</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [first, last] 排列为一个 heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                      RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">make_heap</span>(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这组 make_heap() 不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">               RandomAccessIterator last, T*, Distance*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 如果长度为0或1，不必重新排列</span></span><br><span class="line">    Distance len = last - first; <span class="comment">// 计算堆的长度</span></span><br><span class="line">    <span class="comment">// 找出第一个需要重排的子树头部，以 parent 标示出，由于任何根节点都不需执行</span></span><br><span class="line">    <span class="comment">// percolate down，所以有以下计算。parent 命名不佳，名为 holeIndex 更好</span></span><br><span class="line">    Distance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 为首的子树。len 是为了让 _adjust_heap() 判断操作范围</span></span><br><span class="line">        _adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">        <span class="comment">// 走完根节点，就结束</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// （即将重排之子树的）头部向前一个节点</span></span><br><span class="line">        parent--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看一下 <code>_adjust_heap(first, parent, len, T(*(first + parent)))</code>，他的意思是将 <code>parent</code> 节点（叫做 <code>holeIndex</code> 更好）移动到叶子上，并填写为值 <code>*(first + parent))</code>，该树的长度为 <code>len</code>。此时该函数会从 parent 节点开始，将 parent 节点替换为其左右节点中较大的一个，然后将 parent 节点指向被替换的左右节点，继续进行循环。一直到最后的节点。</p>
<p>综上，该函数的思路是，将所有的值初始化到一个树中，然后从末端的子树开始排序，每次排序会使子树变为有序的堆。自下而上。</p>
<p><strong>heap 同样不提供迭代器和遍历功能。</strong></p>
<h3 id="priority_queue"><a class="markdownIt-Anchor" href="#priority_queue"></a> priority_queue</h3>
<p>priority_queue 的底层就可以直接用上面的 heap 来实现，从而总是最大的出队，最小的入队。具体方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    _STL_TRY &#123;</span><br><span class="line">        <span class="comment">// push_heap是泛型算法，先利用底层容器的push_back()将新元素</span></span><br><span class="line">        <span class="comment">// 推入末尾，再重排heap。见C++ Primer P.1195</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">// push_heap是泛型算法</span></span><br><span class="line">    &#125;</span><br><span class="line">    _STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _STL_TRY &#123;</span><br><span class="line">        <span class="comment">// pop_heap是泛型算法，从heap内取出一个元素。它并不是真正将元素</span></span><br><span class="line">        <span class="comment">// 弹出，而是重排heap，然后再以底层容器的pop_back()取得被弹出</span></span><br><span class="line">        <span class="comment">// 的元素。见C++ Primer P.1195</span></span><br><span class="line">        <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist"><a class="markdownIt-Anchor" href="#slist"></a> slist</h3>
<p>slist 和 list 不同，slist 是一个单向链表，而 list 是一个双向的链表。故前者的迭代器是 Forward Iterator，而后者是 Bidirectional Iterator。slist 相比 list，所占用空间更小，某些操作可能更加快。</p>
<p>注意，根据 STL 的习惯，插入操作会将新元素插入于指定位置之前，而非之后。然而作为一个单向链表，slist 没有任何方便的办法可以回头找出前一个位置，因此它必须从头找起。换句话说，<strong>除了 slist 起点处附近的区域之外，在其它位置上采用 insert 或 erase 操作函数，都属不智之举。</strong> 这便是 slist 相较于 list 之下的大缺点。为此，<strong>slist 特别提供了 insert_after()和 erase_after()供灵活运用。</strong></p>
<p>基于同样的（效率）考虑，slist 不提供 <strong>push_back()</strong>，只提供 <strong>push_front()</strong>。因此 slist 的元素次序会和元素插入进来的次序相反。</p>
<p>slist 相比 list，其用到了多个继承关系，比较复杂，如下图所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/6e221fd864b1c58d5640d407bbe61495.png" alt="image-20241105212403379" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表的节点基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">slist_node_base</span> &#123;</span><br><span class="line">    slist_node_base* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表的节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">slist_node</span> : <span class="keyword">public</span> slist_node_base &#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数：已知某一节点，插入新节点于其后</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> slist_node_base* <span class="title">list_make_link</span><span class="params">(slist_node_base* prev_node, slist_node_base* new_node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    <span class="comment">// 令prev节点的下一节点指向new节点</span></span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">    <span class="keyword">return</span> new_node; <span class="comment">// 返回new节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数：单向链表的大小（元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">slist_size</span><span class="params">(slist_node_base* node)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123; <span class="comment">// 一个一个累计</span></span><br><span class="line">        ++result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是节点的数据结构，下面是迭代器的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向串行的迭代器基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Slist_iterator_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span>               size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>            difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category; <span class="comment">// 单向</span></span><br><span class="line"></span><br><span class="line">  _Slist_node_base* _M_node; <span class="comment">// 指向节点基本结构</span></span><br><span class="line"></span><br><span class="line">  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  <span class="type">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> _Slist_iterator_base&amp; __x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _Slist_iterator_base&amp; __x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向串行的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Ref</span>, <span class="keyword">class</span> <span class="title class_">_Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Slist_iterator</span> : <span class="keyword">public</span> _Slist_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Slist_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Slist_iterator&lt;_Tp, <span class="type">const</span> _Tp&amp;, <span class="type">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Slist_iterator&lt;_Tp, _Ref, _Ptr&gt;             _Self;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Tp              value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr             pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref             reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Slist_node&lt;_Tp&gt; _Node;</span><br><span class="line"></span><br><span class="line">  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) &#123;&#125;</span><br><span class="line">  <span class="comment">//呼叫 slist&lt;T&gt;::end()时会造成 __slist_iterator(0)，于是唤起上述函式。</span></span><br><span class="line">  <span class="comment">// 看不懂上面的注解</span></span><br><span class="line">  _Slist_iterator() : _Slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Slist_iterator(<span class="type">const</span> iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">  &#123;</span><br><span class="line">    _M_incr(); <span class="comment">// 前进一个节点</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_incr();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体单项迭代器的代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">slist</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> slist_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> slist_node&lt;T&gt; list_node;</span><br><span class="line">    <span class="keyword">typedef</span> slist_node_base list_node_base;</span><br><span class="line">    <span class="keyword">typedef</span> slist_iterator_base iterator_base;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;list_node, Allocator&gt; list_node_allocator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> list_node* <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        list_node* node = list_node_allocator::<span class="built_in">allocate</span>(); <span class="comment">// 分配空间</span></span><br><span class="line">        STL_TRY &#123;</span><br><span class="line">            <span class="comment">// 构造元素</span></span><br><span class="line">            <span class="built_in">construct</span>(&amp;node-&gt;data, x);</span><br><span class="line">            node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _STL_UNWIND(list_node_allocator::<span class="built_in">deallocate</span>(node));</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将元素析构</span></span><br><span class="line">        <span class="built_in">destroy</span>(&amp;node-&gt;data);</span><br><span class="line">        <span class="comment">// 释放空间</span></span><br><span class="line">        list_node_allocator::<span class="built_in">deallocate</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list_node_base head; <span class="comment">// 头部注意，它不是指针，是实物</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">slist</span>() : head.<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">slist</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _slist_size(head.next); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head.next == <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个slist互换：只要将head交换互指即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span> </span>&#123;</span><br><span class="line">    list_node_base* tmp = head.next;</span><br><span class="line">    head.next = L.head.next;</span><br><span class="line">    L.head.next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取头部元素</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ((list_node*)head.next)-&gt;data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从头部插入元素（新元素成为slist的第一个元素）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">slist_make_link</span>(&amp;head, <span class="built_in">create_node</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，没有 push_back()</span></span><br><span class="line"><span class="comment">// 从头部取走元素（删除之）。修改head</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list_node* node = (list_node*)head.next;</span><br><span class="line">    head.next = node-&gt;next;</span><br><span class="line">    <span class="built_in">destroy_node</span>(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意 <code>end()</code> 函数：<code>iterator end() &#123; return iterator(nullptr); &#125;</code>，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">slist_iterator</span>&lt;T, T&amp;, T*&gt;(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 也就是，如下会产生一个单独的迭代器，其node指向nullptr,数据是空的</span></span><br><span class="line">_Slist_iterator(<span class="type">const</span> iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>故 <code>end()</code> 返回的并不是 slist 的尾部节点，所以下图中的 <code>end()</code> 节点是分离开的，如下是 slist 插入的两个示意图，和 slist 的 erase 擦除的一个示意图：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/cf78d26957630ba1cda4051b247914d2.png" alt="image-20241105220134375" /></p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/2e5aa47b54a0839b84e45439ae970c33.png" alt="image-20241105220140725" /></p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/d972e9de5d601071594f61703624f279.png" alt="image-20241105220200344" /></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">1.</span> <span class="toc-text"> list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> list 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E6%9C%AC%E8%BA%AB%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text"> list 本身实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E7%9A%84%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text"> list 的其他函数实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> deque 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text"> deque 的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">2.2.</span> <span class="toc-text"> deque 的数据成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">3.</span> <span class="toc-text"> stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">4.</span> <span class="toc-text"> queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap"><span class="toc-number">5.</span> <span class="toc-text"> heap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#heap_push"><span class="toc-number">5.1.</span> <span class="toc-text"> heap_push()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop_heap"><span class="toc-number">5.2.</span> <span class="toc-text"> pop_heap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort_heap"><span class="toc-number">5.3.</span> <span class="toc-text"> sort_heap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#make_heap"><span class="toc-number">5.4.</span> <span class="toc-text"> make_heap()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority_queue"><span class="toc-number">6.</span> <span class="toc-text"> priority_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slist"><span class="toc-number">7.</span> <span class="toc-text"> slist</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/11/04/life/STL_4/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/11/04/life/STL_4/&text=STL_4"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/11/04/life/STL_4/&is_video=false&description=STL_4"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL_4&body=Check out this article: https://utmux.github.io/2024/11/04/life/STL_4/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/11/04/life/STL_4/&title=STL_4"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/11/04/life/STL_4/&name=STL_4&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/11/04/life/STL_4/&t=STL_4"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
