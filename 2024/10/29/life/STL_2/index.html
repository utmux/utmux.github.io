<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：雨 心情：好   第一级配置器(malloc_alloc_template) SGI 的 allocator，第一层配置器，底层是使用 C 语言的 malloc()和 realloc()以及 free()函数实现的。其大致接口如下图所示： 提供一个模板类 simple_alloc，该模板类根据传入的 class Alloc 决定了是第一层配置器，还是第二层配置器实现。simple_alloc">
<meta property="og:type" content="article">
<meta property="og:title" content="STL_2">
<meta property="og:url" content="https://utmux.github.io/2024/10/29/life/STL_2/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：雨 心情：好   第一级配置器(malloc_alloc_template) SGI 的 allocator，第一层配置器，底层是使用 C 语言的 malloc()和 realloc()以及 free()函数实现的。其大致接口如下图所示： 提供一个模板类 simple_alloc，该模板类根据传入的 class Alloc 决定了是第一层配置器，还是第二层配置器实现。simple_alloc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/5dabfc5aec0f6507e8e3f6915acf51f8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/b049eecc29629d35b6c1d4be4d3267f1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/f63ae0b6db5e3811db9f764cc011c54d.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/1b18cc76ae4502f76a4d12e5dba8cff8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/ec55f3f5c3e8a8b71d6aa7b52e4759a9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/928e390c8f23e902bc021e0b6eb4ac3b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/c7961ee278c150e660575fb36d0212b6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/14db0eafdd8280ae5bb25d64f77725ac.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/32d2b848b7d53081550fbb4e784b041b.png">
<meta property="article:published_time" content="2024-10-29T13:25:26.000Z">
<meta property="article:modified_time" content="2025-05-14T08:39:55.112Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/5dabfc5aec0f6507e8e3f6915acf51f8.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>STL_2</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/10/29/life/STL_3/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/09/25/life/STL_1/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/10/29/life/STL_2/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/10/29/life/STL_2/&text=STL_2"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/10/29/life/STL_2/&is_video=false&description=STL_2"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL_2&body=Check out this article: https://utmux.github.io/2024/10/29/life/STL_2/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/10/29/life/STL_2/&name=STL_2&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/10/29/life/STL_2/&t=STL_2"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8malloc_alloc_template"><span class="toc-number">1.</span> <span class="toc-text"> 第一级配置器(malloc_alloc_template)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tipsnew-%E7%9A%84-set_handler-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text"> Tips：new 的 set_handler 函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> 第二级配置器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tips%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text"> Tips：链表中一个节省内存的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tipscc%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%AE%8C%E6%95%B4%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text"> TIps：C&#x2F;C++声明不完整数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tips-sgi-%E9%87%87%E7%94%A8-malloc-%E8%80%8C%E4%B8%8D%E6%98%AF-operator-new-%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.3.</span> <span class="toc-text"> Tips: SGI 采用 malloc 而不是 ::operator new 来分配内存的原因</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text"> 内存链表代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocate-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text"> allocate 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deallocate-%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text"> deallocate 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#refill-%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text"> refill 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chunk_alloc-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> chunk_alloc 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7"><span class="toc-number">8.</span> <span class="toc-text"> 内存处理的基本工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#uninitialized_copy"><span class="toc-number">8.1.</span> <span class="toc-text"> uninitialized_copy()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uninitialized_fill"><span class="toc-number">8.2.</span> <span class="toc-text"> uninitialized_fill()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uninitiated_fill_n"><span class="toc-number">8.3.</span> <span class="toc-text"> uninitiated_fill_n</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtti-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">9.</span> <span class="toc-text"> RTTI 的类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%ABiterator_category"><span class="toc-number">9.1.</span> <span class="toc-text"> 迭代器类别（iterator_category）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tips-%E7%89%B9%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B6%88%E9%99%A4%E5%8D%95%E7%BA%AF%E4%BC%A0%E9%80%92%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text"> Tips 特例初始化消除单纯传递调用的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#std-iterator-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%87%AA%E8%A1%8C%E5%BC%80%E5%8F%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">9.3.</span> <span class="toc-text"> std:: iterator 的基本（自行开发迭代器的要求）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-__type_traits"><span class="toc-number">9.4.</span> <span class="toc-text"> 补充 __type_traits</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        STL_2
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-10-29T13:25:26.000Z" class="dt-published" itemprop="datePublished">2024-10-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/life/">life</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：雨 心情：好</p>
<hr />
<h4 id="第一级配置器malloc_alloc_template"><a class="markdownIt-Anchor" href="#第一级配置器malloc_alloc_template"></a> 第一级配置器(malloc_alloc_template)</h4>
<p>SGI 的 allocator，第一层配置器，底层是使用 C 语言的 malloc()和 realloc()以及 free()函数实现的。其大致接口如下图所示：<br />
提供一个模板类 <code>simple_alloc</code>，该模板类根据传入的 <code>class Alloc</code> 决定了是第一层配置器，还是第二层配置器实现。<code>simple_alloc</code> 提供容器的内存管理接口。<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/5dabfc5aec0f6507e8e3f6915acf51f8.png" alt="image-20240927104018476" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般而言是 thread-safe，并且对于空间的运用比较高效（efficient）。</span></span><br><span class="line"><span class="comment">// 以下是第一级配置器。</span></span><br><span class="line"><span class="comment">// 注意，无「template型别参数」。至于「非型别参数」inst，完全没派上用场。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 函数指针，处理内存不足情况</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* _S_oom_malloc(<span class="type">size_t</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* _S_oom_realloc(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">    <span class="comment">// 处理内存不足的函数指针</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一级配置器直接使用malloc</span></span><br><span class="line">        <span class="type">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="comment">// 无法满足需求时，改用oom方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一级配置器直接使用free</span></span><br><span class="line">        <span class="built_in">free</span>(__p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配内存</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">reallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一级配置器直接使用realloc()</span></span><br><span class="line">        <span class="type">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">        <span class="comment">// 无法满足需求时使用oom_realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下模拟c++的set_new_handler(),可以指定自己的oom handler</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="type">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">void</span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = __f;</span><br><span class="line">        <span class="keyword">return</span>(__old);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的主要逻辑即包装了 C 语言中的 malloc 和 free，以及 realloc 函数。当遇到内存不足时（out of memory）, 调用对应的 <code>oom_alloc</code>，<code>oom_realloc</code>。我们来看一下这两个函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="comment">// 由客户端设定</span></span><br><span class="line"><span class="built_in">void</span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 不断尝试释放、配置、再释放、再配置</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();  <span class="comment">// 企图释放内存</span></span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);   <span class="comment">// 尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="type">void</span>* __p, <span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 同上</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将inst参数设置为0</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::<span class="built_in">allocate</span>(__n * <span class="built_in">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::<span class="built_in">deallocate</span>(__p, __n * <span class="built_in">sizeof</span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">      </span>&#123; _Alloc::<span class="built_in">deallocate</span>(__p, <span class="built_in">sizeof</span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，上面内存处理的函数，只是在不断调用 <code>__malloc_alloc_oom_handler</code>，该函数是由自己设置的，可能是提醒用户，也有可能是释放内存，具体实现需要用户自定义。然后不断尝试重新分配内存，调用 <code>__malloc_alloc_oom_handler</code>。</p>
<p>上面还提供了 backward 接口，将上面实现的 <code>alloc</code> 和 <code>realloc</code> 包装未 <code>simple_alloc</code> 供符合 ISO 标准的容器类调用。</p>
<h5 id="tipsnew-的-set_handler-函数"><a class="markdownIt-Anchor" href="#tipsnew-的-set_handler-函数"></a> Tips：new 的 set_handler 函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to satisfy request for memory\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// 如果不终止程序，将一直重复调用该函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br></pre></td></tr></table></figure>
<p>值得注意的是，一旦调用完 set_handler，会抛出 <code>std::bad_alloc</code> 异常，上面的一级缓存器自己实现呢 set_new_handler，通过模板类中一个 static 的函数指针。</p>
<h4 id="第二级配置器"><a class="markdownIt-Anchor" href="#第二级配置器"></a> 第二级配置器</h4>
<p>我们知道，在操作系统中，任何内存的分配都有一小块内存用于记录该分配的内存的大小和位置，从而 free 函数可以正确释放内存。<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/b049eecc29629d35b6c1d4be4d3267f1.png" alt="image-20240929102824267" /></p>
<p>而如果内存碎片太多时，此时会导致用于记录的内存相比所需内存还要多，且太多小内存通过链表管理，负担太重。</p>
<p>在第二级配置器中，会自动分配大于所需内存的内存，且为 2 的倍数。</p>
<h5 id="tips链表中一个节省内存的方法"><a class="markdownIt-Anchor" href="#tips链表中一个节省内存的方法"></a> Tips：链表中一个节省内存的方法</h5>
<p>在链表中，为了维持链表，通常会需要一个指针指向下一个节点，而此时就可以将节点设置为 union 两用，例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点定义</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">_Obj</span> &#123; <span class="comment">// **定义为union此时，下面可以作为char数组，也可以作为指向下一个节点，节省内存**</span></span><br><span class="line">      <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;</span><br><span class="line">      <span class="type">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="tipscc声明不完整数组类型"><a class="markdownIt-Anchor" href="#tipscc声明不完整数组类型"></a> TIps：C/C++声明不完整数组类型</h5>
<p>之前学习 C 语言的时候，一直说对于二维数组指针，我们必须声明第二个。其实我们可以利用不完整数组声明（应该可以叫做前置定义吧），来让编译器按照顺序编译时能够不报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在C语言中，我们学过</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span> <span class="comment">// 如果A和B需要相互引用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span><span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">a</span>;</span>&#125;; <span class="comment">// 这里注意是指针固定了大小，所以不会导致无限递归</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span><span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">b</span>;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>现在学到这种技巧对二维数组也是一样的，先上车在补票，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言如下</span></span><br><span class="line"><span class="comment">// 头文件（例如：myfile.h）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> my_array[];  <span class="comment">// 声明一个不完整类型的数组，欺骗编译器</span></span><br><span class="line"><span class="comment">// 源文件（例如：myfile.c）</span></span><br><span class="line"><span class="type">int</span> my_array[<span class="number">10</span>];  <span class="comment">// 现在提供具体的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于静态数组</span></span><br><span class="line"><span class="comment">// 在某个 C 文件中</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> my_array[];    <span class="comment">// 声明不完整的静态数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> my_array[<span class="number">10</span>];  <span class="comment">// 定义并提供大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++如下，可以</span></span><br><span class="line"><span class="comment">// 声明：告诉编译器有一个静态数组</span></span><br><span class="line"><span class="type">static</span> _Obj* _S_free_list[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：在实现文件中指定数组的大小</span></span><br><span class="line">_Obj* _S_free_list[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h5 id="tips-sgi-采用-malloc-而不是-operator-new-来分配内存的原因"><a class="markdownIt-Anchor" href="#tips-sgi-采用-malloc-而不是-operator-new-来分配内存的原因"></a> Tips: SGI 采用 <code>malloc</code> 而不是 <code>::operator new</code> 来分配内存的原因</h5>
<ol>
<li>历史因素，由于巨大的惯性效应，所以沿用 malloc</li>
<li>C++没有提供 realloc 函数，只有 malloc 头文件中有</li>
<li>由于使用了 malloc，因此 SGI 不能直接使用 C++的 <code>set_new_handler()</code>，必须仿真一个类似的 <code>set_mailoc_handler()</code>。</li>
</ol>
<h4 id="内存链表代码"><a class="markdownIt-Anchor" href="#内存链表代码"></a> 内存链表代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为第二级配置器</span></span><br><span class="line"><span class="comment">// 无模板参数，且inst没用，第一个参数用于多线程情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 向上取整至8的倍数（取反加一的逆操作）</span></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span></span><br><span class="line">  _S_round_up(<span class="type">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="type">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="type">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="comment">// 节点构造</span></span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">_Obj</span> &#123;</span><br><span class="line">        <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;</span><br><span class="line">        <span class="type">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 16个free_list</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="type">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// n从1算起，根据区块大小决定使用第n号free_list</span></span><br><span class="line">  <span class="type">static</span>  <span class="type">size_t</span> _S_freelist_index(<span class="type">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="type">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="type">static</span> <span class="type">void</span>* _S_refill(<span class="type">size_t</span> __n);</span><br><span class="line">  <span class="comment">// 配置一大块空间，可容纳 nobjs个大小为 &quot;size&quot;的区块。</span></span><br><span class="line">  <span class="comment">// 如果配置 nobjs个区块有所不便，nobjs可能会降低。</span></span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">char</span>* _S_chunk_alloc(<span class="type">size_t</span> __size, <span class="type">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">char</span>* _S_start_free; <span class="comment">//记忆池起始位置。只在 chunk_alloc()变化</span></span><br><span class="line">  <span class="type">static</span> <span class="type">char</span>* _S_end_free;  <span class="comment">//记忆池结束位置。只在 chunk_alloc()变化</span></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> _S_heap_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  <span class="type">static</span> <span class="type">void</span>* <span class="title">reallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> __old_sz, <span class="type">size_t</span> __new_sz)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="allocate-函数"><a class="markdownIt-Anchor" href="#allocate-函数"></a> allocate 函数</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于128就调用第一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="type">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 寻找16个free_list中适当的一个</span></span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="comment">// 没找到可用的free_list，重新填充free_list</span></span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调整free_list</span></span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的 allocate 函数中看到，free_list 链表上面是闲置的内存块。allocate 是直接从 free_list 中占用一个内存块，然后将指针移动到下一个（相当于链表中的移动到下一个节点）。其实看下面的图，认真理顺一下就懂了：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/f63ae0b6db5e3811db9f764cc011c54d.png" alt="image-20241022104438123" /></p>
<h4 id="deallocate-函数"><a class="markdownIt-Anchor" href="#deallocate-函数"></a> deallocate 函数</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 大于128调用第一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="type">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 寻找对应的free_list并调整free_list,挥手区块</span></span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>相当于插入节点到链表表头，可以看下面的示意图：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/1b18cc76ae4502f76a4d12e5dba8cff8.png" alt="image-20241022104755280" /></p>
<h4 id="refill-函数"><a class="markdownIt-Anchor" href="#refill-函数"></a> refill 函数</h4>
<p>我们可以发现，当 free_list 上不存在空闲的内存节点时，此时会调用 refill 函数，我们来看一下 refill 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传回一个大小为n的对象，并且有时候会为适当的free list增加节点. </span></span><br><span class="line"><span class="comment">// 假设 n已经适当上调至 8的倍数。</span></span><br><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//呼叫 chunk_alloc()，尝试取得 nobjs个区块做为free list的新节点。</span></span><br><span class="line">    <span class="comment">//注意参数 nobjs是  pass by reference。</span></span><br><span class="line">    <span class="type">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="type">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只获得一个区块，则返回给调用者，free_list无新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    <span class="comment">// 调整free_list，加入新节点</span></span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在chunk空间内建立free_list</span></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;</span><br><span class="line">      <span class="comment">// free_list指向新配置的空间（取自记忆池）</span></span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</span><br><span class="line">      <span class="comment">// free_list节点串联，从1开始，0传回调用者</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj*)((<span class="type">char</span>*)__next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数只是单纯的分配一个链表表头回去。其中内存分配的工作是由 <code>_S_chunk_alloc</code> 函数完成的。我们下面来看一下该函数的实现。</p>
<h4 id="chunk_alloc-函数"><a class="markdownIt-Anchor" href="#chunk_alloc-函数"></a> <code>chunk_alloc</code> 函数</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="type">size_t</span> __size, </span><br><span class="line">                                                            <span class="type">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* __result;</span><br><span class="line">    <span class="type">size_t</span> __total_bytes = __size * __nobjs;</span><br><span class="line">    <span class="type">size_t</span> __bytes_left = _S_end_free - _S_start_free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆池剩余空间满足需求</span></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    <span class="comment">// 剩余一个以上空间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;</span><br><span class="line">        __nobjs = (<span class="type">int</span>)(__bytes_left/__size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    <span class="comment">// 剩余空间一个区块大小都不足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> __bytes_to_get = </span><br><span class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="comment">// 尝试把剩余的先放到适当的free_list中</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置heap空间，分配内存到记忆池中</span></span><br><span class="line">        _S_start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;</span><br><span class="line">            <span class="comment">// 堆空间都不足，malloc失败情况</span></span><br><span class="line">            <span class="type">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	    _Obj* __p;</span><br><span class="line">            <span class="comment">// 找free_list里面足够大的区块先分配给调用者</span></span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="type">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="type">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    <span class="comment">// 调整free_list释放区块</span></span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="type">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="comment">// 递归调用自己，为了修正 nobjs。</span></span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                    <span class="comment">//注意，任何残余零头终将被编入适当的  free-list备用。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            <span class="comment">// 呼叫第一级配置器，使用oom机制尽人事</span></span><br><span class="line">            _S_start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// 这会导致掷出异常（exception），或内存不足的情况获得改善</span></span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;</span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;</span><br><span class="line">        <span class="comment">//递归呼叫自己，为了修正 nobjs。</span></span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下这个函数的实现，<code>_S_end_free</code> 和 <code>_S_start_free</code> 分别记录了空闲内存的起点和终点，两者之差就是还有的空闲内存，上面分三种情况，能够正好分配，此时修改 <code>_S_end_free</code> 和 <code>_S_start_free</code> 这两个变量的值即可。第二种情况是，能够分配一个以及以上的节点，此时尽量分配尽可能多的节点数。第三种情况需要详细讲一下，此时存在内存碎片的情况，需要处理该内存碎片：</p>
<ol>
<li>将内存碎片插入到 free_list 表头，内存碎片的地址必须大于等于一个最小节点的数量（貌似最小节点数量应该是 1，此时能够存储多个碎片了）</li>
<li>尝试 malloc 申请内存，如果成功就修改 heap_size 和 <code>_S_end_free</code> 和 <code>_S_start_free</code> 的值，即此时的内存为内存中另一段连续内存空间。</li>
<li>如果 malloc 不成功，此时尝试探测 <code>free_list</code> 是否还有剩余的内存，并将该内存释放作为可用内存，然后再调用一次 <code>chunk_alloc</code></li>
</ol>
<p>上述的 <code>chunk_alloc()</code> 函数以 <code>end_free - start_free</code> 来判断内存池的水量。如果水量充足，就直接调出 20 个区块返回给 freelist。如果水量不足以提供 20 个区块，但还足够供应一个以上的区块，就拨出这不足 20 个区块的空间出去。这时候其 <code>pass_by_reference</code> 的 nobjs 参数将被修改为实际能够供应的区块数。如果内存池连一个区块空间都无法供应，对客户端显然无法交待，此时便需利用 <strong>malloc()</strong> 从 <strong>heap</strong> 中配置内存，为内存池注入活水源头以应付需求。<strong>新水量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。</strong></p>
<p>万水千山穷尽，整个系统堆空间都不够了（以至于无法为内存池注入活水源头），<code>malloc()</code> 行动失败，<code>chunk_alloc()</code> 就四处寻找有无“尚有未用区块，且区块够大”之 <code>freelists</code>。找到了就挖一块交出，找不到就调用 <strong>第一级配置器</strong>。第一级配置器其实也是使用 <code>malloc()</code> 来配置内存，但它有 <code>out-of-memory</code> 处理机制（类似 <code>new-handler</code> 机制），或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则发出 <code>bad_alloc</code> 异常。</p>
<p>前面提到过所有的 STL 容器，默认调用 <code>simple_alloc</code> 模板作为内存分类器，而 <code>simple_alloc</code> 该模板需要指定一个 <code>Alloc</code>，在 SGI 的 C++实现中，其默认采取使用第二级内存分配器作为 <code>simple_alloc</code> 的内存分配器的。</p>
<h4 id="内存处理的基本工具"><a class="markdownIt-Anchor" href="#内存处理的基本工具"></a> 内存处理的基本工具</h4>
<p>回到第一章的内容，介绍了 <code>&lt;memory&gt;</code> 是由三个部分，在第一章中介绍了 <code>&lt;stl_construct.h&gt;</code> 定义了 <code>construct()</code> 和 <code>destory()</code> 函数，用于 STL 对象的构造和析构。前一节又介绍了 <code>&lt;stl_alloc.h&gt;</code> 这个头文件，包括了一级和二级内存分配器。现在来介绍 <code>&lt;memory&gt;</code> 的第三部分 <code>&lt;stl_uninitialized.h&gt;</code> 该文件，用于填充和复制大块内存数据，其主要包括下面这几个函数：</p>
<h5 id="uninitialized_copy"><a class="markdownIt-Anchor" href="#uninitialized_copy"></a> <code>uninitialized_copy()</code></h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_ForwardIter</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _ForwardIter</span></span><br><span class="line"><span class="function">  <span class="title">uninitialized_copy</span><span class="params">(_InputIter __first, _InputIter __last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     _ForwardIter __result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy(__first, __last, __result,</span><br><span class="line">                              __VALUE_TYPE(__result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* 特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* __first, <span class="type">const</span> <span class="type">char</span>* __last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">char</span>* __result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 直接搬运内存内容</span></span><br><span class="line">  <span class="built_in">memmove</span>(__result, __first, __last - __first);</span><br><span class="line">  <span class="keyword">return</span> __result + (__last - __first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wchar_t* 特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* __first, <span class="type">const</span> <span class="type">wchar_t</span>* __last,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">wchar_t</span>* __result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memmove</span>(__result, __first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (__last - __first));</span><br><span class="line">  <span class="keyword">return</span> __result + (__last - __first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你需要实现一个容器，<code>uninitialized_copy()</code> 这样的函数会为你带来很大的帮助。因为容器的全区间构造函数（range constructor）通常以两个步骤完成：</p>
<ol>
<li><strong>配置内存区块</strong>：确保内存区块足以包含范围内的所有元素。</li>
<li><strong>构造元素</strong>：使用 <code>uninitialized_copy()</code> 在内存区块上构造元素。</li>
</ol>
<p>C++ 标准规格书要求 <code>uninitialized_copy()</code> 具有“commit or rollback”语义，这意味着它要么“构造出所有必要元素”，要么（当有任何一个拷贝构造函数失败时）“不构造任何东西”。</p>
<h5 id="uninitialized_fill"><a class="markdownIt-Anchor" href="#uninitialized_fill"></a> <code>uninitialized_fill()</code></h5>
<p><code>uninitialized_fill()</code> 也能够使我们将内存配置与对象的构造行为分离开来。如果 <code>[first, last)</code> 范围内的每个迭代器都指向未初始化的内存，那么 <code>uninitialized_fill()</code> 会在该范围内产生 <code>x</code>（上式的第三个参数）的复制品。换句话说，<code>uninitialized_fill()</code> 会针对操作范围内的每个迭代器 <code>i</code>，调用 <code>construct(&amp;*i, x)</code>，在 <code>i</code> 所指之处产生 <code>x</code> 的复制品。式中的 <code>construct()</code> 已在 2.2.3 节讨论过。</p>
<p>与 <code>uninitialized_copy()</code> 一样，<code>uninitialized_fill()</code> 必须具备“commit or rollback”语义。换句话说，它要么产生出所有必要元素，要么不产生任何元素。如果有任何一个拷贝构造函数抛出异常（exception），<code>uninitialized_fill()</code> 必须能够将已产生的所有元素析构掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(_ForwardIter __first,</span></span></span><br><span class="line"><span class="params"><span class="function">                               _ForwardIter __last, </span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> _Tp&amp; __x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __uninitialized_fill(__first, __last, __x, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="uninitiated_fill_n"><a class="markdownIt-Anchor" href="#uninitiated_fill_n"></a> <code>uninitiated_fill_n</code></h5>
<p>该函数是非标准函数，该函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Tp1</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _ForwardIter </span><br><span class="line">__uninitialized_fill_n(_ForwardIter __first, _Size __n, <span class="type">const</span> _Tp&amp; __x, _Tp1*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 判断是否为POD类型纯量型别（scalar types）或传统的C  struct型别。</span></span><br><span class="line">  <span class="comment">// POD 型别必然拥有  trivial ctor/dtor/copy/assignment函式，</span></span><br><span class="line">  <span class="comment">// 因此，我们可以对  POD  型别采取最有效率的初值填写手法，</span></span><br><span class="line">  <span class="comment">// 而对  non-POD  型别采取最保险安全的作法</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _ForwardIter </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_fill_n</span><span class="params">(_ForwardIter __first, _Size __n, <span class="type">const</span> _Tp&amp; __x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));</span><br><span class="line">  <span class="comment">// 利用value_type()去除first的value type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uninitialized_fill_n()</code> 能够使我们将内存配置与对象构造行为分离开来。它会为指定范围内的所有元素设定相同的初值。如果 <code>[first, first+n)</code> 范围内的每一个迭代器都指向未初始化的内存，那么 <code>uninitialized_fill_n()</code> 会调用拷贝构造函数，在该范围内产生 <code>x</code>（上式的第三个参数）的复制品。也就是说，面对 <code>[first, first+n)</code> 范围内的每个迭代器 <code>i</code>，<code>uninitialized_fill_n()</code> 会调用 <code>construct(&amp;*i, x)</code>，在对应位置处产生 <code>x</code> 的复制品。式中的 <code>construct()</code> 已于 2.2.3 节讨论过。</p>
<p><code>uninitialized_fill_n()</code> 也具有“commit or rollback”语义：要么产生所有必要的元素，否则就不产生任何元素。如果任何一个拷贝构造函数抛出异常（exception），<code>uninitialized_fill_n()</code> 必须析构已产生的所有元素。</p>
<p>总结一下上面的流程图：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/ec55f3f5c3e8a8b71d6aa7b52e4759a9.png" alt="image-20241029154309850" /></p>
<h4 id="rtti-的类型推导"><a class="markdownIt-Anchor" href="#rtti-的类型推导"></a> RTTI 的类型推导</h4>
<p>我们之前提到过再 C++中的来实现类似 RTTI 的自动推导是通过 <code>dynamic_cast</code>（判断派生和基类）以及 <code>typeid</code>（判断类型）以及 <code>decltype</code> 用于在编译时推导类型。</p>
<p>除此之外，这里介绍一下利用 RTTI 来实现自动推导：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/928e390c8f23e902bc021e0b6eb4ac3b.png" alt="image-20241029161613241" /></p>
<p>如上面所示，如果我们需要定义该类型以及该类型的迭代器类型变量，此时通过 <code>func_impl</code> 来实现。</p>
<p>但是，从上面看，该函数是 <code>void</code>，即无返回值，如果需要返回值改变，此时 <code>template</code> 模板无法用于函数的返回值，而只能用于参数。如何实现变化的返回值类型，下面是实现的方法<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/c7961ee278c150e660575fb36d0212b6.png" alt="image-20241029170858503" /></p>
<p>注意，<code>func()</code> 的返回类型必须加上关键词 <code>typename</code>，因为 <code>T</code> 是一个模板参数，在它被编译器具现化之前，编译器对 <code>T</code> 一无所知。换句话说，编译器此时并不知道 <code>MyIter&lt;T&gt;::value_type</code> 代表的是一个类型、一个成员函数还是一个数据成员。关键词 <code>typename</code> 的用意在于告诉编译器这是一个类型，如此才能顺利通过编译。</p>
<p>看起来不错。但是有个隐藏的陷阱：并不是所有迭代器都是类类型（class type）。原生指针就不是类类型！如果不是类类型，就无法为它定义内嵌类型。但 STL（以及整个泛型思维）绝对必须接受原生指针作为一种迭代器，所以上述方案还不够。有没有办法可以让上述的一般化概念针对特定情况（例如针对原生指针）做特殊化处理呢？是的，模板偏特化（template partial specialization）可以做到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; <span class="comment">// 如果是一个类，该类存在value_type的typedef，此时可以作为迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; <span class="comment">// 用于特例化指针作为迭代器</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; <span class="comment">// 用于特例化const指针作为迭代器</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type <span class="comment">// 此时调用func函数，其返回值根据迭代器类型而改变</span></span><br><span class="line"><span class="built_in">func</span>(I ite)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只说了所有迭代器必须定义 <code>value_type</code> 指向迭代器对应的数据，除此之外，真正完善的迭代器有下面这些要求：</p>
<ol>
<li>
<p>value_type：定义迭代器指向的元素的类型</p>
</li>
<li>
<p>difference_type：定义两个迭代器的距离类型，例如对于原生指针，我们可以使用 C++ 内建的 <code>ptrdiff_t</code>（定义于 <code>&lt;cstddef&gt;</code> 头文件）作为原生指针的 <code>difference_type</code>，用于表示两个指针的差值。</p>
</li>
<li>
<p>pointer：定义指向 value_type 的指针类型，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生指针的traits 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;_Tp*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生常量指针 pointer-to-const 的traits 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> _Tp*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp*                  pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp&amp;                  reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如上面的代码所示，pointer的类型根据原生指针，或者const 原生指针，以及类指针有不同的定义</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>reference：定义 value_type 的引用类型，根据迭代器的类型，规定了迭代器所指向的 value_type 的值是否能够改变，例如 <code>const int *p</code>，此时 p 所指向的数据禁止改变，该迭代器是 <strong>const iterator</strong>，与之相反是 <strong>mutual iterator</strong>。在 C++中，如果需要改变参数的值，此时传入的参数应该是通过引用传入（by reference），而不是按值传入。故对于一个迭代器 p，此时 dereference 时（即 <code>*p</code>），若其是 const iterator，则 <code>*p</code> 类型为 <code>const T&amp;</code>（而不是 <code>const T</code>，前置代表在此处修改，会同步导致原处修改）。同理，若是 mutual iterator，此时 <code>*p</code> 的类型是 <code>T &amp;</code>.</p>
</li>
<li>
<p>iterator_category：定义迭代器的类别（如随机访问迭代器、双向迭代器、输入迭代器、输出迭代器等）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/14db0eafdd8280ae5bb25d64f77725ac.png" alt="image-20241029200308558" /></p>
<h5 id="迭代器类别iterator_category"><a class="markdownIt-Anchor" href="#迭代器类别iterator_category"></a> 迭代器类别（iterator_category）</h5>
<p>在 C++中，我们知道迭代器大致分为这五种类型，包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputIterator：这种迭代器所指向的对象不允许外界改变，为只读（readonly）。</span><br><span class="line"></span><br><span class="line">OutputIterator：唯写（write-only）。</span><br><span class="line"></span><br><span class="line">ForwardIterator：允许“写入型”算法（例如 <span class="built_in">replace</span>()）在此种迭代器所形成的区间上进行读写操作。</span><br><span class="line"></span><br><span class="line">BidirectionalIterator：可双向移动。某些算法需要逆向遍历某个迭代器区间（例如逆向拷贝某范围内的元素），可以使用 BidirectionalIterators。</span><br><span class="line"></span><br><span class="line">RandomAccessIterator：前四种迭代器都只提供一部分指针算术能力（前三种支持 <span class="keyword">operator</span>++，第四种再加上 <span class="keyword">operator</span>--），而第五种则涵盖所有指针算术能力，包括 p+n，p-n，p[n]，p1-p2，p1&lt;p2。</span><br></pre></td></tr></table></figure>
<p>迭代器之间的关系，用 concept 而不是继承来表示，其关系如下：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/32d2b848b7d53081550fbb4e784b041b.png" alt="image-20241029202711431" /></p>
<p>在选中迭代器时，要注重效率，虽然说一个 Random Access Iterator 一定时满足其他迭代器的各种要求的，但是其效率未必是最优的。以 stl 函数 <code>advance()</code> 为例子，该函数定义了三种函数用于针对不同的迭代器，以满足每种迭代器的最大效率。例如针对：input iterator，有 <code>advance_II()</code>，对于 Bidirectional Iterator 有 <code>advance_BI()</code>，而对于 Random Access Iterator，有 <code>advance_RAI</code>，这三种的内部实现都充分利用了这集中迭代器的特性。</p>
<p>这一章节，我们主要学到的一个方法就是利用 trait 技巧，以及部分特例化技巧来实现针对 RTTI 定义变量和定义返回参数类型。上面介绍了五种迭代器的类型，我们尝试一下，使用 trait 技巧来分辨出这五种迭代器（注意迭代器定义了 iterator_category 这个 typedef。</p>
<p>我们首先定义五种迭代器类型标记为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 五种迭代器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们需要让函数根据传入的迭代器类型，自动使用效率最高的迭代器特例，我们可以如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;I&gt;</span><br><span class="line"><span class="built_in">func</span>(I, input_iterator_tag)... <span class="comment">// 第二个参数特例化为II迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;I&gt;</span><br><span class="line"><span class="built_in">func</span>(I, bidirectional_iterator_tag)... <span class="comment">// 第二个参数特例化为BI迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;I&gt;</span><br><span class="line"><span class="built_in">func</span>(I, random_access_iterator_tag)... <span class="comment">// 第二个参数特例化为RAI迭代器</span></span><br><span class="line"><span class="comment">// 此时，根据输入的参数，会决定不同的特例化示例</span></span><br></pre></td></tr></table></figure>
<h5 id="tips-特例初始化消除单纯传递调用的函数"><a class="markdownIt-Anchor" href="#tips-特例初始化消除单纯传递调用的函数"></a> Tips 特例初始化消除单纯传递调用的函数</h5>
<p>在上面，我们将迭代器定义为一个模板类，其根据传入的参数进行不同的特例化，以适应原生指针，const 原生指针以及类。该种写法，不仅使得一个迭代器便能够能够正确处理多种类型，另一个好处是不必再写单纯只做传递调用的函数（比如前面的 <code>advance()</code> 函数根据迭代器的类型会有不同的过程），而回根据特例初始化自动选择合适的函数。</p>
<h5 id="std-iterator-的基本自行开发迭代器的要求"><a class="markdownIt-Anchor" href="#std-iterator-的基本自行开发迭代器的要求"></a> std:: iterator 的基本（自行开发迭代器的要求）</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自行开发迭代最好继承下面的iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Category</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Distance</span> = <span class="type">ptrdiff_t</span>,</span><br><span class="line">          <span class="keyword">class</span> _Pointer = _Tp*, <span class="keyword">class</span> _Reference = _Tp&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Category  iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Distance  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Pointer   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_USE_NAMESPACES */</span></span></span><br></pre></td></tr></table></figure>
<p>对于最基本的迭代器，我们必须继承上面这个 concept，此时我们可以传入特例化参数，将其变为我们自己需要开发的迭代器。例如下面这个针对原生 const 指针的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生常量指针 pointer-to-const 的traits 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> _Tp*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp*                  pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp&amp;                  reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="补充-__type_traits"><a class="markdownIt-Anchor" href="#补充-__type_traits"></a> 补充 <code>__type_traits</code></h5>
<p>前面我们提到过使用 <code>iterator_traits</code> 来区分不同迭代器性质，而对于 <code>value</code> 的其他性质，比如该类是否为平凡 <code>trival</code> 和 <code>non-trival</code>，我们使用 <code>__type_traits</code>（前面的源码也提到过，使用 isPOD()这个函数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">    <span class="comment">// 判断默认构造函数是否平凡</span></span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">    <span class="comment">// 判断复制构造函数是否平凡</span></span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">    <span class="comment">// 判断赋值构造函数是否平凡</span></span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">    <span class="comment">// 判断析构函数是否平凡</span></span><br><span class="line"><span class="comment">// POD: Plain Old Data</span></span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br><span class="line">    <span class="comment">// 上面所有特性，其类似于前面的iterator_category，定义了下面两种类型：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>一个标准的 <code>__type_traits</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，对于float类型，其__type_traits如下</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>某些编译器可能会内置一些 <code>__type_traits</code>。</p>
<p>利用 <code>__type_traits</code> 可以充分加速某些函数，比如平凡的类，此时可以直接用内存复制函数，复制该片内存即可。而对于非平凡，需要进行深度复制，此时采用 <code>_construct</code> 进行一次次构造。</p>
<p>对于自己定义的类，现代编译器能够自行只能定义 <code>__type_traits</code>。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8malloc_alloc_template"><span class="toc-number">1.</span> <span class="toc-text"> 第一级配置器(malloc_alloc_template)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tipsnew-%E7%9A%84-set_handler-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text"> Tips：new 的 set_handler 函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> 第二级配置器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tips%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text"> Tips：链表中一个节省内存的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tipscc%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%AE%8C%E6%95%B4%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text"> TIps：C&#x2F;C++声明不完整数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tips-sgi-%E9%87%87%E7%94%A8-malloc-%E8%80%8C%E4%B8%8D%E6%98%AF-operator-new-%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.3.</span> <span class="toc-text"> Tips: SGI 采用 malloc 而不是 ::operator new 来分配内存的原因</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text"> 内存链表代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocate-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text"> allocate 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deallocate-%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text"> deallocate 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#refill-%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text"> refill 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chunk_alloc-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> chunk_alloc 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7"><span class="toc-number">8.</span> <span class="toc-text"> 内存处理的基本工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#uninitialized_copy"><span class="toc-number">8.1.</span> <span class="toc-text"> uninitialized_copy()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uninitialized_fill"><span class="toc-number">8.2.</span> <span class="toc-text"> uninitialized_fill()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uninitiated_fill_n"><span class="toc-number">8.3.</span> <span class="toc-text"> uninitiated_fill_n</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtti-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">9.</span> <span class="toc-text"> RTTI 的类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%ABiterator_category"><span class="toc-number">9.1.</span> <span class="toc-text"> 迭代器类别（iterator_category）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tips-%E7%89%B9%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B6%88%E9%99%A4%E5%8D%95%E7%BA%AF%E4%BC%A0%E9%80%92%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text"> Tips 特例初始化消除单纯传递调用的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#std-iterator-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%87%AA%E8%A1%8C%E5%BC%80%E5%8F%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">9.3.</span> <span class="toc-text"> std:: iterator 的基本（自行开发迭代器的要求）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-__type_traits"><span class="toc-number">9.4.</span> <span class="toc-text"> 补充 __type_traits</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/10/29/life/STL_2/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/10/29/life/STL_2/&text=STL_2"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/10/29/life/STL_2/&is_video=false&description=STL_2"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL_2&body=Check out this article: https://utmux.github.io/2024/10/29/life/STL_2/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_2/&title=STL_2"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/10/29/life/STL_2/&name=STL_2&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/10/29/life/STL_2/&t=STL_2"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
