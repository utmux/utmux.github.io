<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：雨 心情：好   序列式容器 STL 种的容器分为两种，序列式和关联式，如下图所示：  所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted）。  vector vector 比较简单，对于 vector，大概代码如下所示： 首先是 _Vector_base，vector 继承了该类，该类定义了 vector 的基本成员和基本函数。 12345678910111213">
<meta property="og:type" content="article">
<meta property="og:title" content="STL_3">
<meta property="og:url" content="https://utmux.github.io/2024/10/29/life/STL_3/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：雨 心情：好   序列式容器 STL 种的容器分为两种，序列式和关联式，如下图所示：  所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted）。  vector vector 比较简单，对于 vector，大概代码如下所示： 首先是 _Vector_base，vector 继承了该类，该类定义了 vector 的基本成员和基本函数。 12345678910111213">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/94fc4ccae5bb2d3dbfa0c69d70b27496.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/a0b4ee6f5f49e85e36e04fbf8d62695c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/8f069783dec855cdf2bbf73c8a35473b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/fbe855d70ec859baba7252eb28990651.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/8afc4e21b367e3d886eba655e99b0af0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/8e488bfa2eb414c8b0d71c42d949172b.png">
<meta property="article:published_time" content="2024-10-29T13:26:26.000Z">
<meta property="article:modified_time" content="2025-05-14T08:40:04.063Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/94fc4ccae5bb2d3dbfa0c69d70b27496.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>STL_3</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/11/04/life/STL_4/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/10/29/life/STL_2/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/10/29/life/STL_3/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/10/29/life/STL_3/&text=STL_3"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/10/29/life/STL_3/&is_video=false&description=STL_3"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL_3&body=Check out this article: https://utmux.github.io/2024/10/29/life/STL_3/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/10/29/life/STL_3/&name=STL_3&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/10/29/life/STL_3/&t=STL_3"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text"> 序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.1.</span> <span class="toc-text"> vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> vector 的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text"> vector 的内存处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vector-%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9Cpop_back-erase-clear-insert"><span class="toc-number">1.3.1.</span> <span class="toc-text"> vector 的其他操作：pop_back, erase, clear, insert</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        STL_3
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-10-29T13:26:26.000Z" class="dt-published" itemprop="datePublished">2024-10-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/life/">life</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：雨 心情：好</p>
<hr />
<h3 id="序列式容器"><a class="markdownIt-Anchor" href="#序列式容器"></a> 序列式容器</h3>
<p>STL 种的容器分为两种，序列式和关联式，如下图所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/94fc4ccae5bb2d3dbfa0c69d70b27496.png" alt="image-20241029212821297" /></p>
<p>所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted）。</p>
<h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h4>
<p>vector 比较简单，对于 vector，大概代码如下所示：</p>
<p>首先是 <code>_Vector_base</code>，vector 继承了该类，该类定义了 vector 的基本成员和基本函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Vector_base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">allocator_type</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  _Vector_base(<span class="type">const</span> _Alloc&amp;) <span class="comment">// vector的基本初始化方法1</span></span><br><span class="line">    : _M_start(<span class="number">0</span>), _M_finish(<span class="number">0</span>), _M_end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  _Vector_base(<span class="type">size_t</span> __n, <span class="type">const</span> _Alloc&amp;) <span class="comment">// vector的基本初始化方法2</span></span><br><span class="line">    : _M_start(<span class="number">0</span>), _M_finish(<span class="number">0</span>), _M_end_of_storage(<span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    _M_start = _M_allocate(__n);</span><br><span class="line">    _M_finish = _M_start;</span><br><span class="line">    _M_end_of_storage = _M_start + __n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~_Vector_base() &#123; _M_deallocate(_M_start, _M_end_of_storage - _M_start); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Tp* _M_start; <span class="comment">// 使用空间的头</span></span><br><span class="line">  _Tp* _M_finish; <span class="comment">// 使用空间的尾</span></span><br><span class="line">  _Tp* _M_end_of_storage; <span class="comment">// 可用空间的尾</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp, _Alloc&gt; _M_data_allocator;</span><br><span class="line">  _Tp* _M_allocate(<span class="type">size_t</span> __n)</span><br><span class="line">    &#123; <span class="keyword">return</span> _M_data_allocator::<span class="built_in">allocate</span>(__n); &#125;</span><br><span class="line">  <span class="type">void</span> _M_deallocate(_Tp* __p, <span class="type">size_t</span> __n) </span><br><span class="line">    &#123; _M_data_allocator::<span class="built_in">deallocate</span>(__p, __n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面可以看出 vector 的内存分配策略，对于 vector 为了频繁的存入元素导致内存频繁分配，所以其实际分配的内存大小为 <code>_M_end_of_storage - _M_start</code>（<code>capacity()</code> 函数返回的值），实际用到的内存大小 <code>_M_finish - _M_start</code>（<code>size()</code> 返回的值），只有当没有可用内存时，才会调用 <code>alloc</code> 对应的内存分配函数。</p>
<p>然后我们再来看一下 vector 的具体源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span> = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="keyword">class</span> vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">    <span class="comment">// 继承了上面的_Vector_base类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// requirements:</span></span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// nested type 定义</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::allocator_type allocator_type;</span><br><span class="line">  <span class="function">allocator_type <span class="title">get_allocator</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _Base::<span class="built_in">get_allocator</span>(); &#125;</span><br><span class="line">    ... <span class="comment">// 中间一些细节，定义了reverse_iterator和const reverse_iterator</span></span><br><span class="line">        </span><br><span class="line"> <span class="keyword">public</span>: <span class="comment">// vector 提供的对外函数接口</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _M_start; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _M_start; &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _M_finish; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _M_finish; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>) / <span class="built_in">sizeof</span>(_Tp); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(_M_end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector所有的构造函数，可以有五种构造含方式</span></span><br><span class="line">    <span class="comment">// 1. 直接传入类型，默认构造函数，直接构造一个</span></span><br><span class="line">    <span class="comment">// 2. 传入个数和值</span></span><br><span class="line">    <span class="comment">// 3. 只传入个数</span></span><br><span class="line">    <span class="comment">// 4. 传入另一个vector来构造</span></span><br><span class="line">    <span class="comment">// 5. 传入两个迭代器，复制两个迭代器中间的值到vector</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(<span class="type">const</span> allocator_type&amp; __a = allocator_type())</span></span></span><br><span class="line"><span class="function">    : _Base(__a) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>(size_type __n, <span class="type">const</span> _Tp&amp; __value,</span><br><span class="line">         <span class="type">const</span> allocator_type&amp; __a = <span class="built_in">allocator_type</span>()) </span><br><span class="line">    : _Base(__n, __a)</span><br><span class="line">    &#123; _M_finish = <span class="built_in">uninitialized_fill_n</span>(_M_start, __n, __value); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">    : _Base(__n, allocator_type())</span></span><br><span class="line"><span class="function">    &#123;</span> _M_finish = <span class="built_in">uninitialized_fill_n</span>(_M_start, __n, _Tp()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">const</span> vector&lt;_Tp, _Alloc&gt;&amp; __x) </span><br><span class="line">    : _Base(__x.<span class="built_in">size</span>(), __x.<span class="built_in">get_allocator</span>())</span><br><span class="line">    &#123; _M_finish = <span class="built_in">uninitialized_copy</span>(__x.<span class="built_in">begin</span>(), __x.<span class="built_in">end</span>(), _M_start); &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="built_in">vector</span>(<span class="type">const</span> _Tp* __first, <span class="type">const</span> _Tp* __last,</span><br><span class="line">         <span class="type">const</span> allocator_type&amp; __a = <span class="built_in">allocator_type</span>())</span><br><span class="line">    : _Base(__last - __first, __a) </span><br><span class="line">    &#123; _M_finish = <span class="built_in">uninitialized_copy</span>(__first, __last, _M_start); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// vector的析构函数</span></span><br><span class="line">  ~<span class="built_in">vector</span>() &#123; <span class="built_in">destroy</span>(_M_start, _M_finish); &#125;</span><br><span class="line">  <span class="comment">// vector提供的函数：reserve，assign，两种push_back函数，swap，以及各种类型的insert函数，erase，resize和clear函数。</span></span><br><span class="line">  vector&lt;_Tp, _Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;_Tp, _Alloc&gt;&amp; __x);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(size_type __n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">capacity</span>() &lt; __n) &#123;</span><br><span class="line">      <span class="type">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">      iterator __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);</span><br><span class="line">      <span class="built_in">destroy</span>(_M_start, _M_finish);</span><br><span class="line">      _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">      _M_start = __tmp;</span><br><span class="line">      _M_finish = __tmp + __old_size;</span><br><span class="line">      _M_end_of_storage = _M_start + __n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assign(), a generalized assignment member function.  Two</span></span><br><span class="line">  <span class="comment">// versions: one that takes a count, and one that takes a range.</span></span><br><span class="line">  <span class="comment">// The range version is a member template, so we dispatch on whether</span></span><br><span class="line">  <span class="comment">// or not the type is an integer.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(size_type __n, <span class="type">const</span> _Tp&amp; __val)</span> </span>&#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line">  <span class="type">void</span> _M_fill_assign(size_type __n, <span class="type">const</span> _Tp&amp; __val);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(_M_finish, __x);</span><br><span class="line">      ++_M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _M_insert_aux(<span class="built_in">end</span>(), __x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(_M_finish);  <span class="comment">// 全局函数</span></span><br><span class="line">      ++_M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _M_insert_aux(<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;_Tp, _Alloc&gt;&amp; __x)</span> </span>&#123;</span><br><span class="line">    __STD::<span class="built_in">swap</span>(_M_start, __x._M_start);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(_M_finish, __x._M_finish);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(_M_end_of_storage, __x._M_end_of_storage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator __position, <span class="type">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">    size_type __n = __position - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (_M_finish != _M_end_of_storage &amp;&amp; __position == <span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(_M_finish, __x);</span><br><span class="line">      ++_M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _M_insert_aux(__position, __x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + __n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator __position)</span> </span>&#123;</span><br><span class="line">    size_type __n = __position - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (_M_finish != _M_end_of_storage &amp;&amp; __position == <span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(_M_finish);</span><br><span class="line">      ++_M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _M_insert_aux(__position);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + __n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator __position,</span></span></span><br><span class="line"><span class="params"><span class="function">              const_iterator __first, const_iterator __last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(iterator __pos, size_type __n, <span class="type">const</span> _Tp&amp; __x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; _M_fill_insert(__pos, __n, __x); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> _M_fill_insert (iterator __pos, size_type __n, <span class="type">const</span> _Tp&amp; __x);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --_M_finish;     <span class="comment">// 尾端标记前移</span></span><br><span class="line">    <span class="built_in">destroy</span>(_M_finish);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator __position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">      <span class="built_in">copy</span>(__position + <span class="number">1</span>, _M_finish, __position);  <span class="comment">// 后序元素向前移动</span></span><br><span class="line">    --_M_finish;</span><br><span class="line">    <span class="built_in">destroy</span>(_M_finish);  <span class="comment">// 删除最后一个</span></span><br><span class="line">    <span class="keyword">return</span> __position;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除 [first, last)</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator __first, iterator __last)</span> </span>&#123;</span><br><span class="line">    iterator __i = <span class="built_in">copy</span>(__last, _M_finish, __first);</span><br><span class="line">    <span class="built_in">destroy</span>(__i, _M_finish);</span><br><span class="line">    _M_finish = _M_finish - (__last - __first);</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type __new_size, <span class="type">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>()) </span><br><span class="line">      <span class="built_in">erase</span>(<span class="built_in">begin</span>() + __new_size, <span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert</span>(<span class="built_in">end</span>(), __new_size - <span class="built_in">size</span>(), __x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span> </span>&#123; <span class="built_in">resize</span>(__new_size, _Tp()); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>
<p>从源代码中看出，其实现都比较常规，值得需要特殊注意的是：</p>
<ol>
<li><code>_M_end_of_storage</code>：该变量为最大存储值，对于 vector 我们实际给其分配的内存总是大于其数据量，防止 vector 在 push_back 插入时频繁分配内存。只有当 <code>end()==_M_end_of_storage</code> 时，才表示内存已经使用完，此时需要进行分配，<code>capacity()</code> 返回的就是具体分配的存储大小，而 <code>size()</code> 返回的则是已占用的空间大小。</li>
<li><code>resize()</code> 函数，我们可以看到，对于 <code>resize()</code> 函数，当 n 小于当前数据量时，此时其会直接截取前 n 个数据。而对于 n 如果大于当前数据量，其会多分配空间。该函数和 <code>reverse()</code> 对比，<code>resize()</code> 调整的是元素个数，而 <code>reverse()</code> 用于预留内存空间，改变 <code>capacity()</code>，但不改变 <code>size()</code>。当空间大于 n 时，不会做任何操作。</li>
</ol>
<h4 id="vector-的迭代器"><a class="markdownIt-Anchor" href="#vector-的迭代器"></a> vector 的迭代器</h4>
<p>可以看到 vector 是支持随机访问的，即支持 <code>[n]</code> 操作访问，所以 vector 的迭代器是 Random Access Iterator。</p>
<p>故 vector 的迭代器应该提供下列这些接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>*, <span class="keyword">operator</span>-&gt;, <span class="keyword">operator</span>++, <span class="keyword">operator</span>--, <span class="keyword">operator</span>+, <span class="keyword">operator</span>-, <span class="keyword">operator</span>+=, <span class="keyword">operator</span>-=</span><br></pre></td></tr></table></figure>
<p>为了将 vector 和 vector 的迭代器联系起来，需要再 vector 中定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// nested type 定义</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator; <span class="comment">//  定义iterator为value_type*</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以看出，对于基本类型，其迭代器是原生指针。而对于自定义类，其迭代器类型仍然是原生指针，指向类的指针。在现代 C++中，其迭代器实际上不再是指针，在 vector 中迭代器的定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</span><br><span class="line"><span class="comment">// 此时迭代器是通过模板来确定的，而不是一个单纯的指针</span></span><br></pre></td></tr></table></figure>
<p>进一步可以看出 iterator.h 此时发生了改变，增加了 <code>iterator_type</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator, <span class="keyword">typename</span> _Container&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__normal_iterator</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    _Iterator _M_current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::iterator_traits&lt;_Iterator&gt;		__traits_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Iterator					iterator_type;</span><br><span class="line">      <span class="comment">// 定义了迭代器类型</span></span><br></pre></td></tr></table></figure>
<p>vector 的一个示意图如下所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/a0b4ee6f5f49e85e36e04fbf8d62695c.png" alt="image-20241030145240920" /></p>
<p>下面我们来看一下 vector 的内存处理。</p>
<h4 id="vector-的内存处理"><a class="markdownIt-Anchor" href="#vector-的内存处理"></a> vector 的内存处理</h4>
<p>该部分主要是 vector 遇到空间满了是，此时需要配置另一处空间搬移空间和释放原空间。该过程比较复杂，简要说明。</p>
<p>首先是新增对象时：构造函数或者 <code>push_back()</code> 插入时，我们来看一下，对于构造函数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(size_type __n, <span class="type">const</span> _Tp&amp; __value,</span><br><span class="line">         <span class="type">const</span> allocator_type&amp; __a = <span class="built_in">allocator_type</span>()) </span><br><span class="line">    : _Base(__n, __a)</span><br><span class="line">    &#123; _M_finish = <span class="built_in">uninitialized_fill_n</span>(_M_start, __n, __value); &#125;</span><br><span class="line"><span class="comment">// 上面_Base(_n, __a)会调用_M_allocate(__n)，并修改_M_start,_M_finish和_M_end_of_storage</span></span><br><span class="line"><span class="comment">// 大致流程就是_Base分配内存和调整值，然后再调用复制函数，根据所复制的数据是否时POD来判断是直接内存复制还是采用construct()来构造</span></span><br></pre></td></tr></table></figure>
<p>对于尾部插入函数 <code>push_back</code>，其相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 尾插</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(_M_finish, __x);</span><br><span class="line">      ++_M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _M_insert_aux(<span class="built_in">end</span>(), __x);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// insert的实现</span></span><br><span class="line">vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(iterator __position, <span class="type">const</span> _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 有备用空间，构造一个元素，以vector最后一个元素值为初值</span></span><br><span class="line">  <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">    <span class="built_in">construct</span>(_M_finish, *(_M_finish - <span class="number">1</span>));</span><br><span class="line">    ++_M_finish;</span><br><span class="line">    _Tp __x_copy = __x;</span><br><span class="line">    <span class="built_in">copy_backward</span>(__position, _M_finish - <span class="number">2</span>, _M_finish - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//copy_backward定义在&lt;iterator&gt;头文件中。它的功能是将从[first, last)范围内的元素复制到[result, result + (last - first))范围内，即将x插入到finish前一个空间中，然后将一部分平移</span></span><br><span class="line">    *__position = __x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有备用空间</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 原大小为0，则配置一个元素，否则配置原大小的2倍</span></span><br><span class="line">    <span class="type">const</span> size_type __len = __old_size != <span class="number">0</span> ? <span class="number">2</span> * __old_size : <span class="number">1</span>;</span><br><span class="line">    iterator __new_start = _M_allocate(__len);</span><br><span class="line">    iterator __new_finish = __new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="comment">// 拷贝原vector内容到新的vector</span></span><br><span class="line">      __new_finish = <span class="built_in">uninitialized_copy</span>(_M_start, __position, __new_start);</span><br><span class="line">      <span class="built_in">construct</span>(__new_finish, __x);</span><br><span class="line">      ++__new_finish;</span><br><span class="line">      <span class="comment">// 将原vector备用空间也拷贝过来</span></span><br><span class="line">      __new_finish = <span class="built_in">uninitialized_copy</span>(__position, _M_finish, __new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// commit or rollback</span></span><br><span class="line">    <span class="comment">// 当在构造新对象或执行其他操作时发生异常，__STL_UNWIND 宏会被触发，此时会1.调用析构函数 2. 释放内存</span></span><br><span class="line">    __STL_UNWIND((<span class="built_in">destroy</span>(__new_start,__new_finish), </span><br><span class="line">                  _M_deallocate(__new_start,__len)));</span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    _M_start = __new_start;</span><br><span class="line">    _M_finish = __new_finish;</span><br><span class="line">    _M_end_of_storage = __new_start + __len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。这是程序员易犯的一个错误，务需小心。</p>
<h5 id="vector-的其他操作pop_back-erase-clear-insert"><a class="markdownIt-Anchor" href="#vector-的其他操作pop_back-erase-clear-insert"></a> vector 的其他操作：pop_back, erase, clear, insert</h5>
<p>下面是 pop_back 和两种多态的 erase 和 clear</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --_M_finish;     <span class="comment">// 尾端标记前移</span></span><br><span class="line">    <span class="built_in">destroy</span>(_M_finish);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator __position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">      <span class="built_in">copy</span>(__position + <span class="number">1</span>, _M_finish, __position);  <span class="comment">// 后序元素向前移动</span></span><br><span class="line">    --_M_finish;</span><br><span class="line">    <span class="built_in">destroy</span>(_M_finish);  <span class="comment">// 删除最后一个</span></span><br><span class="line">    <span class="keyword">return</span> __position;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除 [first, last)</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator __first, iterator __last)</span> </span>&#123;</span><br><span class="line">    iterator __i = <span class="built_in">copy</span>(__last, _M_finish, __first);</span><br><span class="line">    <span class="built_in">destroy</span>(__i, _M_finish);</span><br><span class="line">    _M_finish = _M_finish - (__last - __first);</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/8f069783dec855cdf2bbf73c8a35473b.png" alt="image-20241104100733381" /></p>
<p>下面是 vector 的 insert 函数，以及示意图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// position开始插入n个元素，初值为x</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;_Tp, _Alloc&gt;::_M_fill_insert(iterator __position, size_type __n, </span><br><span class="line">                                         <span class="type">const</span> _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 备用空间大于新增个数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(_M_end_of_storage - _M_finish) &gt;= __n) &#123;</span><br><span class="line">      _Tp __x_copy = __x;</span><br><span class="line">      <span class="comment">// 插入点之后的元素个数</span></span><br><span class="line">      <span class="type">const</span> size_type __elems_after = _M_finish - __position;</span><br><span class="line">      iterator __old_finish = _M_finish;</span><br><span class="line">      <span class="keyword">if</span> (__elems_after &gt; __n) &#123;</span><br><span class="line">        <span class="comment">// 插入点后元素个数大于新增个数</span></span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(_M_finish - __n, _M_finish, _M_finish);</span><br><span class="line">        _M_finish += __n;  <span class="comment">// 尾端标记后移</span></span><br><span class="line">        <span class="comment">// 反向复制，避免覆盖</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(__position, __old_finish - __n, __old_finish);</span><br><span class="line">        <span class="built_in">fill</span>(__position, __position + __n, __x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入点后元素个数小于等于新增个数</span></span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(_M_finish, __n - __elems_after, __x_copy);</span><br><span class="line">        _M_finish += __n - __elems_after;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(__position, __old_finish, _M_finish);</span><br><span class="line">        _M_finish += __elems_after;</span><br><span class="line">        <span class="built_in">fill</span>(__position, __old_finish, __x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备用空间小于新增个数，必须配置额外内存</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">const</span> size_type __old_size = <span class="built_in">size</span>();        </span><br><span class="line">      <span class="type">const</span> size_type __len = __old_size + <span class="built_in">max</span>(__old_size, __n);</span><br><span class="line">      iterator __new_start = _M_allocate(__len);</span><br><span class="line">      iterator __new_finish = __new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        __new_finish = <span class="built_in">uninitialized_copy</span>(_M_start, __position, __new_start);</span><br><span class="line">        __new_finish = <span class="built_in">uninitialized_fill_n</span>(__new_finish, __n, __x);</span><br><span class="line">        __new_finish</span><br><span class="line">          = <span class="built_in">uninitialized_copy</span>(__position, _M_finish, __new_finish);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 发生异常， rollback</span></span><br><span class="line">      __STL_UNWIND((<span class="built_in">destroy</span>(__new_start,__new_finish), </span><br><span class="line">                    _M_deallocate(__new_start,__len)));</span><br><span class="line">      <span class="comment">// 清除释放旧vector</span></span><br><span class="line">      <span class="built_in">destroy</span>(_M_start, _M_finish);</span><br><span class="line">      _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">      _M_start = __new_start;</span><br><span class="line">      _M_finish = __new_finish;</span><br><span class="line">      _M_end_of_storage = __new_start + __len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，首先判断 <strong>备用空间是否大于新增个数</strong>：</p>
<ol>
<li>如果是，再判断：<strong>插入点后元素个数是否大于新增个数</strong>
<ol>
<li>如果是的话，如下图，先复制一段，再移动一段（反向后移防止覆盖），再插入所插入的值：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/fbe855d70ec859baba7252eb28990651.png" alt="image-20241104101842778" /></li>
<li>如果否，此时，先在 finish 后面复制超出的要插入的元素，然后移动插入点到 finish 这一段到备用空间，再插入即可。<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/8afc4e21b367e3d886eba655e99b0af0.png" alt="image-20241104102014548" /></li>
</ol>
</li>
<li>如果空间不足，此时需要 1. 新分配空间 2. 复制原有的 vector 过去 3. 插入 4. 销毁之前的旧 vector 空间<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/8e488bfa2eb414c8b0d71c42d949172b.png" alt="image-20241104102224609" /></li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text"> 序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.1.</span> <span class="toc-text"> vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> vector 的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector-%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text"> vector 的内存处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vector-%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9Cpop_back-erase-clear-insert"><span class="toc-number">1.3.1.</span> <span class="toc-text"> vector 的其他操作：pop_back, erase, clear, insert</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2024/10/29/life/STL_3/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2024/10/29/life/STL_3/&text=STL_3"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2024/10/29/life/STL_3/&is_video=false&description=STL_3"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=STL_3&body=Check out this article: https://utmux.github.io/2024/10/29/life/STL_3/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2024/10/29/life/STL_3/&title=STL_3"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2024/10/29/life/STL_3/&name=STL_3&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2024/10/29/life/STL_3/&t=STL_3"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
