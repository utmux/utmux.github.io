<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：一般   C++ 设计模式与设计原则速查指南  1. 引言 设计模式是软件工程中经过实践验证的、针对常见问题的解决方案。它们是抽象的，描述了在特定上下文中解决特定设计问题的通用方法，而不是具体的代码或库。GoF（Gang of Four，四人帮）在他们的著作《设计模式：可复用面向对象软件的基础》中总结了 23 种经典设计模式，分为创建型、结构型和行为型。 掌握设计模式能够：  提">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 设计模式与设计原则速查指南">
<meta property="og:url" content="https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：一般   C++ 设计模式与设计原则速查指南  1. 引言 设计模式是软件工程中经过实践验证的、针对常见问题的解决方案。它们是抽象的，描述了在特定上下文中解决特定设计问题的通用方法，而不是具体的代码或库。GoF（Gang of Four，四人帮）在他们的著作《设计模式：可复用面向对象软件的基础》中总结了 23 种经典设计模式，分为创建型、结构型和行为型。 掌握设计模式能够：  提">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-03T05:32:49.000Z">
<meta property="article:modified_time" content="2026-01-24T15:38:54.413Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>C++ 设计模式与设计原则速查指南</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/categories/Embedded-Linux/">嵌入式/Linux</a></li><!--
     --><!--
       --><li><a href="/categories/Programming/">编程算法</a></li><!--
     --><!--
       --><li><a href="/categories/Research-AI/">学术研究</a></li><!--
     --><!--
       --><li><a href="/categories/Journal/">生活随笔</a></li><!--
     --><!--
       --><li><a href="/archives/">时间轴</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/08/03/Embedded-Linux/Hardware/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/07/25/Embedded-Linux/Kernel/%E9%9F%A6%E4%B8%9C%E5%B1%B1Pinctrl%E7%B3%BB%E7%BB%9F%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&text=C++ 设计模式与设计原则速查指南"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&is_video=false&description=C++ 设计模式与设计原则速查指南"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ 设计模式与设计原则速查指南&body=Check out this article: https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&name=C++ 设计模式与设计原则速查指南&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&t=C++ 设计模式与设计原则速查指南"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text"> C++ 设计模式与设计原则速查指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-creational-patterns"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 创建型设计模式 (Creational Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton-pattern"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 2.1. 单例模式 (Singleton Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-prototype-pattern"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2.2. 原型模式 (Prototype Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-factory-method-pattern"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 2.3. 工厂方法模式 (Factory Method Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-pattern"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 2.4. 抽象工厂模式 (Abstract Factory Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-builder-pattern"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 2.5. 建造者模式 (Builder Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-structural-patterns"><span class="toc-number">1.3.</span> <span class="toc-text"> 3. 结构型设计模式 (Structural Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter-pattern"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 3.1. 适配器模式 (Adapter Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-bridge-pattern"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 3.2. 桥接模式 (Bridge Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-composite-pattern"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 3.3. 组合模式 (Composite Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-decorator-pattern"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 3.4. 装饰器模式 (Decorator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F-facade-pattern"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 3.5. 门面模式 (Facade Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-flyweight-pattern"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 3.6. 享元模式 (Flyweight Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-proxy-pattern"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 3.7. 代理模式 (Proxy Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-behavioral-patterns"><span class="toc-number">1.4.</span> <span class="toc-text"> 4. 行为型设计模式 (Behavioral Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-template-method-pattern"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 4.1. 模板方法模式 (Template Method Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-iterator-pattern"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 4.2. 迭代器模式 (Iterator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-chain-of-responsibility-pattern"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 4.3. 责任链模式 (Chain of Responsibility Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-strategy-pattern"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 4.4. 策略模式 (Strategy Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-state-pattern"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 4.5. 状态模式 (State Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-memento-pattern"><span class="toc-number">1.4.6.</span> <span class="toc-text"> 4.6. 备忘录模式 (Memento Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-mediator-pattern"><span class="toc-number">1.4.7.</span> <span class="toc-text"> 4.7. 中介者模式 (Mediator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-command-pattern"><span class="toc-number">1.4.8.</span> <span class="toc-text"> 4.8. 命令模式 (Command Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-visitor-pattern"><span class="toc-number">1.4.9.</span> <span class="toc-text"> 4.9. 访问者模式 (Visitor Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#410-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-observer-pattern"><span class="toc-number">1.4.10.</span> <span class="toc-text"> 4.10. 观察者模式 (Observer Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#411-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-interpreter-pattern"><span class="toc-number">1.4.11.</span> <span class="toc-text"> 4.11. 解释器模式 (Interpreter Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text"> 5. 设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E%E8%BE%A8%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text"> 6. 设计模式对比与辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 6.1. 创建型模式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 6.2. 结构型模式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 6.3. 行为型模式对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text"> 7. 总结</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        C++ 设计模式与设计原则速查指南
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-08-03T05:32:49.000Z" class="dt-published" itemprop="datePublished">2025-08-03</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Programming/">Programming</a> › <a class="category-link" href="/categories/Programming/CPP-Core/">CPP-Core</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：一般</p>
<hr />
<h1 id="c-设计模式与设计原则速查指南"><a class="markdownIt-Anchor" href="#c-设计模式与设计原则速查指南"></a> C++ 设计模式与设计原则速查指南</h1>
<h2 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1. 引言</h2>
<p>设计模式是软件工程中经过实践验证的、针对常见问题的解决方案。它们是抽象的，描述了在特定上下文中解决特定设计问题的通用方法，而不是具体的代码或库。GoF（Gang of Four，四人帮）在他们的著作《设计模式：可复用面向对象软件的基础》中总结了 23 种经典设计模式，分为创建型、结构型和行为型。</p>
<p>掌握设计模式能够：</p>
<ul>
<li><strong>提供共同语言：</strong> 团队成员之间可以使用模式名称进行高效沟通。</li>
<li><strong>提高代码质量：</strong> 编写更健壮、可维护、可扩展和可复用的代码。</li>
<li><strong>应对变化：</strong> 模式通常旨在解决特定类型的变化，使系统更灵活。</li>
<li><strong>促进复用：</strong> 模式本身就是可复用的设计经验。</li>
</ul>
<p>本指南将系统地介绍这 23 种 GoF 设计模式，提供 C++代码示例，并总结面向对象设计的六大原则，最后对易混淆的模式进行对比。</p>
<hr />
<h2 id="2-创建型设计模式-creational-patterns"><a class="markdownIt-Anchor" href="#2-创建型设计模式-creational-patterns"></a> 2. 创建型设计模式 (Creational Patterns)</h2>
<p>这类模式关注对象的创建机制，帮助系统独立于对象的创建、组合和表示。</p>
<h3 id="21-单例模式-singleton-pattern"><a class="markdownIt-Anchor" href="#21-单例模式-singleton-pattern"></a> 2.1. 单例模式 (Singleton Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 确保一个类只有一个实例，并提供一个全局访问点。</p>
</li>
<li>
<p><strong>核心思想：</strong> 私有化构造器，通过静态方法提供唯一实例。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Singleton：</strong> 唯一实例的类，包含私有构造器、静态的 <code>getInstance()</code> 方法和静态的唯一实例。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>保证唯一实例，避免资源浪费。</li>
<li>提供全局访问点。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>可能导致代码紧密耦合（全局访问点）。</li>
<li>在多线程环境下需要额外处理线程安全。</li>
<li>扩展性较差，如果需要多个实例则不适用。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要唯一标识和访问点（如日志记录器、配置管理器、线程池、缓存）。</li>
<li>控制对特定资源的访问。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例 (线程安全的饿汉式)</strong>：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// For thread safety</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部直接创建实例</span></span><br><span class="line">    <span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger instance created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数和赋值运算符，防止复制</span></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Logger&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态方法提供全局访问点</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 懒汉式 (推荐): C++11 之后局部静态变量的初始化是线程安全的</span></span><br><span class="line">        <span class="type">static</span> Logger instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际的日志写入逻辑</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     Logger&amp; logger1 = Logger:: getInstance();</span></span><br><span class="line"><span class="comment">//     Logger&amp; logger2 = Logger:: getInstance();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Are logger1 and logger2 the same instance? &quot; &lt;&lt; (&amp;logger1 == &amp;logger2 ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     logger1.log(&quot;Application started.&quot;);</span></span><br><span class="line"><span class="comment">//     logger2.log(&quot;User logged in.&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="22-原型模式-prototype-pattern"><a class="markdownIt-Anchor" href="#22-原型模式-prototype-pattern"></a> 2.2. 原型模式 (Prototype Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 通过复制一个现有的实例来创建新对象，而不是通过 <code>new</code> 关键字实例化。</p>
</li>
<li>
<p><strong>核心思想：</strong> 克隆 (Cloning)。避免直接实例化，尤其是当创建过程复杂或对象状态较多时。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Prototype (抽象原型)：</strong> 声明一个克隆自身的接口。</li>
<li><strong>Concrete Prototype (具体原型)：</strong> 实现克隆操作。</li>
<li><strong>Client (客户端)：</strong> 使用抽象原型接口来创建新对象。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>创建新对象时无需知道其具体类。</li>
<li>简化复杂对象的创建。</li>
<li>动态地添加或删除产品。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>每个具体原型类都必须实现克隆操作。</li>
<li>深拷贝和浅拷贝问题需要仔细处理。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当对象的创建开销较大，或者需要避免与对象的具体类紧密耦合时。</li>
<li>当需要创建大量相似对象时（如游戏中的敌人、图形编辑器中的形状）。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象原型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Document&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Document</span>() = <span class="keyword">default</span>; <span class="comment">// 虚析构函数确保正确释放内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：报告</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Report</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content;</span><br><span class="line">    <span class="type">int</span> pageCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Report</span>(<span class="type">const</span> std::string&amp; content, <span class="type">int</span> pageCount) : <span class="built_in">content</span>(content), <span class="built_in">pageCount</span>(pageCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝实现</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Report&gt;(*<span class="keyword">this</span>); <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Report: \&quot;&quot;</span> &lt;&lt; content &lt;&lt; <span class="string">&quot;\&quot;, Pages: &quot;</span> &lt;&lt; pageCount &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateContent</span><span class="params">(<span class="type">const</span> std::string&amp; newContent)</span> </span>&#123;</span><br><span class="line">        content = newContent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型：简历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resume</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string experience;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resume</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; experience) : <span class="built_in">name</span>(name), <span class="built_in">experience</span>(experience) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Resume&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resume: Name - &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Experience - &quot;</span> &lt;&lt; experience &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addExperience</span><span class="params">(<span class="type">const</span> std::string&amp; newExp)</span> </span>&#123;</span><br><span class="line">        experience += <span class="string">&quot;; &quot;</span> + newExp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Report&gt; originalReport = std:: make_unique &lt;Report&gt;(&quot;Sales Q1&quot;, 50);</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Original Report: &quot;;</span></span><br><span class="line"><span class="comment">//     originalReport-&gt; print();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 克隆报告</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Report&gt; clonedReport = static_cast &lt;std::unique_ptr&lt;Report&gt; &gt;(originalReport-&gt; clone());</span></span><br><span class="line"><span class="comment">//     clonedReport-&gt; updateContent(&quot;Sales Q2&quot;); // 修改克隆体</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Cloned Report (modified): &quot;;</span></span><br><span class="line"><span class="comment">//     clonedReport-&gt; print();</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Original Report (after clone modification): &quot;;</span></span><br><span class="line"><span class="comment">//     originalReport-&gt; print(); // 原始对象不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n------------------\n&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Resume&gt; originalResume = std:: make_unique &lt;Resume&gt;(&quot;John Doe&quot;, &quot;Software Engineer at ABC Inc.&quot;);</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Original Resume: &quot;;</span></span><br><span class="line"><span class="comment">//     originalResume-&gt; print();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Resume&gt; clonedResume = static_cast &lt;std::unique_ptr&lt;Resume&gt; &gt;(originalResume-&gt; clone());</span></span><br><span class="line"><span class="comment">//     clonedResume-&gt; addExperience(&quot;Project Manager at XYZ Corp.&quot;);</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Cloned Resume (modified): &quot;;</span></span><br><span class="line"><span class="comment">//     clonedResume-&gt; print();</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Original Resume (after clone modification): &quot;;</span></span><br><span class="line"><span class="comment">//     originalResume-&gt; print(); // 原始对象不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="23-工厂方法模式-factory-method-pattern"><a class="markdownIt-Anchor" href="#23-工厂方法模式-factory-method-pattern"></a> 2.3. 工厂方法模式 (Factory Method Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将产品创建的责任交给具体的工厂子类，实现“开闭原则”。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Product (抽象产品)：</strong> 定义产品接口或抽象类。</li>
<li><strong>Concrete Product (具体产品)：</strong> 实现产品接口。</li>
<li><strong>Creator (抽象工厂)：</strong> 定义创建产品对象的工厂方法，可能包含其他业务方法。</li>
<li><strong>Concrete Creator (具体工厂)：</strong> 实现工厂方法，返回具体产品实例。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>解耦：客户端代码不直接依赖具体产品类，只依赖抽象产品和抽象工厂。</li>
<li>可扩展性：增加新产品时，只需增加新的具体产品类和新的具体工厂类，不修改现有代码。</li>
<li>符合“开闭原则”。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个产品，就需要增加一个具体工厂，类的数量会增多。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个类无法预知它将要创建的对象的类时。</li>
<li>当一个类希望由其子类来指定它所创建的对象时。</li>
<li>框架中，由框架决定创建何种对象，但用户可以扩展。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">save</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Document</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Opening Word Document.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Saving Word Document.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PdfDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Opening PDF Document.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Saving PDF Document.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DocumentFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里定义其他公共业务逻辑</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;Document&gt; doc = <span class="built_in">createDocument</span>();</span><br><span class="line">        doc-&gt;<span class="built_in">open</span>();</span><br><span class="line">        <span class="comment">// ... 其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDocumentFactory</span> : <span class="keyword">public</span> DocumentFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WordDocument&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PdfDocumentFactory</span> : <span class="keyword">public</span> DocumentFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Document&gt; <span class="title">createDocument</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;PdfDocument&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;DocumentFactory&gt; wordFactory = std:: make_unique &lt;WordDocumentFactory&gt;();</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Document&gt; wordDoc = wordFactory-&gt; createDocument();</span></span><br><span class="line"><span class="comment">//     wordDoc-&gt; open();</span></span><br><span class="line"><span class="comment">//     wordDoc-&gt; save();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;---&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;DocumentFactory&gt; pdfFactory = std:: make_unique &lt;PdfDocumentFactory&gt;();</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Document&gt; pdfDoc = pdfFactory-&gt; createDocument();</span></span><br><span class="line"><span class="comment">//     pdfDoc-&gt; open();</span></span><br><span class="line"><span class="comment">//     pdfDoc-&gt; save();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="24-抽象工厂模式-abstract-factory-pattern"><a class="markdownIt-Anchor" href="#24-抽象工厂模式-abstract-factory-pattern"></a> 2.4. 抽象工厂模式 (Abstract Factory Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</p>
</li>
<li>
<p><strong>核心思想：</strong> 工厂的工厂。它管理多个工厂方法，每个工厂方法生产一种类型的产品，但这些产品属于同一个“产品族”。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Abstract Factory (抽象工厂)：</strong> 声明创建抽象产品对象的操作接口。</li>
<li><strong>Concrete Factory (具体工厂)：</strong> 实现创建具体产品对象的操作。</li>
<li><strong>Abstract Product (抽象产品)：</strong> 声明一类产品对象的接口。</li>
<li><strong>Concrete Product (具体产品)：</strong> 定义一个将被相应具体工厂创建的产品对象。</li>
<li><strong>Client (客户端)：</strong> 使用抽象工厂和抽象产品接口。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>隔离了具体类：客户端与具体产品的实现解耦。</li>
<li>易于交换产品系列：可以很方便地切换整个产品族。</li>
<li>保证产品族的一致性：创建出的产品总是来自同一个产品族。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加新产品系列时，需要修改所有工厂接口和实现，不符合“开闭原则”中的对产品族的扩展。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>一个系统要独立于它产品的创建、组合和表示时。</li>
<li>一个系统要由多个产品系列中的一个来配置时。</li>
<li>需要创建一组相关或相互依赖的对象，而无需指定其具体类时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品 A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rendering a Windows Button.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品 A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rendering a Mac Button.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Checkbox</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品 B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsCheckbox</span> : <span class="keyword">public</span> Checkbox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rendering a Windows Checkbox.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品 B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> : <span class="keyword">public</span> Checkbox &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rendering a Mac Checkbox.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Checkbox&gt; <span class="title">createCheckbox</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">GUIFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂 1：Windows 风格</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Checkbox&gt; <span class="title">createCheckbox</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WindowsCheckbox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂 2：Mac 风格</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> : <span class="keyword">public</span> GUIFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Button&gt; <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacButton&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Checkbox&gt; <span class="title">createCheckbox</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MacCheckbox&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;GUIFactory&gt; factory;</span><br><span class="line">    std::unique_ptr&lt;Button&gt; button;</span><br><span class="line">    std::unique_ptr&lt;Checkbox&gt; checkbox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Application</span>(std::unique_ptr&lt;GUIFactory&gt; fact) : <span class="built_in">factory</span>(std::<span class="built_in">move</span>(fact)) &#123;</span><br><span class="line">        button = factory-&gt;<span class="built_in">createButton</span>();</span><br><span class="line">        checkbox = factory-&gt;<span class="built_in">createCheckbox</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        button-&gt;<span class="built_in">render</span>();</span><br><span class="line">        checkbox-&gt;<span class="built_in">render</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Client: Testing app with Windows factory.&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;GUIFactory&gt; windowsFactory = std:: make_unique &lt;WindowsFactory&gt;();</span></span><br><span class="line"><span class="comment">//     Application app1(std:: move(windowsFactory));</span></span><br><span class="line"><span class="comment">//     app1.run();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\nClient: Testing app with Mac factory.&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;GUIFactory&gt; macFactory = std:: make_unique &lt;MacFactory&gt;();</span></span><br><span class="line"><span class="comment">//     Application app2(std:: move(macFactory));</span></span><br><span class="line"><span class="comment">//     app2.run();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="25-建造者模式-builder-pattern"><a class="markdownIt-Anchor" href="#25-建造者模式-builder-pattern"></a> 2.5. 建造者模式 (Builder Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p>
</li>
<li>
<p><strong>核心思想：</strong> 分步构建。一步步构建复杂对象，最后一次性获取。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Builder (抽象建造者)：</strong> 为创建产品各个部件的抽象接口。</li>
<li><strong>Concrete Builder (具体建造者)：</strong> 实现抽象建造者接口，并实际构建和装配产品。</li>
<li><strong>Product (产品)：</strong> 表示被构建的复杂对象。</li>
<li><strong>Director (指挥者)：</strong> 负责构建产品的步骤，但不关心具体的构建细节。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将复杂对象的构建过程与它的表示分离，使得构建过程可以独立于产品的具体实现而变化。</li>
<li>可以控制构建过程的精细程度。</li>
<li>可以灵活地创建不同类型的产品表示。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了系统的复杂性，需要引入多个类。</li>
<li>如果产品内部变化很小，则不适用。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构建过程需要允许不同的产品表示时。</li>
<li>当一个对象的构造函数参数过多时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品：汽车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string engine;</span><br><span class="line">    std::string tires;</span><br><span class="line">    std::string color;</span><br><span class="line">    std::vector&lt;std::string&gt; features;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEngine</span><span class="params">(<span class="type">const</span> std::string&amp; eng)</span> </span>&#123; engine = eng; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTires</span><span class="params">(<span class="type">const</span> std::string&amp; trs)</span> </span>&#123; tires = trs; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> std::string&amp; clr)</span> </span>&#123; color = clr; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFeature</span><span class="params">(<span class="type">const</span> std::string&amp; feature)</span> </span>&#123; features.<span class="built_in">push_back</span>(feature); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;--- Car Details ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Engine: &quot;</span> &lt;&lt; engine &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Tires: &quot;</span> &lt;&lt; tires &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Color: &quot;</span> &lt;&lt; color &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Features: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; f : features) &#123;</span><br><span class="line">            std::cout &lt;&lt; f &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::unique_ptr&lt;Car&gt; car;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CarBuilder</span>() &#123; car = std::<span class="built_in">make_unique</span>&lt;Car&gt;(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildTires</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildColor</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildFeatures</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Car&gt; <span class="title">getCar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(car); &#125; <span class="comment">// 转移所有权</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CarBuilder</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者：SUV 汽车建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SUVCarBuilder</span> : <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; car-&gt;<span class="built_in">setEngine</span>(<span class="string">&quot;V6 SUV Engine&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildTires</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; car-&gt;<span class="built_in">setTires</span>(<span class="string">&quot;Off-road Tires&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildColor</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; car-&gt;<span class="built_in">setColor</span>(<span class="string">&quot;Black&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildFeatures</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;<span class="built_in">addFeature</span>(<span class="string">&quot;4x4 Drive&quot;</span>);</span><br><span class="line">        car-&gt;<span class="built_in">addFeature</span>(<span class="string">&quot;Roof Rack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者：跑车建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SportsCarBuilder</span> : <span class="keyword">public</span> CarBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; car-&gt;<span class="built_in">setEngine</span>(<span class="string">&quot;V8 Sports Engine&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildTires</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; car-&gt;<span class="built_in">setTires</span>(<span class="string">&quot;Low Profile Tires&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildColor</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; car-&gt;<span class="built_in">setColor</span>(<span class="string">&quot;Red&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildFeatures</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        car-&gt;<span class="built_in">addFeature</span>(<span class="string">&quot;Spoiler&quot;</span>);</span><br><span class="line">        car-&gt;<span class="built_in">addFeature</span>(<span class="string">&quot;Sport Suspension&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarDirector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">construct</span><span class="params">(CarBuilder&amp; builder)</span> </span>&#123;</span><br><span class="line">        builder.<span class="built_in">buildEngine</span>();</span><br><span class="line">        builder.<span class="built_in">buildTires</span>();</span><br><span class="line">        builder.<span class="built_in">buildColor</span>();</span><br><span class="line">        builder.<span class="built_in">buildFeatures</span>();</span><br><span class="line">        <span class="keyword">return</span> builder.<span class="built_in">getCar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     CarDirector director;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     SUVCarBuilder suvBuilder;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Car&gt; suv = director.construct(suvBuilder);</span></span><br><span class="line"><span class="comment">//     suv-&gt; showCar();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     SportsCarBuilder sportsBuilder;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Car&gt; sportsCar = director.construct(sportsBuilder);</span></span><br><span class="line"><span class="comment">//     sportsCar-&gt; showCar();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="3-结构型设计模式-structural-patterns"><a class="markdownIt-Anchor" href="#3-结构型设计模式-structural-patterns"></a> 3. 结构型设计模式 (Structural Patterns)</h2>
<p>这类模式关注如何组合类或对象以获得更大的结构。</p>
<h3 id="31-适配器模式-adapter-pattern"><a class="markdownIt-Anchor" href="#31-适配器模式-adapter-pattern"></a> 3.1. 适配器模式 (Adapter Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 将一个类的接口转换成客户希望的另一个接口。适配器模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</li>
<li>
<p><strong>核心思想：</strong> 充当一个中间转换器，将被适配者（Adaptee）的接口转换为目标接口（Target）。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Target (目标接口)：</strong> 客户端期望的接口。</li>
<li><strong>Adaptee (被适配者)：</strong> 现有的、需要被适配的类。</li>
<li><strong>Adapter (适配器)：</strong> 实现目标接口，并包含一个被适配者的实例（对象适配器）或继承被适配者（类适配器），将目标接口的请求委托给被适配者。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>复用现有类，无需修改原代码。</li>
<li>提高类的透明度和复用性。</li>
<li>将目标类和被适配者类解耦。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加代码复杂度（多了一个适配器类）。</li>
<li>过度使用会使系统维护变得困难。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>想使用一个已经存在的类，而它的接口不符合你的需求。</li>
<li>你想创建一个可复用的类，该类可以与不相关的类或不兼容的接口协同工作。</li>
<li>（尤其常见于整合第三方库、遗留系统时）。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例 (对象适配器)：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口：客户端期望的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPaymentGateway</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NewPaymentGateway</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被适配者：老旧的支付系统，接口不兼容</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldPaymentSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeDollarPayment</span><span class="params">(<span class="type">double</span> valueInDollars)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using old system to process payment: $&quot;</span> &lt;&lt; valueInDollars &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器：将老旧系统适配到新接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldToNewPaymentAdapter</span> : <span class="keyword">public</span> NewPaymentGateway &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    OldPaymentSystem* oldSystem; <span class="comment">// 组合被适配者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OldToNewPaymentAdapter</span>(OldPaymentSystem* system) : <span class="built_in">oldSystem</span>(system) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 接口转换逻辑：新接口的 processPayment 方法调用老接口的 makeDollarPayment</span></span><br><span class="line">        oldSystem-&gt;<span class="built_in">makeDollarPayment</span>(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     OldPaymentSystem legacySystem;</span></span><br><span class="line"><span class="comment">//     // 客户端使用新的支付接口，通过适配器调用旧系统</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;NewPaymentGateway&gt; gateway = std:: make_unique &lt;OldToNewPaymentAdapter&gt;(&amp;legacySystem);</span></span><br><span class="line"><span class="comment">//     gateway-&gt; processPayment(100.0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="32-桥接模式-bridge-pattern"><a class="markdownIt-Anchor" href="#32-桥接模式-bridge-pattern"></a> 3.2. 桥接模式 (Bridge Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</li>
<li>
<p><strong>核心思想：</strong> 通过组合和委托，将两个独立变化的维度（抽象和实现）解耦。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Abstraction (抽象部分)：</strong> 定义抽象接口，并包含一个指向 <code>Implementor</code> 的引用。</li>
<li><strong>Refined Abstraction (修正抽象)：</strong> 扩展抽象部分。</li>
<li><strong>Implementor (实现部分)：</strong> 定义实现类的接口，不关心抽象部分。</li>
<li><strong>Concrete Implementor (具体实现)：</strong> 实现 <code>Implementor</code> 接口。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将抽象和实现解耦，使它们可以独立地扩展，避免类爆炸。</li>
<li>符合“开闭原则”。</li>
<li>提高系统的灵活性。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了类的数量和系统的复杂度。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个类存在两个或多个独立变化的维度，并且这些维度都需要独立扩展时。</li>
<li>当不希望在抽象和它的实现之间有一个固定的绑定关系时。</li>
<li>在运行时切换对象的实现时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现部分接口 (Implementor)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setChannel</span><span class="params">(<span class="type">int</span> channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Device</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现 A (Concrete Implementor)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span> : <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">turnOn</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;TV is ON.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">turnOff</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;TV is OFF.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChannel</span><span class="params">(<span class="type">int</span> channel)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;TV Channel set to &quot;</span> &lt;&lt; channel &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现 B (Concrete Implementor)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Radio</span> : <span class="keyword">public</span> Device &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">turnOn</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Radio is ON.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">turnOff</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Radio is OFF.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChannel</span><span class="params">(<span class="type">int</span> channel)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Radio Frequency set to &quot;</span> &lt;&lt; channel &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象部分 (Abstraction)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::unique_ptr&lt;Device&gt; device; <span class="comment">// 桥接点：通过组合引用实现部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RemoteControl</span>(std::unique_ptr&lt;Device&gt; dev) : <span class="built_in">device</span>(std::<span class="built_in">move</span>(dev)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setChannel</span><span class="params">(<span class="type">int</span> channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RemoteControl</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正抽象 (Refined Abstraction)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicRemote</span> : <span class="keyword">public</span> RemoteControl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BasicRemote</span>(std::unique_ptr&lt;Device&gt; dev) : <span class="built_in">RemoteControl</span>(std::<span class="built_in">move</span>(dev)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">powerOn</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; device-&gt;<span class="built_in">turnOn</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">powerOff</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; device-&gt;<span class="built_in">turnOff</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChannel</span><span class="params">(<span class="type">int</span> channel)</span> <span class="keyword">override</span> </span>&#123; device-&gt;<span class="built_in">setChannel</span>(channel); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedRemote</span> : <span class="keyword">public</span> RemoteControl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AdvancedRemote</span>(std::unique_ptr&lt;Device&gt; dev) : <span class="built_in">RemoteControl</span>(std::<span class="built_in">move</span>(dev)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">powerOn</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; device-&gt;<span class="built_in">turnOn</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">powerOff</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; device-&gt;<span class="built_in">turnOff</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChannel</span><span class="params">(<span class="type">int</span> channel)</span> <span class="keyword">override</span> </span>&#123; device-&gt;<span class="built_in">setChannel</span>(channel); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Device is muted.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 可以添加更多高级功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     // 使用 BasicRemote 控制 TV</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Device&gt; tv = std:: make_unique &lt;Tv&gt;();</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;RemoteControl&gt; basicTvRemote = std:: make_unique &lt;BasicRemote&gt;(std:: move(tv));</span></span><br><span class="line"><span class="comment">//     basicTvRemote-&gt; powerOn();</span></span><br><span class="line"><span class="comment">//     basicTvRemote-&gt; setChannel(5);</span></span><br><span class="line"><span class="comment">//     basicTvRemote-&gt; powerOff();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;---&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 使用 AdvancedRemote 控制 Radio</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Device&gt; radio = std:: make_unique &lt;Radio&gt;();</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;AdvancedRemote&gt; advancedRadioRemote = std:: make_unique &lt;AdvancedRemote&gt;(std:: move(radio));</span></span><br><span class="line"><span class="comment">//     advancedRadioRemote-&gt; powerOn();</span></span><br><span class="line"><span class="comment">//     advancedRadioRemote-&gt; setChannel(98500); // Radio frequency</span></span><br><span class="line"><span class="comment">//     advancedRadioRemote-&gt; mute();</span></span><br><span class="line"><span class="comment">//     advancedRadioRemote-&gt; powerOff();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="33-组合模式-composite-pattern"><a class="markdownIt-Anchor" href="#33-组合模式-composite-pattern"></a> 3.3. 组合模式 (Composite Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</li>
<li>
<p><strong>核心思想：</strong> 对叶子对象和组合对象提供统一的接口，让客户端无需区分它们。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Component (抽象构件)：</strong> 定义了叶子和组合对象的共同接口。</li>
<li><strong>Leaf (叶子构件)：</strong> 没有子构件的构件，实现 <code>Component</code> 接口。</li>
<li><strong>Composite (组合构件)：</strong> 包含子构件（可以是 <code>Leaf</code> 也可以是 <code>Composite</code>），实现 <code>Component</code> 接口，并提供管理子构件的方法。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>统一性：客户端可以一致地处理单个对象和组合对象。</li>
<li>简化客户端代码：客户端无需区分复杂对象和简单对象。</li>
<li>易于扩展：添加新的构件类型无需修改现有代码。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>设计复杂：需要考虑构件的父子关系和递归操作。</li>
<li>可能使组件接口过于通用，导致叶子节点实现一些无意义的方法。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当需要表示对象的部分-整体层次结构时（如文件系统、组织架构、UI 组件）。</li>
<li>当希望用户忽略组合对象和单个对象的区别，统一对待它们时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象构件 (Component)：定义了文件和文件夹的共同操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> std::string&amp; indent)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FileSystemComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子构件 (Leaf)：文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> std::string&amp; indent)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; indent &lt;&lt; <span class="string">&quot;File: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合构件 (Composite)：文件夹</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;FileSystemComponent&gt;&gt; components;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Folder</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addComponent</span><span class="params">(std::unique_ptr&lt;FileSystemComponent&gt; component)</span> </span>&#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(component));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> std::string&amp; indent)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; indent &lt;&lt; <span class="string">&quot;Folder: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; component : components) &#123;</span><br><span class="line">            component-&gt;<span class="built_in">display</span>(indent + <span class="string">&quot;  &quot;</span>); <span class="comment">// 递归显示子组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     // 构建文件系统结构</span></span><br><span class="line"><span class="comment">//     Folder root(&quot;Root&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     auto myDocuments = std:: make_unique &lt;Folder&gt;(&quot;MyDocuments&quot;);</span></span><br><span class="line"><span class="comment">//     myDocuments-&gt; addComponent(std:: make_unique &lt;File&gt;(&quot;Resume.pdf&quot;));</span></span><br><span class="line"><span class="comment">//     myDocuments-&gt; addComponent(std:: make_unique &lt;File&gt;(&quot;Letter.docx&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     auto pictures = std:: make_unique &lt;Folder&gt;(&quot;Pictures&quot;);</span></span><br><span class="line"><span class="comment">//     pictures-&gt; addComponent(std:: make_unique &lt;File&gt;(&quot;Vacation.jpg&quot;));</span></span><br><span class="line"><span class="comment">//     pictures-&gt; addComponent(std:: make_unique &lt;File&gt;(&quot;Family.png&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     root.addComponent(std:: move(myDocuments));</span></span><br><span class="line"><span class="comment">//     root.addComponent(std:: move(pictures));</span></span><br><span class="line"><span class="comment">//     root.addComponent(std:: make_unique &lt;File&gt;(&quot;Readme.txt&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 统一操作：无论是文件还是文件夹，都调用 display 方法</span></span><br><span class="line"><span class="comment">//     root.display(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="34-装饰器模式-decorator-pattern"><a class="markdownIt-Anchor" href="#34-装饰器模式-decorator-pattern"></a> 3.4. 装饰器模式 (Decorator Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活。</p>
</li>
<li>
<p><strong>核心思想：</strong> 通过“包装”或“包裹”一个对象来增强其功能，而不是通过继承。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Component (抽象构件)：</strong> 定义了被装饰对象和装饰器共同的接口。</li>
<li><strong>Concrete Component (具体构件)：</strong> 被装饰的原始对象。</li>
<li><strong>Decorator (抽象装饰器)：</strong> 实现 <code>Component</code> 接口，并包含一个 <code>Component</code> 类型的引用。它是一个抽象类，具体装饰器将继承它。</li>
<li><strong>Concrete Decorator (具体装饰器)：</strong> 扩展 <code>Decorator</code>，向其包裹的构件添加新功能。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>比继承更灵活，可以动态地添加或撤销功能。</li>
<li>避免“类爆炸”问题，特别是在需要多种功能组合时。</li>
<li>符合“开闭原则”。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>会创建许多小对象，增加系统的复杂性。</li>
<li>如果多次装饰，调试可能会变得复杂。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>在不影响其他对象的情况下，动态地给一个对象添加功能。</li>
<li>当不能或不方便通过继承来扩展一个类的功能时。</li>
<li>当需要添加的功能可以按层级或组合的方式排列时（如 C++ <code>std::iostream</code>）。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象构件 (Component)：咖啡接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Coffee</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体构件 (Concrete Component)：基本咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰器 (Decorator)：咖啡配料基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::unique_ptr&lt;Coffee&gt; decoratedCoffee; <span class="comment">// 组合被装饰对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoffeeDecorator</span>(std::unique_ptr&lt;Coffee&gt; coffee) : <span class="built_in">decoratedCoffee</span>(std::<span class="built_in">move</span>(coffee)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认实现，委托给被装饰对象</span></span><br><span class="line">    <span class="function">std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee-&gt;<span class="built_in">getDescription</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee-&gt;<span class="built_in">getCost</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器 (Concrete Decorator A)：加牛奶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkDecorator</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MilkDecorator</span>(std::unique_ptr&lt;Coffee&gt; coffee) : <span class="built_in">CoffeeDecorator</span>(std::<span class="built_in">move</span>(coffee)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee-&gt;<span class="built_in">getDescription</span>() + <span class="string">&quot;, with Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee-&gt;<span class="built_in">getCost</span>() + <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器 (Concrete Decorator B)：加糖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SugarDecorator</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SugarDecorator</span>(std::unique_ptr&lt;Coffee&gt; coffee) : <span class="built_in">CoffeeDecorator</span>(std::<span class="built_in">move</span>(coffee)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee-&gt;<span class="built_in">getDescription</span>() + <span class="string">&quot;, with Sugar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee-&gt;<span class="built_in">getCost</span>() + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Coffee&gt; coffee = std:: make_unique &lt;SimpleCoffee&gt;();</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; coffee-&gt; getDescription() &lt;&lt; &quot; $&quot; &lt;&lt; coffee-&gt; getCost() &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 加牛奶</span></span><br><span class="line"><span class="comment">//     coffee = std:: make_unique &lt;MilkDecorator&gt;(std:: move(coffee));</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; coffee-&gt; getDescription() &lt;&lt; &quot; $&quot; &lt;&lt; coffee-&gt; getCost() &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 再加糖</span></span><br><span class="line"><span class="comment">//     coffee = std:: make_unique &lt;SugarDecorator&gt;(std:: move(coffee));</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; coffee-&gt; getDescription() &lt;&lt; &quot; $&quot; &lt;&lt; coffee-&gt; getCost() &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 也可以直接创建加了牛奶和糖的咖啡</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Coffee&gt; anotherCoffee = std:: make_unique &lt;SugarDecorator&gt;(</span></span><br><span class="line"><span class="comment">//                                               std:: make_unique &lt;MilkDecorator&gt;(</span></span><br><span class="line"><span class="comment">//                                                 std:: make_unique &lt;SimpleCoffee&gt;()</span></span><br><span class="line"><span class="comment">//                                               )</span></span><br><span class="line"><span class="comment">//                                             );</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; anotherCoffee-&gt; getDescription() &lt;&lt; &quot; $&quot; &lt;&lt; anotherCoffee-&gt; getCost() &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="35-门面模式-facade-pattern"><a class="markdownIt-Anchor" href="#35-门面模式-facade-pattern"></a> 3.5. 门面模式 (Facade Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 为子系统中的一组接口提供一个统一的、高层次的接口。门面模式定义了一个新的接口，使子系统更容易使用。</p>
</li>
<li>
<p><strong>核心思想：</strong> 封装复杂子系统的内部实现和交互逻辑，对外提供一个简化的入口。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Facade (门面)：</strong> 提供统一的简化接口，它知道哪些子系统类负责处理请求，并将客户端的请求委托给适当的子系统对象。</li>
<li><strong>Subsystem Classes (子系统类)：</strong> 实现子系统的具体功能，它们不了解门面。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>简化客户端与复杂子系统之间的交互。</li>
<li>将客户端与子系统解耦，防止客户端直接访问子系统内部细节。</li>
<li>提高子系统的可维护性。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>如果门面设计不当，可能成为“上帝对象”，承担过多职责。</li>
<li>增加了一个门面层，可能略微增加调用开销（通常可忽略）。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个系统变得非常复杂，包含大量类时，为客户端提供一个简单的入口。</li>
<li>当你想将客户端与子系统解耦，防止客户端直接访问子系统内部细节。</li>
<li>当你想为不同的客户端提供不同的访问接口（可以有多个门面）。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类：投影仪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Projector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Projector ON&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Projector OFF&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wideScreenMode</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Projector in widescreen mode&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类：功放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amplifier</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Amplifier ON&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Amplifier OFF&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDvdPlayer</span><span class="params">(<span class="type">const</span> std::string&amp; player)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Amplifier setting DVD player: &quot;</span> &lt;&lt; player &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVolume</span><span class="params">(<span class="type">int</span> volume)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Amplifier volume set to &quot;</span> &lt;&lt; volume &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类：DVD 播放器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DvdPlayer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;DVD Player ON&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;DVD Player OFF&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(<span class="type">const</span> std::string&amp; movie)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Playing movie: &quot;</span> &lt;&lt; movie &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Stopping movie&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门面类：家庭影院</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Projector&gt; projector;</span><br><span class="line">    std::unique_ptr&lt;Amplifier&gt; amplifier;</span><br><span class="line">    std::unique_ptr&lt;DvdPlayer&gt; dvdPlayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HomeTheaterFacade</span>(std::unique_ptr&lt;Projector&gt; proj, std::unique_ptr&lt;Amplifier&gt; amp, std::unique_ptr&lt;DvdPlayer&gt; dvd)</span><br><span class="line">        : <span class="built_in">projector</span>(std::<span class="built_in">move</span>(proj)), <span class="built_in">amplifier</span>(std::<span class="built_in">move</span>(amp)), <span class="built_in">dvdPlayer</span>(std::<span class="built_in">move</span>(dvd)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化操作：观看电影</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">watchMovie</span><span class="params">(<span class="type">const</span> std::string&amp; movie)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nGet ready to watch a movie...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        projector-&gt;<span class="built_in">on</span>();</span><br><span class="line">        projector-&gt;<span class="built_in">wideScreenMode</span>();</span><br><span class="line">        amplifier-&gt;<span class="built_in">on</span>();</span><br><span class="line">        amplifier-&gt;<span class="built_in">setDvdPlayer</span>(<span class="string">&quot;DVD Player&quot;</span>); <span class="comment">// 这里直接使用字符串作为标识，实际中可能传递 DvdPlayer 对象</span></span><br><span class="line">        amplifier-&gt;<span class="built_in">setVolume</span>(<span class="number">5</span>);</span><br><span class="line">        dvdPlayer-&gt;<span class="built_in">on</span>();</span><br><span class="line">        dvdPlayer-&gt;<span class="built_in">play</span>(movie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化操作：结束电影</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">endMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nShutting down movie theater...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        dvdPlayer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">        dvdPlayer-&gt;<span class="built_in">off</span>();</span><br><span class="line">        amplifier-&gt;<span class="built_in">off</span>();</span><br><span class="line">        projector-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     // 创建子系统组件</span></span><br><span class="line"><span class="comment">//     auto projector = std:: make_unique &lt;Projector&gt;();</span></span><br><span class="line"><span class="comment">//     auto amplifier = std:: make_unique &lt;Amplifier&gt;();</span></span><br><span class="line"><span class="comment">//     auto dvdPlayer = std:: make_unique &lt;DvdPlayer&gt;();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 创建门面</span></span><br><span class="line"><span class="comment">//     HomeTheaterFacade homeTheater(std:: move(projector), std:: move(amplifier), std:: move(dvdPlayer));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     homeTheater.watchMovie(&quot;Inception&quot;);</span></span><br><span class="line"><span class="comment">//     homeTheater.endMovie();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="36-享元模式-flyweight-pattern"><a class="markdownIt-Anchor" href="#36-享元模式-flyweight-pattern"></a> 3.6. 享元模式 (Flyweight Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 运用共享技术有效地支持大量细粒度的对象。</p>
</li>
<li>
<p><strong>核心思想：</strong> 共享不可变状态（内部状态），外部状态由客户端提供。将对象的状态分为内部状态（不变的，可共享）和外部状态（变化的，不可共享）。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Flyweight (抽象享元)：</strong> 定义一个接口，通过这个接口享元可以接受并作用于外部状态。</li>
<li><strong>Concrete Flyweight (具体享元)：</strong> 实现享元接口，并存储内部状态。</li>
<li><strong>Unshared Concrete Flyweight (非共享具体享元)：</strong> 可选，表示那些不适合共享的对象。</li>
<li><strong>Flyweight Factory (享元工厂)：</strong> 负责创建和管理享元对象，确保共享。</li>
<li><strong>Client (客户端)：</strong> 维护对享元对象的引用，并计算或存储它们的外部状态。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>减少内存消耗，尤其是当有大量相似对象时。</li>
<li>提高系统性能。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了系统复杂性，需要区分内部状态和外部状态。</li>
<li>线程安全问题：享元工厂可能需要在多线程环境下进行同步。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个应用中使用了大量的对象，并且这些对象中的大部分状态可以外部化。</li>
<li>当对象的大部分属性可以变为外部状态，从而使少数共享的享元对象可以取代大量对象时。</li>
<li>如字符编辑器中的字符对象（字符本身是内部状态，位置是外部状态）。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象享元：字符接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>= <span class="number">0</span>; <span class="comment">// x, y 是外部状态</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Character</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元：具体字符 (内部状态：字符代码，字体)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCharacter</span> : <span class="keyword">public</span> Character &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> charCode;</span><br><span class="line">    std::string font; <span class="comment">// 字体也是内部状态，假设固定</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCharacter</span>(<span class="type">char</span> code, <span class="type">const</span> std::string&amp; font) : <span class="built_in">charCode</span>(code), <span class="built_in">font</span>(font) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Creating ConcreteCharacter: &quot;</span> &lt;&lt; charCode &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; font &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying char &#x27;&quot;</span> &lt;&lt; charCode &lt;&lt; <span class="string">&quot;&#x27; with font &#x27;&quot;</span> &lt;&lt; font</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&#x27; at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;<span class="type">char</span>, std::shared_ptr&lt;Character&gt;&gt; characters; <span class="comment">// 存储享元对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Character&gt; <span class="title">getCharacter</span><span class="params">(<span class="type">char</span> key, <span class="type">const</span> std::string&amp; font)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (characters.<span class="built_in">find</span>(key) == characters.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            characters[key] = std::<span class="built_in">make_shared</span>&lt;ConcreteCharacter&gt;(key, font);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> characters[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CharacterFactory</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CharacterFactory destroyed. Total characters created: &quot;</span> &lt;&lt; characters.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     CharacterFactory factory;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 模拟在屏幕上显示一些字符</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;H&#x27;, &quot;Arial&quot;)-&gt; display(10, 10);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;e&#x27;, &quot;Arial&quot;)-&gt; display(20, 10);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;l&#x27;, &quot;Arial&quot;)-&gt; display(30, 10);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;l&#x27;, &quot;Arial&quot;)-&gt; display(40, 10);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;o&#x27;, &quot;Arial&quot;)-&gt; display(50, 10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;W&#x27;, &quot;Calibri&quot;)-&gt; display(10, 30);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;o&#x27;, &quot;Calibri&quot;)-&gt; display(20, 30);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;r&#x27;, &quot;Calibri&quot;)-&gt; display(30, 30);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;l&#x27;, &quot;Calibri&quot;)-&gt; display(40, 30);</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;d&#x27;, &quot;Calibri&quot;)-&gt; display(50, 30);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;H&#x27;, &quot;Arial&quot;)-&gt; display(10, 50); // &#x27;H&#x27; (Arial) 再次被请求，但不会再次创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 即使我们显示了 11 个字符，但实际上只创建了 5 (Arial) + 5 (Calibri) = 10 个不同的享元对象</span></span><br><span class="line"><span class="comment">//     // (如果字体固定为 Arial，则只创建了&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;W&#x27;,&#x27;r&#x27;,&#x27;d&#x27; 7 个字符对象)</span></span><br><span class="line"><span class="comment">//     // 这里为了简化，假设每个字符只存在一种字体</span></span><br><span class="line"><span class="comment">//     // 更严谨的享元是 (字符, 字体) 作为 key</span></span><br><span class="line"><span class="comment">//     // 上面示例中，由于每次 getCharacter 都传了 font，实际上每次都会检查 key+&#x27;font&#x27;的组合</span></span><br><span class="line"><span class="comment">//     // 假设我们固定 font，或者将 font 也作为 key 的一部分，才能更好地体现享元</span></span><br><span class="line"><span class="comment">//     // 为简化理解，这里只共享 charCode</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Re-requesting &#x27;l&#x27; (Arial) ---\n&quot;;</span></span><br><span class="line"><span class="comment">//     factory.getCharacter(&#x27;l&#x27;, &quot;Arial&quot;)-&gt; display(60, 10); // 应该不会再输出创建信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="37-代理模式-proxy-pattern"><a class="markdownIt-Anchor" href="#37-代理模式-proxy-pattern"></a> 3.7. 代理模式 (Proxy Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 为另一个对象提供一个替身或占位符，以控制对这个对象的访问。</p>
</li>
<li>
<p><strong>核心思想：</strong> 代理对象与真实对象实现相同的接口，并包含对真实对象的引用，在客户端访问真实对象前/后执行额外逻辑。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Subject (抽象主题)：</strong> 定义真实对象和代理对象的共同接口。</li>
<li><strong>Real Subject (真实主题)：</strong> 实际执行业务逻辑的对象。</li>
<li><strong>Proxy (代理)：</strong> 实现 <code>Subject</code> 接口，包含对 <code>Real Subject</code> 的引用，并控制对真实对象的访问。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>隐藏真实对象的复杂性。</li>
<li>控制对真实对象的访问（如权限验证、延迟加载、缓存）。</li>
<li>可以在不修改真实对象的情况下，增加额外的功能（如日志、性能监控）。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加系统复杂性（多了一个代理层）。</li>
<li>在某些情况下可能引入性能开销。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li><strong>远程代理：</strong> 为远程对象提供本地代理。</li>
<li><strong>虚拟代理：</strong> 延迟创建开销大的对象（如图片加载）。</li>
<li><strong>保护代理：</strong> 控制对对象的访问权限。</li>
<li><strong>缓存代理：</strong> 对结果进行缓存。</li>
<li><strong>智能引用：</strong> 在访问对象时执行额外操作（如引用计数）。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// For std::this_thread:: sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span> <span class="comment">// For std::chrono:: seconds</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题 (Subject)：图像加载接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Image</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题 (Real Subject)：实际图像类（加载开销大）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImage</span> : <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string filename;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadImageFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot; from disk...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟 I/O 耗时</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealImage</span>(<span class="type">const</span> std::string&amp; filename) : <span class="built_in">filename</span>(filename) &#123;</span><br><span class="line">        <span class="built_in">loadImageFromDisk</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理 (Proxy)：虚拟代理，延迟加载图像</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyImage</span> : <span class="keyword">public</span> Image &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string filename;</span><br><span class="line">    std::unique_ptr&lt;RealImage&gt; realImage; <span class="comment">// 代理持有真实对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProxyImage</span>(<span class="type">const</span> std::string&amp; filename) : <span class="built_in">filename</span>(filename), <span class="built_in">realImage</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Proxy for &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot; created (image not loaded yet).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有在第一次调用 display 时才创建并加载真实图像 (延迟加载)</span></span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            realImage = std::<span class="built_in">make_unique</span>&lt;RealImage&gt;(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage-&gt;<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     // 客户端使用代理对象</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Image&gt; image1 = std:: make_unique &lt;ProxyImage&gt;(&quot;photo1.jpg&quot;);</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Image&gt; image2 = std:: make_unique &lt;ProxyImage&gt;(&quot;photo2.png&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\nFirst call to display image1:&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     image1-&gt; display(); // 此时才会真正加载 photo1.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\nSecond call to display image1:&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     image1-&gt; display(); // 此时不会再次加载，直接显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\nFirst call to display image2:&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     image2-&gt; display(); // 此时才会真正加载 photo2.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="4-行为型设计模式-behavioral-patterns"><a class="markdownIt-Anchor" href="#4-行为型设计模式-behavioral-patterns"></a> 4. 行为型设计模式 (Behavioral Patterns)</h2>
<p>这类模式关注对象间的责任分配和通信机制。</p>
<h3 id="41-模板方法模式-template-method-pattern"><a class="markdownIt-Anchor" href="#41-模板方法模式-template-method-pattern"></a> 4.1. 模板方法模式 (Template Method Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 定义一个算法的骨架，而将一些步骤延迟到子类中去实现。模板方法使子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。</p>
</li>
<li>
<p><strong>核心思想：</strong> <strong>继承</strong>。通过抽象父类定义算法的框架，并用抽象方法或钩子方法让子类来填充具体细节。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Abstract Class (抽象类)：</strong> 定义了模板方法（一个固定算法的骨架），以及抽象操作（由子类实现）和钩子操作（子类可选实现）。</li>
<li><strong>Concrete Class (具体类)：</strong> 实现抽象类中定义的抽象操作，以完成算法的具体步骤。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>代码复用：公共部分在父类实现，避免重复代码。</li>
<li>控制流程：父类控制算法的整体结构，子类只能改变特定步骤。</li>
<li>符合“开闭原则”。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>通过继承实现，父类与子类之间耦合度较高。</li>
<li>如果算法骨架发生变化，需要修改父类，可能影响所有子类。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当你想在多个类中实现一个算法，但这些算法的某些步骤是相同的，而其他步骤是不同的。</li>
<li>当你想控制子类扩展点，确保它们不会改变算法的整体结构。</li>
<li>实现“好莱坞原则”：Don't call us, we'll call you. (父类调用子类的方法)。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类：定义制作饮料的模板方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板方法：定义了制作饮料的固定算法骨架，使用 final 防止子类修改流程 (C++11)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareRecipe</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="built_in">boilWater</span>();</span><br><span class="line">        <span class="built_in">brew</span>();         <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">        <span class="built_in">pourInCup</span>();</span><br><span class="line">        <span class="built_in">addCondiments</span>(); <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">customerWantsHook</span>()) &#123; <span class="comment">// 钩子方法，子类可选重写</span></span><br><span class="line">            <span class="built_in">addLemon</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CaffeineBeverage</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 固定步骤</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Boiling water&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pouring into cup&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法 (Hook Method)：子类可以重写，也可以不重写</span></span><br><span class="line">    <span class="comment">// 默认返回 true，表示通常需要这个步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">customerWantsHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addLemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding Lemon (from hook)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> CaffeineBeverage &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dripping coffee through filter&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding sugar and milk&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Coffee 不需要柠檬，可以重写钩子方法返回 false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">customerWantsHook</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：制作茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> CaffeineBeverage &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Steeping the tea bag&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding lemon&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Making coffee:&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     Coffee coffee;</span></span><br><span class="line"><span class="comment">//     coffee.prepareRecipe(); // 调用模板方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\nMaking tea:&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     Tea tea;</span></span><br><span class="line"><span class="comment">//     tea.prepareRecipe(); // 调用模板方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="42-迭代器模式-iterator-pattern"><a class="markdownIt-Anchor" href="#42-迭代器模式-iterator-pattern"></a> 4.2. 迭代器模式 (Iterator Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>
</li>
<li>
<p><strong>核心思想：</strong> 分离遍历行为和聚合对象。将集合对象的遍历职责委托给一个独立的迭代器对象。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Iterator (抽象迭代器)：</strong> 定义访问和遍历元素的接口。</li>
<li><strong>Concrete Iterator (具体迭代器)：</strong> 实现抽象迭代器接口，负责跟踪当前位置。</li>
<li><strong>Aggregate (抽象聚合)：</strong> 定义一个创建相应迭代器对象的接口。</li>
<li><strong>Concrete Aggregate (具体聚合)：</strong> 实现创建具体迭代器对象的工厂方法，并返回一个具体迭代器实例。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将遍历算法从聚合对象中分离，实现职责分离。</li>
<li>支持多种遍历方式。</li>
<li>在不暴露聚合内部结构的情况下，提供了对元素的访问。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了类的数量。</li>
<li>对于简单的遍历，可能显得过于复杂。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当需要访问一个聚合对象的内容，而又不希望暴露其内部表示时。</li>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要在同一个聚合对象上并行遍历时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例 (C++标准库已广泛使用，这里模拟实现)：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象聚合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> std::unique_ptr&lt;Iterator&lt;T&gt;&gt; <span class="built_in">createIterator</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Aggregate</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> Iterator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::vector&lt;T&gt;&amp; collection;</span><br><span class="line">    <span class="type">size_t</span> position;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteIterator</span>(<span class="type">const</span> std::vector&lt;T&gt;&amp; coll) : <span class="built_in">collection</span>(coll), <span class="built_in">position</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;T&amp;&gt;(collection.<span class="built_in">at</span>(position++)); <span class="comment">// at() 提供边界检查</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; collection.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体聚合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookCollection</span> : <span class="keyword">public</span> Aggregate&lt;std::string&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; books;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addBook</span><span class="params">(<span class="type">const</span> std::string&amp; book)</span> </span>&#123;</span><br><span class="line">        books.<span class="built_in">push_back</span>(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Iterator&lt;std::string&gt;&gt; <span class="built_in">createIterator</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;ConcreteIterator&lt;std::string&gt;&gt;(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     BookCollection myBooks;</span></span><br><span class="line"><span class="comment">//     myBooks.addBook(&quot;Design Patterns&quot;);</span></span><br><span class="line"><span class="comment">//     myBooks.addBook(&quot;Clean Code&quot;);</span></span><br><span class="line"><span class="comment">//     myBooks.addBook(&quot;The Pragmatic Programmer&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;Iterator&lt;std::string&gt; &gt; it = myBooks.createIterator();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Books in collection:&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     while (it-&gt; hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//         std:: cout &lt;&lt; &quot;- &quot; &lt;&lt; it-&gt; next() &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="43-责任链模式-chain-of-responsibility-pattern"><a class="markdownIt-Anchor" href="#43-责任链模式-chain-of-responsibility-pattern"></a> 4.3. 责任链模式 (Chain of Responsibility Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</li>
<li>
<p><strong>核心思想：</strong> 请求沿着链条传递，每个节点都有处理或传递请求的权利。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Handler (抽象处理者)：</strong> 定义一个处理请求的接口，并实现一个设置下一个处理者的可选方法。</li>
<li><strong>Concrete Handler (具体处理者)：</strong> 实现处理请求的方法，如果自己不能处理，则将请求转发给下一个处理者。</li>
<li><strong>Client (客户端)：</strong> 向链中的第一个处理者发送请求。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>降低耦合度：发送者和接收者之间解耦。</li>
<li>增加灵活性：可以动态地修改或重组链。</li>
<li>符合“开闭原则”：增加新的处理者无需修改现有代码。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>不能保证请求一定会被处理。</li>
<li>链过长可能影响性能。</li>
<li>调试困难，请求的路径不确定。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当有多个对象可以处理一个请求，但具体哪个对象处理未知时。</li>
<li>当需要动态地指定处理请求的对象集合时。</li>
<li>如日志记录、审批流程、事件处理、过滤器链。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Handler* nextHandler; <span class="comment">// 指向链中的下一个处理者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Handler</span>() : <span class="built_in">nextHandler</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(Handler* next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nextHandler = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> request)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandlerA</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">0</span> &amp;&amp; request &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler A handled request &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler A passed request &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler A cannot handle request &quot;</span> &lt;&lt; request &lt;&lt; <span class="string">&quot; and no next handler.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandlerB</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">10</span> &amp;&amp; request &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler B handled request &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler B passed request &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler B cannot handle request &quot;</span> &lt;&lt; request &lt;&lt; <span class="string">&quot; and no next handler.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者 C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandlerC</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">int</span> request)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request &gt;= <span class="number">20</span> &amp;&amp; request &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler C handled request &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler C passed request &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler C cannot handle request &quot;</span> &lt;&lt; request &lt;&lt; <span class="string">&quot; and no next handler.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     ConcreteHandlerA handlerA;</span></span><br><span class="line"><span class="comment">//     ConcreteHandlerB handlerB;</span></span><br><span class="line"><span class="comment">//     ConcreteHandlerC handlerC;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     handlerA.setNext(&amp;handlerB);</span></span><br><span class="line"><span class="comment">//     handlerB.setNext(&amp;handlerC);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     handlerA.handleRequest(5);</span></span><br><span class="line"><span class="comment">//     handlerA.handleRequest(15);</span></span><br><span class="line"><span class="comment">//     handlerA.handleRequest(25);</span></span><br><span class="line"><span class="comment">//     handlerA.handleRequest(35); // 没有处理者能处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="44-策略模式-strategy-pattern"><a class="markdownIt-Anchor" href="#44-策略模式-strategy-pattern"></a> 4.4. 策略模式 (Strategy Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将算法封装成独立的策略类，并通过组合的方式在上下文（Context）中切换不同的策略。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Context (上下文)：</strong> 持有对 <code>Strategy</code> 对象的引用，并委托其执行操作。</li>
<li><strong>Strategy (抽象策略)：</strong> 定义所有具体策略的共同接口。</li>
<li><strong>Concrete Strategy (具体策略)：</strong> 实现 <code>Strategy</code> 接口，包含具体的算法实现。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将算法和使用算法的客户端解耦。</li>
<li>易于扩展新的算法，符合“开闭原则”。</li>
<li>避免大量的条件判断语句。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>客户端需要了解所有策略，并自行选择合适的策略。</li>
<li>增加了类的数量。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个对象有多种行为，并且这些行为在运行时可以根据情况改变时。</li>
<li>当需要避免在客户端代码中出现大量的条件语句来选择不同的行为时。</li>
<li>当不同算法的变体仅在行为上有所不同时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象策略 (Strategy)：支付策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PaymentStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略 A：支付宝支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayStrategy</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string userId;</span><br><span class="line">    std::string password;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AlipayStrategy</span>(<span class="type">const</span> std::string&amp; userId, <span class="type">const</span> std::string&amp; password) : <span class="built_in">userId</span>(userId), <span class="built_in">password</span>(password) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paying &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using Alipay (User: &quot;</span> &lt;&lt; userId &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 实际的支付逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略 B：微信支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WechatPayStrategy</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string openId;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WechatPayStrategy</span>(<span class="type">const</span> std::string&amp; openId) : <span class="built_in">openId</span>(openId) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pay</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Paying &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; using WeChat Pay (OpenId: &quot;</span> &lt;&lt; openId &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 实际的支付逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文 (Context)：订单，持有支付策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;PaymentStrategy&gt; paymentStrategy;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Order</span>(<span class="type">double</span> amount) : <span class="built_in">amount</span>(amount), <span class="built_in">paymentStrategy</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPaymentStrategy</span><span class="params">(std::unique_ptr&lt;PaymentStrategy&gt; strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;paymentStrategy = std::<span class="built_in">move</span>(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!paymentStrategy) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No payment strategy set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Order amount: &quot;</span> &lt;&lt; amount &lt;&lt; std::endl;</span><br><span class="line">        paymentStrategy-&gt;<span class="built_in">pay</span>(amount); <span class="comment">// 委托给具体策略执行支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     Order order1(150.0);</span></span><br><span class="line"><span class="comment">//     order1.setPaymentStrategy(std:: make_unique &lt;AlipayStrategy&gt;(&quot;user123&quot;, &quot;pass&quot;));</span></span><br><span class="line"><span class="comment">//     order1.checkout();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;---&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Order order2(29.99);</span></span><br><span class="line"><span class="comment">//     order2.setPaymentStrategy(std:: make_unique &lt;WechatPayStrategy&gt;(&quot;wx_open_id_xyz&quot;));</span></span><br><span class="line"><span class="comment">//     order2.checkout();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="45-状态模式-state-pattern"><a class="markdownIt-Anchor" href="#45-状态模式-state-pattern"></a> 4.5. 状态模式 (State Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将对象的行为封装在不同的状态类中，并让对象在运行时切换其内部状态对象，从而改变行为。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Context (上下文)：</strong> 维护一个 <code>Concrete State</code> 子类的实例，这个实例定义了当前的状态。</li>
<li><strong>State (抽象状态)：</strong> 定义一个接口，封装了与 <code>Context</code> 的一个特定状态相关的行为。</li>
<li><strong>Concrete State (具体状态)：</strong> 实现 <code>State</code> 接口，执行与 <code>Context</code> 特定状态相关的行为。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将特定状态的行为局部化到一个类中，使得代码更清晰、更易于维护。</li>
<li>消除大量的条件语句。</li>
<li>将状态转换逻辑封装在状态类中，便于扩展新的状态。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了类的数量，对于简单的状态机可能过于复杂。</li>
<li>状态转换逻辑分散在不同的状态类中，可能难以一览无余。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个对象的行为取决于它的状态，并且它在运行时可能改变它的行为时。</li>
<li>当一个操作中含有庞大的条件语句，这些条件语句依赖于对象的状态时。</li>
<li>如订单状态流转、电梯状态、TCP 连接状态、游戏角色状态。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明 Context</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insertMoney</span><span class="params">(VendingMachine* machine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">selectProduct</span><span class="params">(VendingMachine* machine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">(VendingMachine* machine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文：自动售货机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;State&gt; currentState;</span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>(); <span class="comment">// 构造函数中初始化初始状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::unique_ptr&lt;State&gt; newState)</span> </span>&#123;</span><br><span class="line">        currentState = std::<span class="built_in">move</span>(newState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">        currentState-&gt;<span class="built_in">insertMoney</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">selectProduct</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= <span class="number">10.0</span>) &#123; <span class="comment">// 假设产品价格为 10</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Dispensing product. Please take your change: &quot;</span> &lt;&lt; (balance - <span class="number">10.0</span>) &lt;&lt; std::endl;</span><br><span class="line">            balance = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Insufficient funds to dispense product.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        currentState-&gt;<span class="built_in">dispenseProduct</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        balance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态：无钱状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoMoneyState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertMoney</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Money inserted. Current balance: &quot;</span> &lt;&lt; machine-&gt;<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line">        machine-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_unique</span>&lt;<span class="keyword">class</span> HasMoneyState&gt;()); <span class="comment">// 状态切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Please insert money first.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cannot dispense. No money inserted.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态：有钱状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasMoneyState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertMoney</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Already has money. Current balance: &quot;</span> &lt;&lt; machine-&gt;<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Product selected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        machine-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_unique</span>&lt;<span class="keyword">class</span> ProductSelectedState&gt;()); <span class="comment">// 状态切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Please select a product first.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态：产品已选择状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductSelectedState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertMoney</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Product already selected. Current balance: &quot;</span> &lt;&lt; machine-&gt;<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Product already selected.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        machine-&gt;<span class="built_in">dispenseProduct</span>(); <span class="comment">// 实际执行出货逻辑</span></span><br><span class="line">        machine-&gt;<span class="built_in">setState</span>(std::<span class="built_in">make_unique</span>&lt;NoMoneyState&gt;()); <span class="comment">// 状态切换回无钱状态</span></span><br><span class="line">        machine-&gt;<span class="built_in">resetBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VendingMachine 构造函数的实现，需要在使用状态类之后定义</span></span><br><span class="line">VendingMachine::<span class="built_in">VendingMachine</span>() : <span class="built_in">balance</span>(<span class="number">0.0</span>) &#123;</span><br><span class="line">    currentState = std::<span class="built_in">make_unique</span>&lt;NoMoneyState&gt;(); <span class="comment">// 初始状态</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vending machine initialized. Current balance: &quot;</span> &lt;&lt; balance &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     VendingMachine machine;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     machine.selectProduct();    // 无钱，无法选择</span></span><br><span class="line"><span class="comment">//     machine.insertMoney(5.0);   // 插入 5 元</span></span><br><span class="line"><span class="comment">//     machine.insertMoney(3.0);   // 插入 3 元</span></span><br><span class="line"><span class="comment">//     machine.selectProduct();    // 选择产品</span></span><br><span class="line"><span class="comment">//     machine.dispenseProduct();  // 余额不足，无法出货</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Adding more money ---\n&quot;;</span></span><br><span class="line"><span class="comment">//     machine.insertMoney(10.0);  // 插入 10 元</span></span><br><span class="line"><span class="comment">//     machine.selectProduct();    // 选择产品</span></span><br><span class="line"><span class="comment">//     machine.dispenseProduct();  // 出货，回到无钱状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Try again after dispense ---\n&quot;;</span></span><br><span class="line"><span class="comment">//     machine.selectProduct();    // 此时应再次提示无钱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="46-备忘录模式-memento-pattern"><a class="markdownIt-Anchor" href="#46-备忘录模式-memento-pattern"></a> 4.6. 备忘录模式 (Memento Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将对象的内部状态封装到 Memento 对象中，并通过 Caretaker 对象管理这些 Memento，Originator 负责创建和恢复状态。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Originator (发起人)：</strong> 创建一个备忘录，用以记录当前时刻的内部状态，并可以使用备忘录恢复内部状态。</li>
<li><strong>Memento (备忘录)：</strong> 存储发起人对象的内部状态。</li>
<li><strong>Caretaker (负责人)：</strong> 负责保存好备忘录，不能对备忘录的内容进行操作或检查。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>在不破坏封装性的前提下，提供了恢复对象状态的能力。</li>
<li>简化了发起人：发起人无需管理和存储其所有历史状态。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>如果状态数据量大，可能会消耗大量内存。</li>
<li>如果状态经常改变，创建和存储备忘录的开销会很大。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当需要保存一个对象在某个时刻的完整状态，以便在以后某个时刻恢复时。</li>
<li>当需要提供撤销/重做功能时。</li>
<li>如文本编辑器中的撤销/重做、游戏存档、数据库事务回滚。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录 (Memento)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditorMemento</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EditorMemento</span>(<span class="type">const</span> std::string&amp; content) : <span class="built_in">content</span>(content) &#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getSavedContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起人 (Originator)：文本编辑器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">type</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123;</span><br><span class="line">        content += text;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current editor content: &quot;</span> &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录，保存当前状态</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;EditorMemento&gt; <span class="title">save</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Saving editor state...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;EditorMemento&gt;(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从备忘录中恢复状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">const</span> EditorMemento&amp; memento)</span> </span>&#123;</span><br><span class="line">        content = memento.<span class="built_in">getSavedContent</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Restored editor content: &quot;</span> &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责人 (Caretaker)：历史管理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EditorMemento&gt;&gt; mementos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMemento</span><span class="params">(std::unique_ptr&lt;EditorMemento&gt; memento)</span> </span>&#123;</span><br><span class="line">        mementos.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(memento));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;EditorMemento&gt; <span class="title">getMemento</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; mementos.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">move</span>(mementos[index]); <span class="comment">// 返回并移除，或返回副本</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;EditorMemento&gt; <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mementos.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::unique_ptr&lt;EditorMemento&gt; lastState = std::<span class="built_in">move</span>(mementos.<span class="built_in">back</span>());</span><br><span class="line">            mementos.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> lastState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     Editor editor;</span></span><br><span class="line"><span class="comment">//     History history;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     editor.type(&quot;Hello &quot;);</span></span><br><span class="line"><span class="comment">//     history.addMemento(editor.save()); // 保存点 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     editor.type(&quot;World!&quot;);</span></span><br><span class="line"><span class="comment">//     history.addMemento(editor.save()); // 保存点 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     editor.type(&quot; How are you?&quot;);</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;Current: &quot; &lt;&lt; editor.getSavedContent() &lt;&lt; std:: endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 撤销一步</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Undo ---\n&quot;;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;EditorMemento&gt; memento1 = history.undo();</span></span><br><span class="line"><span class="comment">//     if (memento1) &#123;</span></span><br><span class="line"><span class="comment">//         editor.restore(*memento1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 再撤销一步</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Undo again ---\n&quot;;</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;EditorMemento&gt; memento0 = history.undo();</span></span><br><span class="line"><span class="comment">//     if (memento0) &#123;</span></span><br><span class="line"><span class="comment">//         editor.restore(*memento0);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="47-中介者模式-mediator-pattern"><a class="markdownIt-Anchor" href="#47-中介者模式-mediator-pattern"></a> 4.7. 中介者模式 (Mediator Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将网状的复杂交互转化为星型的集中交互。对象之间不再直接通信，而是通过中介者进行通信。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Mediator (抽象中介者)：</strong> 定义中介者和同事对象之间通信的接口。</li>
<li><strong>Concrete Mediator (具体中介者)：</strong> 实现抽象中介者接口，维护所有同事的引用，并协调它们之间的交互。</li>
<li><strong>Colleague (抽象同事)：</strong> 定义与中介者通信的接口。</li>
<li><strong>Concrete Colleague (具体同事)：</strong> 实现抽象同事接口，在需要与其他同事交互时，通过中介者进行。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>减少了对象之间的耦合：同事之间不再直接依赖。</li>
<li>简化了对象交互：将复杂的多对多交互转换为一对多（中介者到同事）。</li>
<li>集中控制：将复杂的控制逻辑集中在中介者中。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>中介者可能变得过于复杂，成为“上帝对象”。</li>
<li>增加了系统的复杂性。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一组对象以复杂但定义良好地方式进行交互时。</li>
<li>当对象之间的交互依赖于对象的内部状态变化，而需要集中管理这些交互时。</li>
<li>如 GUI 组件交互、航空交通管制系统、聊天室。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明 Mediator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chatroom</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象同事 (User)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Chatroom* mediator;</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(Chatroom* med, <span class="type">const</span> std::string&amp; name) : <span class="built_in">mediator</span>(med), <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">User</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatUser</span> : <span class="keyword">public</span> User &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChatUser</span>(Chatroom* med, <span class="type">const</span> std::string&amp; name) : <span class="built_in">User</span>(med, name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// 定义在 Chatroom 之后</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; receives]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者 (Chatroom)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chatroom</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, User* sender)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addUser</span><span class="params">(User* user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Chatroom</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteChatroom</span> : <span class="keyword">public</span> Chatroom &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;User*&gt; users; <span class="comment">// 存储所有注册的用户</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUser</span><span class="params">(User* user)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        users.<span class="built_in">push_back</span>(user);</span><br><span class="line">        std::cout &lt;&lt; user-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; joined the chatroom.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, User* sender)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[From &quot;</span> &lt;&lt; sender-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (User* user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user != sender) &#123; <span class="comment">// 除了发送者，其他人都会收到消息</span></span><br><span class="line">                user-&gt;<span class="built_in">receive</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事 A 的 send 方法实现，依赖于 Chatroom</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatUser::send</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; sends]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    mediator-&gt;<span class="built_in">sendMessage</span>(message, <span class="built_in">const_cast</span>&lt;ChatUser*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     ConcreteChatroom chatroom;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     ChatUser john(&amp;chatroom, &quot;John&quot;);</span></span><br><span class="line"><span class="comment">//     ChatUser jane(&amp;chatroom, &quot;Jane&quot;);</span></span><br><span class="line"><span class="comment">//     ChatUser mike(&amp;chatroom, &quot;Mike&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     chatroom.addUser(&amp;john);</span></span><br><span class="line"><span class="comment">//     chatroom.addUser(&amp;jane);</span></span><br><span class="line"><span class="comment">//     chatroom.addUser(&amp;mike);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     john.send(&quot;Hi everyone!&quot;);</span></span><br><span class="line"><span class="comment">//     jane.send(&quot;Hello John!&quot;);</span></span><br><span class="line"><span class="comment">//     mike.send(&quot;What&#x27;s up?&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="48-命令模式-command-pattern"><a class="markdownIt-Anchor" href="#48-命令模式-command-pattern"></a> 4.8. 命令模式 (Command Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将一个操作封装成一个对象。这个对象包含了执行操作所需的所有信息（接收者、动作、参数）。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Command (抽象命令)：</strong> 声明执行操作的接口。</li>
<li><strong>Concrete Command (具体命令)：</strong> 实现抽象命令接口，绑定一个接收者对象和一组动作。</li>
<li><strong>Receiver (接收者)：</strong> 知道如何执行与请求相关的操作。</li>
<li><strong>Invoker (请求者)：</strong> 持有对命令对象的引用，在某个时刻调用命令的执行方法。</li>
<li><strong>Client (客户端)：</strong> 创建具体命令对象，并设置其接收者。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将请求的发送者和接收者解耦。</li>
<li>支持撤销/重做操作。</li>
<li>支持命令队列和日志记录。</li>
<li>可以组合命令（宏命令）。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了类的数量。</li>
<li>命令的粒度如果过细，会导致系统过于复杂。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当需要将操作参数化时（如菜单系统）。</li>
<li>当需要支持撤销/重做功能时。</li>
<li>当需要将请求排队或延迟执行时。</li>
<li>当需要对操作进行日志记录或事务处理时。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// For std:: unique_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者 (Receiver)：灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Light is ON&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Light is OFF&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 支持撤销</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令：开灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOnCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light* light; <span class="comment">// 接收者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LightOnCommand</span>(Light* light) : <span class="built_in">light</span>(light) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">turnOn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">turnOff</span>(); <span class="comment">// 撤销开灯就是关灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令：关灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOffCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light* light; <span class="comment">// 接收者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LightOffCommand</span>(Light* light) : <span class="built_in">light</span>(light) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">turnOff</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">turnOn</span>(); <span class="comment">// 撤销关灯就是开灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求者 (Invoker)：遥控器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Command&gt; onCommand;</span><br><span class="line">    std::unique_ptr&lt;Command&gt; offCommand;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Command&gt;&gt; history; <span class="comment">// 用于撤销</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCommands</span><span class="params">(std::unique_ptr&lt;Command&gt; onCmd, std::unique_ptr&lt;Command&gt; offCmd)</span> </span>&#123;</span><br><span class="line">        onCommand = std::<span class="built_in">move</span>(onCmd);</span><br><span class="line">        offCommand = std::<span class="built_in">move</span>(offCmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pressOnButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (onCommand) &#123;</span><br><span class="line">            onCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">            history.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(onCommand)); <span class="comment">// 记录命令以便撤销</span></span><br><span class="line">            <span class="comment">// 需要重新创建命令对象，因为 unique_ptr 所有权已转移</span></span><br><span class="line">            <span class="comment">// 在实际系统中，这通常意味着命令是可重用的或者工厂创建的</span></span><br><span class="line">            <span class="comment">// 为了简化示例，这里不处理重复创建问题，只演示基本逻辑</span></span><br><span class="line">            <span class="comment">// 真实场景可能用 shared_ptr 或者命令是无状态的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pressOffButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (offCommand) &#123;</span><br><span class="line">            offCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">            history.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(offCommand)); <span class="comment">// 记录命令以便撤销</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pressUndoButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!history.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::unique_ptr&lt;Command&gt; lastCommand = std::<span class="built_in">move</span>(history.<span class="built_in">back</span>());</span><br><span class="line">            history.<span class="built_in">pop_back</span>();</span><br><span class="line">            lastCommand-&gt;<span class="built_in">undo</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Nothing to undo.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     Light livingRoomLight;</span></span><br><span class="line"><span class="comment">//     RemoteControl remote;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 创建命令并设置给遥控器</span></span><br><span class="line"><span class="comment">//     remote.setCommands(</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;LightOnCommand&gt;(&amp;livingRoomLight),</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;LightOffCommand&gt;(&amp;livingRoomLight)</span></span><br><span class="line"><span class="comment">//     );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 执行操作</span></span><br><span class="line"><span class="comment">//     remote.pressOnButton();</span></span><br><span class="line"><span class="comment">//     remote.pressOffButton();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 撤销操作</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Undo Actions ---&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     remote.pressUndoButton(); // 撤销关灯 -&gt; 开灯</span></span><br><span class="line"><span class="comment">//     remote.pressUndoButton(); // 撤销开灯 -&gt; 关灯</span></span><br><span class="line"><span class="comment">//     remote.pressUndoButton(); // 没有更多可撤销的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="49-访问者模式-visitor-pattern"><a class="markdownIt-Anchor" href="#49-访问者模式-visitor-pattern"></a> 4.9. 访问者模式 (Visitor Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</li>
<li>
<p><strong>核心思想：</strong> 双重分派 (Double Dispatch)。将操作（访问者）从被操作的对象（元素）中分离出来。当对象结构稳定但需要增加新操作时使用。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Visitor (抽象访问者)：</strong> 为对象结构中的每一个 <code>Concrete Element</code> 声明一个 <code>Visit</code> 操作。</li>
<li><strong>Concrete Visitor (具体访问者)：</strong> 实现抽象访问者声明的每个 <code>Visit</code> 操作。</li>
<li><strong>Element (抽象元素)：</strong> 定义一个 <code>accept</code> 操作，它以一个抽象访问者为参数。</li>
<li><strong>Concrete Element (具体元素)：</strong> 实现 <code>accept</code> 操作，通常调用访问者的 <code>Visit</code> 方法，并传入自身。</li>
<li><strong>Object Structure (对象结构)：</strong> 存储元素集合，可以遍历它们并让它们接受访问者。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>将数据结构和操作分离，符合“单一职责原则”。</li>
<li>增加新的操作（新的访问者）非常容易，无需修改元素类，符合“开闭原则”。</li>
<li>访问者可以累积状态，在访问过程中收集信息。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>增加新的元素类型很困难，需要修改所有访问者接口和实现。</li>
<li>访问者可能破坏元素的封装性，因为它通常需要访问元素的内部状态。</li>
<li>实现复杂，理解难度大。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个对象结构包含许多不同类型的对象，而且你希望对这些对象执行依赖于其具体类型的操作时。</li>
<li>当需要对一个对象结构进行许多不相关的操作，并且不希望这些操作污染元素类时。</li>
<li>当对象结构比较稳定，但需要频繁增加新的操作时。</li>
<li>如编译器（对 AST 进行各种操作）、XML 解析器。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeVisitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Circle&amp; circle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Square&amp; square)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Triangle&amp; triangle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapeVisitor</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 A：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>); <span class="comment">// 双重分派的关键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 B：正方形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> side;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">double</span> s) : <span class="built_in">side</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getSide</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> side; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>); <span class="comment">// 双重分派的关键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素 C：三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> base;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">double</span> b, <span class="type">double</span> h) : <span class="built_in">base</span>(b), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBase</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> base; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> height; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>); <span class="comment">// 双重分派的关键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者 A：计算面积</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> : <span class="keyword">public</span> ShapeVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Circle&amp; circle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calculating area for Circle: &quot;</span> &lt;&lt; <span class="number">3.14159</span> * circle.<span class="built_in">getRadius</span>() * circle.<span class="built_in">getRadius</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Square&amp; square)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calculating area for Square: &quot;</span> &lt;&lt; square.<span class="built_in">getSide</span>() * square.<span class="built_in">getSide</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Triangle&amp; triangle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calculating area for Triangle: &quot;</span> &lt;&lt; <span class="number">0.5</span> * triangle.<span class="built_in">getBase</span>() * triangle.<span class="built_in">getHeight</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者 B：绘制形状 (假设有图形库)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingVisitor</span> : <span class="keyword">public</span> ShapeVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Circle&amp; circle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Circle with radius &quot;</span> &lt;&lt; circle.<span class="built_in">getRadius</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Square&amp; square)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Square with side &quot;</span> &lt;&lt; square.<span class="built_in">getSide</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Triangle&amp; triangle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing Triangle with base &quot;</span> &lt;&lt; triangle.<span class="built_in">getBase</span>() &lt;&lt; <span class="string">&quot; and height &quot;</span> &lt;&lt; triangle.<span class="built_in">getHeight</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addShape</span><span class="params">(std::unique_ptr&lt;Shape&gt; shape)</span> </span>&#123;</span><br><span class="line">        shapes.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(shape));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyVisitor</span><span class="params">(ShapeVisitor&amp; visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; shape : shapes) &#123;</span><br><span class="line">            shape-&gt;<span class="built_in">accept</span>(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     Drawing myDrawing;</span></span><br><span class="line"><span class="comment">//     myDrawing.addShape(std:: make_unique &lt;Circle&gt;(5.0));</span></span><br><span class="line"><span class="comment">//     myDrawing.addShape(std:: make_unique &lt;Square&gt;(4.0));</span></span><br><span class="line"><span class="comment">//     myDrawing.addShape(std:: make_unique &lt;Triangle&gt;(6.0, 8.0));</span></span><br><span class="line"><span class="comment">//     myDrawing.addShape(std:: make_unique &lt;Circle&gt;(2.5));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     AreaCalculator areaCalc;</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;--- Calculating Areas ---&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     myDrawing.applyVisitor(areaCalc);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     DrawingVisitor drawer;</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;\n--- Drawing Shapes ---&quot; &lt;&lt; std:: endl;</span></span><br><span class="line"><span class="comment">//     myDrawing.applyVisitor(drawer);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="410-观察者模式-observer-pattern"><a class="markdownIt-Anchor" href="#410-观察者模式-observer-pattern"></a> 4.10. 观察者模式 (Observer Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 定义对象之间的一种一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</li>
<li>
<p><strong>核心思想：</strong> 发布-订阅机制。主题（Subject）维护一组观察者（Observer），当状态改变时通知它们。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Subject (主题/可观察者)：</strong> 维护一个观察者列表，提供添加/删除观察者和通知观察者的方法。</li>
<li><strong>Observer (观察者)：</strong> 定义一个更新接口，供主题在状态改变时调用。</li>
<li><strong>Concrete Subject (具体主题)：</strong> 存储状态，当状态改变时通知观察者。</li>
<li><strong>Concrete Observer (具体观察者)：</strong> 实现 <code>Observer</code> 接口，接收通知并执行相应操作。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>解耦：主题和观察者之间松散耦合，可以独立变化。</li>
<li>可扩展性：易于增加新的观察者，无需修改主题代码。</li>
<li>支持广播通信。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>如果观察者过多，通知可能成为性能瓶颈。</li>
<li>观察者对主题的改变顺序可能不确定。</li>
<li>如果观察者和主题之间形成循环依赖，可能导致内存泄漏（特别是使用原始指针时）。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个对象的改变需要通知其他对象，而又不知道有多少个或哪些对象需要通知时。</li>
<li>当一个系统需要动态地添加或删除观察者时。</li>
<li>GUI 事件处理、消息队列、RSS 订阅、新闻通知等。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// For std:: remove</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>; <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>; <span class="comment">// 移除观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题：天气数据发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    std::string weatherUpdate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWeather</span><span class="params">(<span class="type">const</span> std::string&amp; newWeather)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weatherUpdate = newWeather;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nWeather station: New weather update: &quot;</span> &lt;&lt; newWeather &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">notifyObservers</span>(); <span class="comment">// 状态改变时通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Observer attached.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer), observers.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Observer detached.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(weatherUpdate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者 A：手机应用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneDisplay</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Phone Display: Current weather is &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者 B：网站显示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebsiteDisplay</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Website Display: Weather updated to &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     WeatherStation station;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     PhoneDisplay phone;</span></span><br><span class="line"><span class="comment">//     WebsiteDisplay website;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     station.attach(&amp;phone);</span></span><br><span class="line"><span class="comment">//     station.attach(&amp;website);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     station.setWeather(&quot;Sunny, 25°C&quot;);</span></span><br><span class="line"><span class="comment">//     station.setWeather(&quot;Rainy, 18°C&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     station.detach(&amp;phone); // 手机应用不再接收通知</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     station.setWeather(&quot;Cloudy, 20°C&quot;); // 只有网站会收到更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="411-解释器模式-interpreter-pattern"><a class="markdownIt-Anchor" href="#411-解释器模式-interpreter-pattern"></a> 4.11. 解释器模式 (Interpreter Pattern)</h3>
<ul>
<li>
<p><strong>意图：</strong> 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</li>
<li>
<p><strong>核心思想：</strong> 将语言的文法规则映射到类结构上，并通过递归调用来解释句子。每个文法规则对应一个表达式类。</p>
</li>
<li>
<p><strong>结构：</strong></p>
<ul>
<li><strong>Abstract Expression (抽象表达式)：</strong> 声明一个解释操作的抽象接口。</li>
<li><strong>Terminal Expression (终结符表达式)：</strong> 实现与文法中的终结符相关的解释操作。</li>
<li><strong>Nonterminal Expression (非终结符表达式)：</strong> 为文法中的非终结符实现解释操作，通常包含其他表达式的引用。</li>
<li><strong>Context (上下文)：</strong> 包含解释器之外的一些全局信息。</li>
<li><strong>Client (客户端)：</strong> 构建抽象语法树，并调用解释操作。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>易于扩展新的解释方法。</li>
<li>将语法规则表示为类层次结构，易于理解和维护。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>对于复杂的文法，类的数量可能变得非常庞大。</li>
<li>效率可能较低。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个问题可以使用语言来表达，并且语言的文法简单而稳定时。</li>
<li>当需要解释某种特定领域的 DSL（领域特定语言）时。</li>
<li>如编译器、正则表达式解析器、SQL 解析器、规则引擎。</li>
</ul>
</li>
<li>
<p><strong>C++ 示例 (非常简化，仅演示基本结构，一个简单的算术表达式)：</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Context (上下文)：存储变量及其值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; variables;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span> std::string&amp; var, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        variables[var] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> std::string&amp; var)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> variables.<span class="built_in">at</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractExpression</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式：数字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> : <span class="keyword">public</span> AbstractExpression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberExpression</span>(<span class="type">int</span> num) : <span class="built_in">number</span>(num) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式：变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableExpression</span> : <span class="keyword">public</span> AbstractExpression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VariableExpression</span>(<span class="type">const</span> std::string&amp; varName) : <span class="built_in">name</span>(varName) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.<span class="built_in">lookup</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：加法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> : <span class="keyword">public</span> AbstractExpression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;AbstractExpression&gt; left;</span><br><span class="line">    std::unique_ptr&lt;AbstractExpression&gt; right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(std::unique_ptr&lt;AbstractExpression&gt; l, std::unique_ptr&lt;AbstractExpression&gt; r)</span><br><span class="line">        : <span class="built_in">left</span>(std::<span class="built_in">move</span>(l)), <span class="built_in">right</span>(std::<span class="built_in">move</span>(r)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>(context) + right-&gt;<span class="built_in">interpret</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：减法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractExpression</span> : <span class="keyword">public</span> AbstractExpression &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;AbstractExpression&gt; left;</span><br><span class="line">    std::unique_ptr&lt;AbstractExpression&gt; right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubtractExpression</span>(std::unique_ptr&lt;AbstractExpression&gt; l, std::unique_ptr&lt;AbstractExpression&gt; r)</span><br><span class="line">        : <span class="built_in">left</span>(std::<span class="built_in">move</span>(l)), <span class="built_in">right</span>(std::<span class="built_in">move</span>(r)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">(<span class="type">const</span> Context&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>(context) - right-&gt;<span class="built_in">interpret</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端构建抽象语法树并解释</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     // 定义上下文，赋值变量</span></span><br><span class="line"><span class="comment">//     Context context;</span></span><br><span class="line"><span class="comment">//     context.assign(&quot;a&quot;, 10);</span></span><br><span class="line"><span class="comment">//     context.assign(&quot;b&quot;, 5);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 构建表达式树： (a + 2) - b</span></span><br><span class="line"><span class="comment">//     // (a + 2)</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;AbstractExpression&gt; expr1 = std:: make_unique &lt;AddExpression&gt;(</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;VariableExpression&gt;(&quot;a&quot;),</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;NumberExpression&gt;(2)</span></span><br><span class="line"><span class="comment">//     );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // ((a + 2) - b)</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;AbstractExpression&gt; finalExpression = std:: make_unique &lt;SubtractExpression&gt;(</span></span><br><span class="line"><span class="comment">//         std:: move(expr1),</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;VariableExpression&gt;(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">//     );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     int result = finalExpression-&gt; interpret(context);</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;(a + 2) - b = &quot; &lt;&lt; result &lt;&lt; std:: endl; // (10 + 2) - 5 = 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 另一个例子: (5 - b) + a</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;AbstractExpression&gt; expr2 = std:: make_unique &lt;SubtractExpression&gt;(</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;NumberExpression&gt;(5),</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;VariableExpression&gt;(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">//     );</span></span><br><span class="line"><span class="comment">//     std:: unique_ptr &lt;AbstractExpression&gt; finalExpression2 = std:: make_unique &lt;AddExpression&gt;(</span></span><br><span class="line"><span class="comment">//         std:: move(expr2),</span></span><br><span class="line"><span class="comment">//         std:: make_unique &lt;VariableExpression&gt;(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">//     );</span></span><br><span class="line"><span class="comment">//     int result2 = finalExpression2-&gt; interpret(context);</span></span><br><span class="line"><span class="comment">//     std:: cout &lt;&lt; &quot;(5 - b) + a = &quot; &lt;&lt; result2 &lt;&lt; std:: endl; // (5 - 5) + 10 = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="5-设计原则"><a class="markdownIt-Anchor" href="#5-设计原则"></a> 5. 设计原则</h2>
<p>设计模式是设计原则的实践，理解原则是掌握模式的基础。以下是面向对象设计的六大原则：</p>
<ol>
<li>
<p><strong>单一职责原则 (Single Responsibility Principle - SRP)</strong></p>
<ul>
<li><strong>定义：</strong> 一个类只负责一个职责或一个功能。</li>
<li><strong>目的：</strong> 提高类的内聚性，降低耦合度。当需求变化时，修改一个类的原因只有一个。</li>
<li><strong>体现：</strong> 门面模式（门面只负责协调子系统，不实现具体业务）。</li>
</ul>
</li>
<li>
<p><strong>开闭原则 (Open/Closed Principle - OCP)</strong></p>
<ul>
<li><strong>定义：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</li>
<li><strong>目的：</strong> 提高系统的可扩展性和稳定性。不修改现有代码即可增加新功能。</li>
<li><strong>体现：</strong> 工厂方法模式（增加新产品不修改工厂）、策略模式（增加新算法不修改上下文）、装饰器模式（增加新功能不修改核心类）。</li>
</ul>
</li>
<li>
<p><strong>里氏替换原则 (Liskov Substitution Principle - LSP)</strong></p>
<ul>
<li><strong>定义：</strong> 所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li><strong>目的：</strong> 确保继承的正确性和多态的有效性。子类必须能够替换掉它们的父类，并仍能正常工作。</li>
<li><strong>体现：</strong> 所有使用多态（虚函数）的设计模式都遵循此原则，如策略模式、模板方法模式。</li>
</ul>
</li>
<li>
<p><strong>接口隔离原则 (Interface Segregation Principle - ISP)</strong></p>
<ul>
<li><strong>定义：</strong> 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>
<li><strong>目的：</strong> 避免“胖接口”，防止一个类实现它不关心的功能。</li>
<li><strong>体现：</strong> 适配器模式（将不兼容的大接口拆分为小接口），也可以通过细化接口来避免在一个大接口中包含多种职责。</li>
</ul>
</li>
<li>
<p><strong>依赖倒置原则 (Dependency Inversion Principle - DIP)</strong></p>
<ul>
<li><strong>定义：</strong>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖抽象。</li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。</li>
</ul>
</li>
<li><strong>目的：</strong> 解耦，提高系统的灵活性和可维护性。面向接口编程，而不是面向实现编程。</li>
<li><strong>体现：</strong> 工厂模式、策略模式、观察者模式、桥接模式等，都通过抽象接口来实现依赖倒置。</li>
</ul>
</li>
<li>
<p><strong>迪米特法则 (Law of Demeter - LoD) / 最少知识原则</strong></p>
<ul>
<li><strong>定义：</strong> 一个对象应该对其他对象有最少的了解。只和你的直接朋友交流。</li>
<li><strong>目的：</strong> 降低类之间的耦合度，提高系统的健壮性。</li>
<li><strong>体现：</strong> 门面模式（客户端只与门面交互，不了解子系统内部）。</li>
</ul>
</li>
</ol>
<hr />
<h2 id="6-设计模式对比与辨析"><a class="markdownIt-Anchor" href="#6-设计模式对比与辨析"></a> 6. 设计模式对比与辨析</h2>
<p>许多设计模式在表面上看起来相似，但在目的和应用场景上存在显著差异。理解这些区别是掌握模式的关键。</p>
<h3 id="61-创建型模式对比"><a class="markdownIt-Anchor" href="#61-创建型模式对比"></a> 6.1. 创建型模式对比</h3>
<ul>
<li>
<p><strong>工厂方法 vs 抽象工厂 vs 建造者</strong></p>
<ul>
<li><strong>工厂方法：</strong> 创建 <strong>一个</strong> 产品家族中的 <strong>一个</strong> 产品。关注点是 &quot;谁来创建产品&quot;。
<ul>
<li><strong>示例：</strong> 生产汽车的工厂，可以生产轿车，也可以生产卡车，但一次只生产一种。</li>
</ul>
</li>
<li><strong>抽象工厂：</strong> 创建 <strong>一系列相关或相互依赖的</strong> 产品。关注点是 &quot;创建什么产品家族&quot;。
<ul>
<li><strong>示例：</strong> 生产汽车配件的工厂，既能生产轿车发动机，又能生产轿车轮胎；或者既能生产卡车发动机，又能生产卡车轮胎。用户选择“轿车配件工厂”或“卡车配件工厂”，就能得到对应系列的所有配件。</li>
</ul>
</li>
<li><strong>建造者：</strong> 复杂对象的 <strong>分步构建</strong>。关注点是 &quot;如何构建一个复杂对象&quot;。
<ul>
<li><strong>示例：</strong> 组装一辆汽车，用户一步步选择发动机、轮胎、颜色、内饰，最后得到完整的汽车。同样的构建步骤可以组装出 SUV 或跑车。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>工厂方法 vs 原型</strong></p>
<ul>
<li><strong>工厂方法：</strong> 通过 <strong>实例化</strong> （<code>new</code>）来创建新对象。</li>
<li><strong>原型：</strong> 通过 <strong>复制</strong> 现有对象来创建新对象。当对象的创建过程复杂，或需要避免与具体类耦合时，原型模式更具优势。</li>
</ul>
</li>
</ul>
<h3 id="62-结构型模式对比"><a class="markdownIt-Anchor" href="#62-结构型模式对比"></a> 6.2. 结构型模式对比</h3>
<ul>
<li>
<p><strong>适配器 vs 门面</strong></p>
<ul>
<li><strong>适配器：</strong> 解决 <strong>接口不兼容</strong> 的问题。将一个类的接口转换为另一个客户端期望的接口。
<ul>
<li><strong>目的：</strong> 接口转换。</li>
<li><strong>关注点：</strong> 两个不兼容接口之间的桥梁。</li>
</ul>
</li>
<li><strong>门面：</strong> 解决 <strong>子系统复杂性</strong> 的问题。为复杂子系统提供一个统一、简化的入口。
<ul>
<li><strong>目的：</strong> 简化接口。</li>
<li><strong>关注点：</strong> 隐藏复杂性，提供高层抽象。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>装饰器 vs 代理</strong></p>
<ul>
<li><strong>装饰器：</strong> <strong>增强功能</strong>。在不改变原有对象接口的前提下，动态地给对象添加新功能。可以层层嵌套。
<ul>
<li><strong>示例：</strong> 咖啡加牛奶，再加糖。</li>
</ul>
</li>
<li><strong>代理：</strong> <strong>控制访问</strong>。为另一个对象提供一个替身或占位符，以控制对这个对象的访问。通常只控制一个真实对象。
<ul>
<li><strong>示例：</strong> 延迟加载图片，权限验证。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>桥接 vs 组合</strong></p>
<ul>
<li><strong>桥接：</strong> 解决 <strong>两个独立变化维度</strong> 的解耦问题（抽象与实现）。
<ul>
<li><strong>示例：</strong> 遥控器（抽象）与设备（实现）独立变化。</li>
</ul>
</li>
<li><strong>组合：</strong> 解决 <strong>部分-整体层次结构</strong> 的统一处理问题。
<ul>
<li><strong>示例：</strong> 文件和文件夹的树形结构，可以统一操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="63-行为型模式对比"><a class="markdownIt-Anchor" href="#63-行为型模式对比"></a> 6.3. 行为型模式对比</h3>
<ul>
<li>
<p><strong>策略 vs 模板方法</strong></p>
<ul>
<li><strong>策略：</strong> 封装 <strong>整个算法</strong>。客户端可以在运行时选择并切换不同的算法。通过 <strong>组合</strong> 实现。
<ul>
<li><strong>谁决定：</strong> 客户端。</li>
<li><strong>变什么：</strong> 整个算法。</li>
<li><strong>示例：</strong> 支付方式（支付宝、微信），排序算法。</li>
</ul>
</li>
<li><strong>模板方法：</strong> 封装 <strong>算法的骨架</strong>，允许子类重写其中的 <strong>特定步骤</strong>。通过 <strong>继承</strong> 实现。
<ul>
<li><strong>谁决定：</strong> 父类（固定流程），子类（具体步骤）。</li>
<li><strong>变什么：</strong> 算法中的部分步骤。</li>
<li><strong>示例：</strong> 制作饮料的固定步骤，但泡茶和泡咖啡的具体步骤不同。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>状态 vs 策略</strong></p>
<ul>
<li><strong>状态：</strong> 行为改变由对象的 <strong>内部状态</strong> 决定。不同状态类可以相互引用并执行状态转换。
<ul>
<li><strong>目的：</strong> 当对象的行为因内部状态变化而改变时。</li>
<li><strong>示例：</strong> 自动售货机的“无钱”状态到“有钱”状态。</li>
</ul>
</li>
<li><strong>策略：</strong> 行为改变由 <strong>客户端选择</strong> 不同的算法（策略）决定。策略类通常彼此独立。
<ul>
<li><strong>目的：</strong> 当需要运行时选择不同的算法时。</li>
<li><strong>示例：</strong> 客户端选择用支付宝还是微信支付。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>观察者 vs 中介者</strong></p>
<ul>
<li><strong>观察者：</strong> 对象之间是 <strong>一对多</strong> 的依赖关系，通常是 <strong>发布-订阅</strong> 模式，主题直接通知观察者。
<ul>
<li><strong>耦合度：</strong> 主题和观察者之间直接耦合（尽管是松散的）。</li>
</ul>
</li>
<li><strong>中介者：</strong> 对象之间通过一个 <strong>中心中介者</strong> 进行通信，消除直接引用。
<ul>
<li><strong>耦合度：</strong> 所有同事只与中介者耦合，彼此解耦。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>命令 vs 策略</strong></p>
<ul>
<li><strong>命令：</strong> 将 <strong>一个请求</strong>（动作、接收者、参数）封装为一个对象。侧重于可撤销、可排队、可记录等额外功能。</li>
<li><strong>策略：</strong> 将 <strong>整个算法</strong> 封装为一个对象。侧重于算法的可替换性。</li>
</ul>
</li>
<li>
<p><strong>访问者 vs 迭代器</strong></p>
<ul>
<li><strong>访问者：</strong> 对复杂对象结构（如树）中的 <strong>不同类型元素</strong> 执行 <strong>不同操作</strong>。侧重于在不修改元素类的情况下增加新操作。</li>
<li><strong>迭代器：</strong> 顺序访问聚合对象中的元素，<strong>隐藏内部表示</strong>。侧重于遍历方式。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="7-总结"><a class="markdownIt-Anchor" href="#7-总结"></a> 7. 总结</h2>
<p>设计模式是经验的总结，是解决常见软件设计问题的“最佳实践”。它们提供了一种标准化的方式来讨论和解决设计问题，提升了代码的可读性、可维护性和可扩展性。</p>
<p><strong>C++ 中的注意事项：</strong></p>
<ul>
<li><strong>内存管理：</strong> C++ 中需手动管理内存 (<code>new</code>/<code>delete</code>)。强烈推荐使用 <strong>智能指针</strong> (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>) 来避免内存泄漏和悬垂指针，尤其在实现多态和对象所有权转移时。我在示例中主要使用了 <code>std::unique_ptr</code> 来体现所有权转移。</li>
<li><strong>虚函数和多态：</strong> 设计模式大量依赖多态，因此虚函数 (<code>virtual</code>) 和纯虚函数 (<code>= 0</code>) 的使用至关重要。别忘了虚析构函数 (<code>virtual ~ClassName() = default;</code>) 来确保正确释放继承链上的资源。</li>
<li><strong><code>final</code> 关键字：</strong> C++11 引入的 <code>final</code> 关键字可以用于类和虚函数，防止类被继承或虚函数被重写，在模板方法等模式中可以用于固定算法骨架。</li>
<li><strong>RAII (Resource Acquisition Is Initialization)：</strong> C++ 特有的资源管理范式，利用对象的生命周期来管理资源（如智能指针、文件句柄），与设计模式相辅相成。</li>
</ul>
<p>学习设计模式不应止于记忆其定义和结构，更重要的是理解它们所解决的 <strong>问题</strong> 和背后的 <strong>设计原则</strong>。通过实践，你会发现这些模式在现实世界的代码库中无处不在，它们是构建健壮、可维护和可扩展软件的基石。</p>
<p>希望这份详尽的文档能对你的 C++设计模式学习之路有所帮助！</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/categories/Embedded-Linux/">嵌入式/Linux</a></li>
        
          <li><a href="/categories/Programming/">编程算法</a></li>
        
          <li><a href="/categories/Research-AI/">学术研究</a></li>
        
          <li><a href="/categories/Journal/">生活随笔</a></li>
        
          <li><a href="/archives/">时间轴</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text"> C++ 设计模式与设计原则速查指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-creational-patterns"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 创建型设计模式 (Creational Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton-pattern"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 2.1. 单例模式 (Singleton Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-prototype-pattern"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2.2. 原型模式 (Prototype Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-factory-method-pattern"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 2.3. 工厂方法模式 (Factory Method Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-abstract-factory-pattern"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 2.4. 抽象工厂模式 (Abstract Factory Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-builder-pattern"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 2.5. 建造者模式 (Builder Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-structural-patterns"><span class="toc-number">1.3.</span> <span class="toc-text"> 3. 结构型设计模式 (Structural Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-adapter-pattern"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 3.1. 适配器模式 (Adapter Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-bridge-pattern"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 3.2. 桥接模式 (Bridge Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-composite-pattern"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 3.3. 组合模式 (Composite Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-decorator-pattern"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 3.4. 装饰器模式 (Decorator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F-facade-pattern"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 3.5. 门面模式 (Facade Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-flyweight-pattern"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 3.6. 享元模式 (Flyweight Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-proxy-pattern"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 3.7. 代理模式 (Proxy Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-behavioral-patterns"><span class="toc-number">1.4.</span> <span class="toc-text"> 4. 行为型设计模式 (Behavioral Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-template-method-pattern"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 4.1. 模板方法模式 (Template Method Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-iterator-pattern"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 4.2. 迭代器模式 (Iterator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-chain-of-responsibility-pattern"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 4.3. 责任链模式 (Chain of Responsibility Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-strategy-pattern"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 4.4. 策略模式 (Strategy Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-state-pattern"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 4.5. 状态模式 (State Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-memento-pattern"><span class="toc-number">1.4.6.</span> <span class="toc-text"> 4.6. 备忘录模式 (Memento Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-mediator-pattern"><span class="toc-number">1.4.7.</span> <span class="toc-text"> 4.7. 中介者模式 (Mediator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-command-pattern"><span class="toc-number">1.4.8.</span> <span class="toc-text"> 4.8. 命令模式 (Command Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-visitor-pattern"><span class="toc-number">1.4.9.</span> <span class="toc-text"> 4.9. 访问者模式 (Visitor Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#410-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-observer-pattern"><span class="toc-number">1.4.10.</span> <span class="toc-text"> 4.10. 观察者模式 (Observer Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#411-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-interpreter-pattern"><span class="toc-number">1.4.11.</span> <span class="toc-text"> 4.11. 解释器模式 (Interpreter Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text"> 5. 设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E%E8%BE%A8%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text"> 6. 设计模式对比与辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 6.1. 创建型模式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 6.2. 结构型模式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 6.3. 行为型模式对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text"> 7. 总结</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&text=C++ 设计模式与设计原则速查指南"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&is_video=false&description=C++ 设计模式与设计原则速查指南"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ 设计模式与设计原则速查指南&body=Check out this article: https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&title=C++ 设计模式与设计原则速查指南"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&name=C++ 设计模式与设计原则速查指南&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/08/03/Programming/CPP-Core/C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E9%80%9F%E6%9F%A5%E6%8C%87%E5%8D%97/&t=C++ 设计模式与设计原则速查指南"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2026
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/categories/Embedded-Linux/">嵌入式/Linux</a></li><!--
     --><!--
       --><li><a href="/categories/Programming/">编程算法</a></li><!--
     --><!--
       --><li><a href="/categories/Research-AI/">学术研究</a></li><!--
     --><!--
       --><li><a href="/categories/Journal/">生活随笔</a></li><!--
     --><!--
       --><li><a href="/archives/">时间轴</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@10.8.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
