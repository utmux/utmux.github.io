<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：好   网络结构模式  C&#x2F;S 模式 即客户端服务器模式，客户端向服务器发送请求，服务器返回响应。优点是可以充分利用客户端处理能力，效率高，缺点是要求客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高，且不能够跨平台。  B&#x2F;S 模式 即浏览器服务">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客项目教程3">
<meta property="og:url" content="https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：好   网络结构模式  C&#x2F;S 模式 即客户端服务器模式，客户端向服务器发送请求，服务器返回响应。优点是可以充分利用客户端处理能力，效率高，缺点是要求客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高，且不能够跨平台。  B&#x2F;S 模式 即浏览器服务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/a6716b048c8f9d5c02a4b3d02301959b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/4414f2bbbb9f5a587efec2815120e12f.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/8a69d9fb5d2d831e25987f85021ef191.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/720f6772a440ffa5059eb267aec84f63.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/68a6ca137f2785c399f75a3349e4928c.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/7ab2811e1e6526acd8aa4be5c480cef5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/80b07ea464dba90815cc278735d4fe9d.png">
<meta property="og:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/77dfee0c4b96764e1c397f6969d6303e.png">
<meta property="article:published_time" content="2025-01-05T11:59:26.000Z">
<meta property="article:modified_time" content="2025-05-14T08:53:32.517Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/utmux/pictures/main/img/a6716b048c8f9d5c02a4b3d02301959b.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>牛客项目教程3</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/05/10/research/SAR%E4%BB%BF%E7%9C%9F%E8%AE%BE%E8%AE%A1/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/01/04/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B2/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&text=牛客项目教程3"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&is_video=false&description=牛客项目教程3"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=牛客项目教程3&body=Check out this article: https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&name=牛客项目教程3&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&t=牛客项目教程3"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text"> 网络结构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cs-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> C&#x2F;S 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bs-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> B&#x2F;S 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mac-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.</span> <span class="toc-text"> MAC 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text"> IP 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">1.5.</span> <span class="toc-text"> 子网掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text"> 端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text"> 网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 七层网络模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcpip-%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text"> TCP&#x2F;IP 四层网络模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.</span> <span class="toc-text"> 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#udp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text"> UDP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text"> TCP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.3.</span> <span class="toc-text"> IP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.4.</span> <span class="toc-text"> ARP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%B0%81%E8%A3%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.5.</span> <span class="toc-text"> 以太网帧封装协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text"> 字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.1.</span> <span class="toc-text"> socket 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8-socket-%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.9.1.1.</span> <span class="toc-text"> 通用 socket 地址结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8-socket-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.1.2.</span> <span class="toc-text"> 专用 socket 地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2-ip-%E6%95%B4%E6%95%B0-%E4%B8%BB%E6%9C%BA-%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.2.</span> <span class="toc-text"> IP 地址转换（字符串 ip-整数 ，主机、网络字节序的转换）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text"> TCP 通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text"> TCP 三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.10.2.</span> <span class="toc-text"> 滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.10.3.</span> <span class="toc-text"> 四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.4.</span> <span class="toc-text"> 半关闭状态的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#recv-%E5%AF%B9%E6%AF%94-read-%E8%AF%BB%E5%8F%96%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.10.4.1.</span> <span class="toc-text"> recv 对比 read 读取套接字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">1.10.5.</span> <span class="toc-text"> 端口复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text"> IO 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bio"><span class="toc-number">1.11.1.</span> <span class="toc-text"> BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.11.2.</span> <span class="toc-text"> 非阻塞，忙轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nio"><span class="toc-number">1.11.3.</span> <span class="toc-text"> NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">1.11.4.</span> <span class="toc-text"> select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">1.11.5.</span> <span class="toc-text"> poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">1.11.6.</span> <span class="toc-text"> epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%89%93%E6%96%AD%E5%AF%BC%E8%87%B4%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.11.6.1.</span> <span class="toc-text"> 注意信号量打断导致非阻塞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udp-%E9%80%9A%E4%BF%A1"><span class="toc-number">1.12.</span> <span class="toc-text"> UDP 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-number">1.12.1.</span> <span class="toc-text"> 广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%92%AD"><span class="toc-number">1.12.2.</span> <span class="toc-text"> 组播</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">1.12.2.1.</span> <span class="toc-text"> 组播地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.13.</span> <span class="toc-text"> 本地套接字</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        牛客项目教程3
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-01-05T11:59:26.000Z" class="dt-published" itemprop="datePublished">2025-01-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/life/">life</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：好</p>
<hr />
<h2 id="网络结构模式"><a class="markdownIt-Anchor" href="#网络结构模式"></a> 网络结构模式</h2>
<h3 id="cs-模式"><a class="markdownIt-Anchor" href="#cs-模式"></a> C/S 模式</h3>
<p>即客户端服务器模式，客户端向服务器发送请求，服务器返回响应。优点是可以充分利用客户端处理能力，效率高，缺点是要求客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高，且不能够跨平台。</p>
<h3 id="bs-模式"><a class="markdownIt-Anchor" href="#bs-模式"></a> B/S 模式</h3>
<p>即浏览器服务器模式，浏览器向服务器发送请求，服务器返回响应。优点是客户端不需要安装任何软件，只要浏览器即可，缺点是服务器处理能力有限，且客户端处理能力有限。</p>
<h3 id="mac-地址"><a class="markdownIt-Anchor" href="#mac-地址"></a> MAC 地址</h3>
<p>MAC 地址（media access control）是物理地址，用来唯一标识一个网络接口。MAC 地址是物理地址，是网络接口的唯一标识符，是网络接口的物理地址。MAC 地址是物理地址，是网络接口的唯一标识符，是网络接口的物理地址。其长度为为 48 位，即六个字节，其中前面 3 个字节一般用于标识生产厂商。</p>
<h3 id="ip-地址"><a class="markdownIt-Anchor" href="#ip-地址"></a> IP 地址</h3>
<p>和 MAC 地址不同，前者是一个实际的物理地址，后者是一个虚拟的逻辑地址，其长度为 32 位，即 4 个字节。IP 地址可以分成 A，B，C，D，E（后两者为特殊的地址）五类。</p>
<p>其中 A，B，C 这三类分别表示大小不同的局域网，其分别用 IP 的第一段，前两段和前三段表示网络段，如下图所示：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>最大网络数</th>
<th>IP 地址范围</th>
<th>单个网段最大主机数</th>
<th>私有 IP 地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>126 (2^7 - 2)</td>
<td>1.0.0.1 - 126.255.255.254</td>
<td>16777214</td>
<td>10.0.0.0 - 10.255.255.255</td>
</tr>
<tr>
<td>B</td>
<td>16384 (2^14)</td>
<td>128.0.0.1 - 191.255.255.254</td>
<td>65534</td>
<td>172.16.0.0 - 172.31.255.255</td>
</tr>
<tr>
<td>C</td>
<td>2097152 (2^21)</td>
<td>192.0.0.1 - 223.255.255.254</td>
<td>254</td>
<td>192.168.0.0 - 192.168.255.255</td>
</tr>
</tbody>
</table>
<p>注意图中的表格的起始为什么从 1 开始，因为 0 是保留地址，用于广播掩码，同理 255 也是保留地址，用于广播地址。</p>
<h3 id="子网掩码"><a class="markdownIt-Anchor" href="#子网掩码"></a> 子网掩码</h3>
<p>和前面提到的 umask 一样，用于获取网络段和主机段。</p>
<h3 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h3>
<p>端口号是网络通信中用于区分不同进程的标识符，其范围是 0-65535（即 2 个字节，16 位），其中 0-1023 为保留端口（一般用于一些约定的服务，比如 https 等），1024-49151 为注册端口，49152-65535 为动态端口，一般是随机申请使用。</p>
<h3 id="网络模型"><a class="markdownIt-Anchor" href="#网络模型"></a> 网络模型</h3>
<p>网络模型有两个，七层和四层，后者是前者的简化，提高了效率和降低了成本</p>
<h4 id="七层网络模型"><a class="markdownIt-Anchor" href="#七层网络模型"></a> 七层网络模型</h4>
<p>7 层网络模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| 应用层 (Application)|</span><br><span class="line">+---------------------+</span><br><span class="line">| 表示层 (Presentation)|</span><br><span class="line">+---------------------+</span><br><span class="line">| 会话层 (Session)    |</span><br><span class="line">+---------------------+</span><br><span class="line">| 传输层 (Transport)  |</span><br><span class="line">+---------------------+</span><br><span class="line">| 网络层 (Network)    |</span><br><span class="line">+---------------------+</span><br><span class="line">| 数据链路层 (Data Link)|</span><br><span class="line">+---------------------+</span><br><span class="line">| 物理层 (Physical)   |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>层次</th>
<th>名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>第七层</td>
<td>应用层 (Application)</td>
<td>提供网络服务接口，例如 HTTP、FTP、SMTP、DNS 等协议。</td>
</tr>
<tr>
<td>第六层</td>
<td>表示层 (Presentation)</td>
<td>数据格式转换、加密与解密，例如文本编码、图像压缩等。</td>
</tr>
<tr>
<td>第五层</td>
<td>会话层 (Session)</td>
<td>建立、管理和终止会话，例如登录验证、同步点的创建等。</td>
</tr>
<tr>
<td>第四层</td>
<td>传输层 (Transport)</td>
<td>提供端到端的数据传输服务，包含可靠传输（TCP）和非可靠传输（UDP）。</td>
</tr>
<tr>
<td>第三层</td>
<td>网络层 (Network)</td>
<td>负责数据的路径选择与转发（路由功能），主要协议有 IP、ICMP 等。</td>
</tr>
<tr>
<td>第二层</td>
<td>数据链路层 (Data Link)</td>
<td>提供数据帧的传输和差错检测，定义 MAC 地址、交换机的工作。</td>
</tr>
<tr>
<td>第一层</td>
<td>物理层 (Physical)</td>
<td>负责比特流的传输，定义硬件标准（如电缆、信号、电压等）。</td>
</tr>
</tbody>
</table>
<h4 id="tcpip-四层网络模型"><a class="markdownIt-Anchor" href="#tcpip-四层网络模型"></a> TCP/IP 四层网络模型</h4>
<p>TCP/IP 协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用<br />
层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p>
<p>简化后的 TCP/IP 四层网络为：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/a6716b048c8f9d5c02a4b3d02301959b.png" alt="TCPIP" /></p>
<ol>
<li>应用层：应用层是 TCP/IP 协议的第一层，是直接为应用进程提供服务的。（1）对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。（2）应用层还能加密、解密、格式化数据。（3）应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。</li>
<li>传输层：作为 TCP/IP 协议的第二层，运输层在整个 TCP/IP 协议中起到了中流砥柱的作用。且在运输层中， TCP 和 UDP 也同样起到了中流砥柱的作用。</li>
<li>网络层：网络层在 TCP/IP 协议中的位于第三层。在 TCP/IP 协议中网络层可以进行网络连接的建立和终止以及 IP 地址的寻找等功能。</li>
<li>网络接口层：在 TCP/IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。</li>
</ol>
<p>其和上面的 7 层对应关系如下所示：</p>
<table>
<thead>
<tr>
<th>OSI 参考模型</th>
<th>TCP/IP 模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td>表示层</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>网络接口层</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3>
<p>协议是计算机双方共同遵守的一组约定。它的三要素是：<strong>语法、语义、时序。</strong></p>
<p>应用层常见的协议有：FTP 协议（File Transfer Protocol 文件传输协议）、HTTP 协议（Hyper TextTransfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。 传输层常见协议有：TCP 协议（Transmission Control Protocol 传输控制协议）、UDP 协议（UserDatagram Protocol 用户数据报协议）。<br />
网络层常见协议有：IP 协议（Internet Protocol 因特网互联协议）、ICMP 协议（Internet ControlMessage Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特网组管理协议）。<br />
网络接口层常见协议有：ARP 协议（Address Resolution Protocol 地址解析协议）、RARP 协议（Reverse Address Resolution Protocol 反向地址解析协议）。</p>
<h4 id="udp-协议"><a class="markdownIt-Anchor" href="#udp-协议"></a> UDP 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------------------+</span><br><span class="line">|   16位源端口号      |   16位目的端口号    |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|   16位UDP长度       |   16位UDP校验和     |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|                 数据（如果有）            |</span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure>
<ol>
<li>源端口号：发送方端口号</li>
<li>目的端口号：接收方端口号</li>
<li>长度：UDP 用户数据报的长度，最小值是 8（仅有首部）</li>
<li>校验和：检测 UDP 用户数据报在传输中是否有错，有错就丢弃</li>
</ol>
<h4 id="tcp-协议"><a class="markdownIt-Anchor" href="#tcp-协议"></a> TCP 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------------------+</span><br><span class="line">|   16位源端口号      |   16位目的端口号    |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|                32位序号                   |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|                32位确认号                 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|  4位头部长度  | 保留 6位  | 控制位 6位 | </span><br><span class="line">| 16位窗口大小  |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|               16位校验和                  |</span><br><span class="line">|               16位紧急指针                |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|               选项（最多40字节）          |</span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure>
<ol>
<li>源端口号：发送方端口号</li>
<li>目的端口号：接收方端口号</li>
<li>序列号：本报文段的数据的第一个字节的序号</li>
<li>确认序号：期望收到对方下一个报文段的第一个数据字节的序号</li>
<li>首部长度（数据偏移）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长度。单位：32 位，即以 4 字节为计算单位</li>
<li>保留：占 6 位，保留为今后使用，目前应置为 0</li>
<li>紧急 URG ：此位置 1 ，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送</li>
<li>确认 ACK：仅当 ACK = 1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须把 ACK 置 1</li>
<li>推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方 TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</li>
<li>复位 RST：用于复位相应的 TCP 连接</li>
<li>同步 SYN：仅在三次握手建立 TCP 连接时有效。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN = 1 和 ACK = 1。因此，SYN 置 1 就表示这是一个连接请求或连接接受报文</li>
<li>终止 FIN：用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li>
<li>窗口：指发送本报文段的一方的接收窗口（而不是自己的发送窗口）</li>
<li>校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头部</li>
<li>紧急指针：仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据</li>
<li>选项：长度可变，最长可达 40 字节，当没有使用选项时，TCP 首部长度是 20 字节</li>
</ol>
<h4 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+---------------------+</span><br><span class="line">|   16位源端口号      |   16位目的端口号    |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|                32位序号                   |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|                32位确认号                 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|  4位头部长度  | 保留 6位  | 控制位 6位 | </span><br><span class="line">| 16位窗口大小  |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|               16位校验和                  |</span><br><span class="line">|               16位紧急指针                |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|               选项（最多40字节）          |</span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure>
<ol>
<li>版本：IP 协议的版本。通信双方使用过的 IP 协议的版本必须一致，目前最广泛使用的 IP 协议版本号为 4（即 IPv4)</li>
<li>首部长度：单位是 32 位（4 字节）</li>
<li>服务类型：一般不适用，取值为 0</li>
<li>总长度：指首部加上数据的总长度，单位为字节</li>
<li>标识（identification）：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段</li>
<li>标志（flag）：目前只有两位有意义。标志字段中的最低位记为 MF。MF = 1 即表示后面“还有分片”的数据报。MF = 0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF，意思是“不能分片”，只有当 DF = 0 时才允许分片</li>
<li>片偏移：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以 8 字节为偏移单位。</li>
<li>生存时间：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个字段。路由器在转发数据之前就把 TTL 值减一，当 TTL 值减为零时，就丢弃这个数据报。</li>
<li>协议：指出此数据报携带的数据时使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程，常用的 ICMP(1)，IGMP(2)，TCP(6)，UDP(17)，IPv6（41）</li>
<li>首部校验和：只校验数据报的首部，不包括数据部分。</li>
<li>源地址：发送方 IP 地址</li>
<li>目的地址：接收方 IP 地址</li>
</ol>
<h4 id="arp-协议"><a class="markdownIt-Anchor" href="#arp-协议"></a> ARP 协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+--------+-------------------+--------+-------------------+--------+</span><br><span class="line">| 硬件   | 协议   | 硬件地 | 协议地 | 操作   | 发送端以太网地址  | 发送端 | 目的端以太网地址  | 目的端 |</span><br><span class="line">| 类型   | 类型   | 址长度 | 址长度 |        |                   | IP地址 |                   | IP地址 |</span><br><span class="line">| (2字节)| (2字节)| (1字节)| (1字节)| (2字节)| (6字节)           | (4字节)| (6字节)           | (4字节)|</span><br><span class="line">+--------+--------+--------+--------+--------+-------------------+--------+-------------------+--------+</span><br></pre></td></tr></table></figure>
<p>类型：0x800 表示 IP、0x806 表示 ARP、0x835 表示 RARP</p>
<h4 id="以太网帧封装协议"><a class="markdownIt-Anchor" href="#以太网帧封装协议"></a> 以太网帧封装协议</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+-------------------+--------+-------------------+------+</span><br><span class="line">| 目的物理地址      | 源物理地址        | 类型   | 数据              | CRC  |</span><br><span class="line">| (6字节)           | (6字节)           | (2字节)| (46~1500字节)     | (4字节)|</span><br><span class="line">+-------------------+-------------------+--------+-------------------+------+</span><br></pre></td></tr></table></figure>
<ol>
<li>硬件类型：1 表示 MAC 地址</li>
<li>协议类型：0x800 表示 IP 地址</li>
<li>硬件地址长度：6</li>
<li>协议地址长度：4</li>
<li>操作：1 表示 ARP 请求，2 表示 ARP 应答，3 表示 RARP 请求，4 表示 RARP 应答</li>
</ol>
<h3 id="字节序"><a class="markdownIt-Anchor" href="#字节序"></a> 字节序</h3>
<ol>
<li>大端序：高位字节位于地址低端，低位字节位于地址高端</li>
<li>小端序：低位字节位于地址低端，高位字节位于地址高端</li>
</ol>
<p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，<strong>网络字节顺序采用大端排序方式。</strong></p>
<p>BSD Socket 提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network 网络字节序</span><br><span class="line">s - <span class="type">short</span> <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">l - <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br></pre></td></tr></table></figure>
<h4 id="socket-地址"><a class="markdownIt-Anchor" href="#socket-地址"></a> socket 地址</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个</span><br><span class="line">socket地址。</span><br><span class="line">// 客户端 -&gt; 服务器（IP, Port）</span><br></pre></td></tr></table></figure>
<h5 id="通用-socket-地址结构体"><a class="markdownIt-Anchor" href="#通用-socket-地址结构体"></a> 通用 socket 地址结构体</h5>
<p>通用 socket 地址是一个存储 IP 和端口信息的结构体，其被定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>sa_family_t：表示地址族，表示地址类型，比如 IPV4、IPV6 等，其通常也和协议对应：
<ul>
<li>AF_INET：IPV4，对应协议族 PF_UNIX</li>
<li>AF_INET6：IPV6，对应协议族 PF_INET</li>
<li>AF_UNIX：UNIX 域 socket，对应协议族 PF_INET6</li>
<li>宏 <code>PF_*</code> 和 <code>AF_*</code> 都定义在 bits/socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。</li>
</ul>
</li>
<li>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：
<ul>
<li>PF_UNIX：文件的路径名，长度可达到 108 字节</li>
<li>PF_INET：16 bit 端口号和 32 bit IPv4 地址，共 6 字节</li>
<li>PF_INET6：16 bit 端口号，32 bit 流标识，128 bit IPv6 地址，32 bit 范围 ID，共 26 字节</li>
</ul>
</li>
</ol>
<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line"><span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>
<h5 id="专用-socket-地址"><a class="markdownIt-Anchor" href="#专用-socket-地址"></a> 专用 socket 地址</h5>
<p>早期的网络编程都是使用专用的 socket 地址，即 <code>struct socketaddr</code>，为了向前兼容，现在 sockaddr 退化成了 <code>(void *)</code> 的作用，传递一个地址给函数，至于这个函数是 <code>sockaddr_in</code> 还是 <code>sockaddr_in6</code>，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<p>总结一下，通用 socket 地址 <code>socketaddr</code> 是一个特殊结构体，实际中传入的是专用 socket 地址，如 <code>sockaddr_in</code>、<code>sockaddr_in6</code> 等。由于这几个专用的 socket 地址中的前 16 位都是表示地址类型，此时可以将专用的 socket 地址，转化为通用 socket 地址，如下图表示：</p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/4414f2bbbb9f5a587efec2815120e12f.png" alt="通用和专用 socket 结构" /></p>
<p>如上图所示，几个专用的 socket 结构体如下所示：</p>
<p>首先是用于 Unix 域 socket 的专用 socket 地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后是用于 TCP/IP 协议的专用 socket 地址结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span></span><br><span class="line"><span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line"><span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin6_family;</span><br><span class="line"><span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure>
<h4 id="ip-地址转换字符串-ip-整数-主机-网络字节序的转换"><a class="markdownIt-Anchor" href="#ip-地址转换字符串-ip-整数-主机-网络字节序的转换"></a> IP 地址转换（字符串 ip-整数 ，主机、网络字节序的转换）</h4>
<p>IP 地址转换，主要是将字符串类型的 IP 地址转换为整数类型的 IP 地址，以及将整数类型的 IP 地址转换为字符串类型的 IP 地址。</p>
<p>下面这这几个函数用于字符串和 IP 之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>; <span class="comment">// 字符串ip-整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>; <span class="comment">// 字符串ip-整数</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>; <span class="comment">// 整数ip-字符串，不可重用，因为该函数内部使用了一个固定的静态变量保存结果，再次调用会覆盖</span></span><br></pre></td></tr></table></figure>
<p>上面三个函数比较老旧，基本不再使用，现在使用 <code>inet_pton</code> 和 <code>inet_ntop</code> 函数来完成同样的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure>
<h3 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// TCP 和 UDP -&gt; 传输层的协议</span><br><span class="line">UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠</span><br><span class="line">TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输</span><br><span class="line">UDP TCP</span><br><span class="line">是否创建连接 无连接 面向连接</span><br><span class="line">是否可靠 不可靠 可靠的</span><br><span class="line">连接的对象个数 一对一、一对多、多对一、多对多 支持一对一</span><br><span class="line">传输的方式 面向数据报 面向字节流</span><br><span class="line">首部开销 8个字节 最少20个字节</span><br><span class="line">适用场景 实时应用（视频会议，直播） 可靠性高的应用（文件传输）</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/8a69d9fb5d2d831e25987f85021ef191.png" alt="TCP 通信流程" /></p>
<p>相关使用的系统函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">- domain: 协议族</span><br><span class="line">AF_INET : ipv4</span><br><span class="line">AF_INET6 : ipv6</span><br><span class="line">AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">- type: 通信过程中使用的协议类型</span><br><span class="line">SOCK_STREAM : 流式协议</span><br><span class="line">SOCK_DGRAM : 报式协议</span><br><span class="line">- protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">- 失败：<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">// socket命</span></span><br><span class="line">名</span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">- backlog : 未连接的和已经连接的和的最大值， <span class="number">5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于监听的文件描述符</span><br><span class="line">- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功 ：用于通信的文件描述符</span><br><span class="line">- <span class="number">-1</span> ： 失败</span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于通信的文件描述符</span><br><span class="line">- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">- addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>
<h4 id="tcp-三次握手"><a class="markdownIt-Anchor" href="#tcp-三次握手"></a> TCP 三次握手</h4>
<p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。</p>
<p>TCP 使用三次握手，四次挥手来建立连接和断开连接。</p>
<p>首先是三次握手，其发生在客户端连接的时候，此时客户端发起 <code>connect</code> 请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Client                                        Server</span><br><span class="line">  |                                              |</span><br><span class="line">  |---------------- SYN=1 seq=J ----------------&gt;|</span><br><span class="line">  |                                              |</span><br><span class="line">  |&lt;------- SYN=1, ACK=1 ack=J+1, seq=K ---------|</span><br><span class="line">  |                                              |</span><br><span class="line">  |---------------- ACK=1 ack=K+1 --------------&gt;|</span><br><span class="line">  |                                              |</span><br><span class="line">ESTABLISHED                                  ESTABLISHED</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：</span><br><span class="line">1.客户端将SYN标志位置为1</span><br><span class="line">2.生成一个随机的32位的序号seq=J ， 这个序号后边是可以携带数据（数据的大小）</span><br><span class="line">第二次握手：</span><br><span class="line">1.服务器端接收客户端的连接： ACK=1</span><br><span class="line">2.服务器会回发一个确认序号： ack=客户端的序号 + 数据长度 + <span class="strong">**SYN/FIN(按一个字节算)**</span></span><br><span class="line">3.服务器端会向客户端发起连接请求： SYN=1</span><br><span class="line">4.服务器会生成一个随机序号：seq = K</span><br><span class="line">第三次握手：</span><br><span class="line">1.客户单应答服务器的连接请求：ACK=1</span><br><span class="line">2.客户端回复收到了服务器端的数据：ack=服务端的序号 + 数据长度 + SYN/FIN(按一个字节算)</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h4>
<p>正如之前的 TCP 协议图解，其存在一个滑动窗口的字段，其大小为 32 位值，其表示发送窗口的大小。</p>
<p>其中发送方和接受的服务器都有滑动窗口，前者记录已经发送的数据的大小，后者记录还能接受的数据的大小。</p>
<p>通过滑动窗口，发送方可以一次性发送多个数据包，而不用等待服务器的回复（即 ACK）。</p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/720f6772a440ffa5059eb267aec84f63.png" alt="滑动窗口" /></p>
<h4 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h4>
<p>四次挥手是 TCP 协议中的一个重要机制，用于关闭连接。其发生顺序为：</p>
<ol>
<li>客户端发送 FIN 包，表示不再发送数据，但可以接受数据。</li>
<li>服务器端收到 FIN 包后，发送 ACK 包，表示不再接受数据，但可以发送数据。</li>
<li>客户端发送 FIN 包，表示不再发送数据，但可以接受数据。</li>
<li>服务器端收到 FIN 包后，发送 ACK 包，表示不再接受数据，但可以发送数据。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client                                          Server</span><br><span class="line">  |                                                |</span><br><span class="line">  |-------------------- FIN M --------------------&gt;| CLOSE_WAIT</span><br><span class="line">  |                                                |</span><br><span class="line">  |&lt;------------------- ACK M+1 -------------------| </span><br><span class="line">  |                                                |</span><br><span class="line">  |-------------------- FIN N --------------------&gt;| LAST_ACK</span><br><span class="line">  |                                                |</span><br><span class="line">  |&lt;------------------- ACK K+1 -------------------| CLOSED</span><br><span class="line">  |                                                |</span><br></pre></td></tr></table></figure>
<p>整个 TCP 协议从建立到关闭的状态转换图如下所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/68a6ca137f2785c399f75a3349e4928c.png" alt="TCP 状态转换图" /></p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/7ab2811e1e6526acd8aa4be5c480cef5.png" alt="TCP 状态转换图" /></p>
<p><strong>为什么使用四次挥手，而不是三次挥手呢？</strong><br />
原因是为了保证正确安全的关闭数据，当客户端第一次挥手发送 FIN 时，此时，如上图，客户端已经 close，此时只能接受数据，无法发送数据，如果客户端直接发送 ACK 和 FIN 一起发送，会导致立即结束服务器发送。此时服务器可能还存在未发送完成的数据，会导致数据丢失。<br />
这样四次挥手，可以分别关闭客户端和服务端的发送，这样还能实现半关闭状态，如果一方只接受，另一方只发送的情况。</p>
<p><strong>为什么要等待 2MSL 的时间才结束</strong><br />
这个是为了安全性，防止（主动断开的一方）客户端没有接收到 ACK 导致客户端一直在等待服务端发送 ACK 信号（客户端会重新发送 FIN）。<br />
在官方的指导中一个 MSL 的时间是 2min，但是在 LINUX 中的实现中是 30S。</p>
<h4 id="半关闭状态的使用"><a class="markdownIt-Anchor" href="#半关闭状态的使用"></a> 半关闭状态的使用</h4>
<p>当 TCP 连接中，一方处于 FIN_WAIT2 状态，此时一方只能接收，而不能发送，此时称作半关闭状态。</p>
<p>为了实现半关闭状态，可以使用 API 来实现半连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="comment">//sockfd: 需要关闭的socket的描述符</span></span><br><span class="line"><span class="comment">//how: 允许为shutdown操作选择以下几种方式:</span></span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span><br><span class="line">该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR</span><br></pre></td></tr></table></figure>
<p>使用 close 中止一个连接，<strong>但它只是减少描述符的引用计数</strong>，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，<strong>直接关闭描述符</strong>。也可选择中止一个方向的连接，只中止读或只中止写。<br />
注意:</p>
<ol>
<li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li>
<li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。</li>
</ol>
<h5 id="recv-对比-read-读取套接字"><a class="markdownIt-Anchor" href="#recv-对比-read-读取套接字"></a> recv 对比 read 读取套接字</h5>
<p>为了更加方便的读取套接字，一般使用 <code>recv</code> 而不是 <code>read</code> 对套接字文件进行读取。这是因为 <code>recv</code> 提供了多种功能的读取，通过传入不同的 <code>flag</code> 参数控制读取方式：</p>
<ul>
<li>
<p>MSG_PEEK：仅窥探数据，不从接收队列中移除（即数据还保留在缓冲区中）。</p>
</li>
<li>
<p>MSG_OOB：读取带外数据。</p>
</li>
<li>
<p>MSG_WAITALL：阻塞等待，直到请求的字节数全部读取完。</p>
</li>
<li>
<p>MSG_DONTWAIT：非阻塞读取。</p>
</li>
</ul>
<p>其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// sockfd: 套接字描述符</span></span><br><span class="line"><span class="comment">// buf: 缓冲区</span></span><br><span class="line"><span class="comment">// len: 缓冲区大小</span></span><br><span class="line"><span class="comment">// flags: 标志位，控制读取方式，具体看man手册</span></span><br></pre></td></tr></table></figure>
<h4 id="端口复用"><a class="markdownIt-Anchor" href="#端口复用"></a> 端口复用</h4>
<p>前面提到了 2MSL 机制，对于服务端而言，如果其需要重启，会导致在 2MSL 的时间内都无法绑定原先的端口，必须等待 2MSL 的时间后原来的 socket 被释放才能重新绑定。这个时候端口复用就起作用了，端口复用通过设置 socket 属性来实现，调用的函数为 <code>setsockopt</code>，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"><span class="comment">// sockfd: 套接字描述符</span></span><br><span class="line"><span class="comment">// level: 协议层，一般使用`SOL_SOCKET`，具体看参考书UNIX网络编程</span></span><br><span class="line"><span class="comment">// optname: 选项名，具体看参考书UNIX网络编程，一般设置为`SO_REUSEADDR`或者`SO_REUSEPORT`</span></span><br><span class="line"><span class="comment">// optval: 选项值，设置为1表示允许端口复用，设置为0表示不允许端口复用</span></span><br><span class="line"><span class="comment">// optlen: optval的长度</span></span><br></pre></td></tr></table></figure>
<p>如上所示，调用函数进行端口复用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br></pre></td></tr></table></figure>
<h3 id="io-多路复用"><a class="markdownIt-Anchor" href="#io-多路复用"></a> IO 多路复用</h3>
<p>传统的 I（input）是指从内存读取数据到程序之中，O（output）是指从程序写数据到内存之中。</p>
<p>前面对于多个 socket 文件是通过多进程或者多线程实现，但是由于线程的资源消耗以及调度消耗的时间，会导致大量资源浪费。</p>
<p>IO 多路复用就是指在一个进程上同时监控多个 socket，当某个 socket 有数据可读时，进程会收到通知，然后进行相应的处理。</p>
<p>Linux 上常见的实现 IO 多路复用有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
</ul>
<h4 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h4>
<p>BIO（Blocking IO）正如前面所说的，通过多线程或者多进程来对应每个客户端连接，需要大量的资源，该模型的特点就是阻塞 IO，即每个进程或者线程当客户端不发送数据时，此时会阻塞。</p>
<h4 id="非阻塞忙轮询"><a class="markdownIt-Anchor" href="#非阻塞忙轮询"></a> 非阻塞，忙轮询</h4>
<p>类似于 for 循环，轮询检查是否有数据可读，如果有数据，则进行相应的处理，如果没有数据，则进行相应的处理。</p>
<p>这种方式在性能上比较差，因为每次都需要进行轮询，并且每次都需要进行判断，所以效率非常低。通过 IO 多路复用可以解决这个问题。</p>
<h4 id="nio"><a class="markdownIt-Anchor" href="#nio"></a> NIO</h4>
<p>NIO（Non-Blocking IO）NIO 是阻塞 IO 的改进，NIO 通过将 IO 操作分为读和写两种，当客户端发送数据时，服务端会阻塞，当客户端没有发送数据时，服务端不会阻塞（即不会阻塞在 accept 处）且不会阻塞在 read 处（即宰 BIO 中把 accept 和 read 函数变成了非阻塞函数）。</p>
<h4 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h4>
<p>select 是 Linux 上最常用的 IO 多路复用模型，其原理是：在 select 函数中，会传入一个 <code>fd_set</code> 结构体，该结构体中包含了所有的 socket 文件描述符，当某个 socket 文件描述符有数据可读时，select 函数会返回，此时进程会收到通知，然后进行相应的处理。</p>
<p>注意只会通知有多少个 socket 文件描述符有数据可读，而不会通知具体的哪个 socket 文件描述符有数据可读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">- nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">- 一般检测读操作</span><br><span class="line">- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲</span><br><span class="line">区</span><br><span class="line">- 是一个传入传出参数</span><br><span class="line">- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">- exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">- timeout : 设置的超时时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line">- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">- 返回值 :</span><br><span class="line">- <span class="number">-1</span> : 失败</span><br><span class="line">- &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> FD_CLR(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>select 的缺点是：</p>
<ol>
<li>select 每次调用都需要将用户空间的 fd_set 复制到内核空间，当监控大量文件描述符时效率较低。</li>
<li>select 每次都会返回所有监控的文件描述符，而不是只返回监控中变化的文件描述符。</li>
<li>select 只支持 1024 个文件描述符。</li>
<li>fds 文件描述符每次都要重新设置。</li>
</ol>
<h4 id="poll"><a class="markdownIt-Anchor" href="#poll"></a> poll</h4>
<p>poll 是 Linux 上另一个常用的 IO 多路复用模型，其原理是：在 poll 函数中，会传入一个 <code>struct epoll_event</code> 结构体数组，该结构体中包含了所有的 socket 文件描述符，当某个 socket 文件描述符有数据可读时，poll 函数会返回，此时进程会收到通知，然后进行相应的处理。</p>
<p>poll 相比 select 更加推荐使用，原因如下：<br />
返回值信息：</p>
<ul>
<li>
<p>select 返回的是就绪的文件描述符总数，但不会直接告诉是哪些文件描述符就绪，需要调用者再次遍历所有文件描述符以确定具体哪个就绪。</p>
</li>
<li>
<p>poll 不仅返回就绪的文件描述符个数，而且对于每一个 pollfd 结构体中的 revents 成员会标明具体的事件类型（例如 POLLIN 表示可读），因此可以直接知道哪个文件描述符发生了什么事件。<br />
性能方面：</p>
</li>
<li>
<p>select 每次调用都需要将用户空间的 fd_set 复制到内核空间，当监控大量文件描述符时效率较低。<br />
poll 只需要传递一个指针给内核，性能上优于 select，特别是在高并发场景下表现更好。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line"><span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line"><span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">- fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">- <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">- timeout : 阻塞时长</span><br><span class="line"><span class="number">0</span> : 不阻塞</span><br><span class="line"><span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">&gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">- 返回值：</span><br><span class="line"><span class="number">-1</span> : 失败</span><br><span class="line">&gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>值 (宏定义)</th>
<th>作为 <code>event</code> 的值</th>
<th>作为 <code>revents</code> 的值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POLLIN</code></td>
<td>是</td>
<td>是</td>
<td>有数据可读（普通数据或优先数据）</td>
</tr>
<tr>
<td><code>POLLPRI</code></td>
<td>是</td>
<td>是</td>
<td>有紧急数据可读（例如带外数据）</td>
</tr>
<tr>
<td><code>POLLOUT</code></td>
<td>是</td>
<td>是</td>
<td>写操作不会阻塞（可以写入数据）</td>
</tr>
<tr>
<td><code>POLLRDHUP</code></td>
<td>是</td>
<td>是</td>
<td>流套接字对端关闭连接，或关闭写半连接（Linux 2.6.17 及以上）</td>
</tr>
<tr>
<td><code>POLLERR</code></td>
<td>否</td>
<td>是</td>
<td>发生错误（仅作为 <code>revents</code> 返回）</td>
</tr>
<tr>
<td><code>POLLHUP</code></td>
<td>否</td>
<td>是</td>
<td>挂起（例如管道或套接字对端关闭，仅作为 <code>revents</code> 返回）</td>
</tr>
<tr>
<td><code>POLLNVAL</code></td>
<td>否</td>
<td>是</td>
<td>无效的文件描述符（例如未打开的文件，仅作为 <code>revents</code> 返回）</td>
</tr>
</tbody>
</table>
<p>poll 的缺点：</p>
<ol>
<li>每次调用会将 fd 集合从用户态拷贝到内核态，开销较大</li>
<li>发生改变时，返回的 fd 集合中只包含发生变化的 fd，需要用户自己遍历判断。</li>
</ol>
<h4 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h4>
<p>epoll 是 Linux 下高效的 IO 多路复用模型，特别适用于处理大量并发连接。它在性能和扩展性方面相比 select 和 poll 有显著的提升。以下是关于 epoll 的一些关键点：</p>
<ul>
<li>事件驱动：epoll 采用事件驱动的方式，只有当某个文件描述符（如 socket）发生了特定事件（如可读、可写），才会通知进程进行处理。</li>
<li>高效的通知机制：与 select 和 poll 不同，epoll 不会每次调用时都遍历所有文件描述符，而是通过内核中的红黑树来管理这些描述符，并且只返回就绪的描述符列表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检</span></span><br><span class="line">测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向</span><br><span class="line">链表）。</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">- 返回值：</span><br><span class="line"><span class="number">-1</span> : 失败</span><br><span class="line">&gt; <span class="number">0</span> : 文件描述符，操作epoll实例的</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">- EPOLLIN</span><br><span class="line">- EPOLLOUT</span><br><span class="line">- EPOLLERR</span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">- epfd : epoll实例对应的文件描述符</span><br><span class="line">- op : 要进行什么操作</span><br><span class="line">EPOLL_CTL_ADD: 添加</span><br><span class="line">EPOLL_CTL_MOD: 修改</span><br><span class="line">EPOLL_CTL_DEL: 删除</span><br><span class="line">- fd : 要检测的文件描述符</span><br><span class="line">- event : 检测文件描述符什么事情</span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span></span></span><br><span class="line"><span class="params">timeout)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">- epfd : epoll实例对应的文件描述符</span><br><span class="line">- events : 传出参数，保存了发送了变化的文件描述符的信息</span><br><span class="line">- maxevents : 第二个参数结构体数组的大小</span><br><span class="line">- timeout : 阻塞时间</span><br><span class="line">- <span class="number">0</span> : 不阻塞</span><br><span class="line">- <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">- &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">- 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>Epoll 的工作模式：<br />
LT 模式 （水平触发）</p>
<p>假设委托内核检测读事件 -&gt; 检测 fd 的读缓冲区<br />
读缓冲区有数据 - &gt; epoll 检测到了会给用户通知</p>
<ul>
<li>a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</li>
<li>b.用户只读了一部分数据，epoll 会通知</li>
<li>c.缓冲区的数据读完了，不通知<br />
LT（level - triggered）是缺省的工作方式，并且同时支持 <strong>block</strong> 和 <strong>no-block socket</strong>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</li>
</ul>
<p>ET 模式（边沿触发）</p>
<p>假设委托内核检测读事件 -&gt; 检测 fd 的读缓冲区<br />
读缓冲区有数据 - &gt; epoll 检测到了会给用户通知</p>
<ul>
<li>a.用户不读数据，数据一致在缓冲区中，epoll 下次检测的时候就不通知了</li>
<li>b.用户只读了一部分数据，epoll 不通知</li>
<li>c.缓冲区的数据读完了，不通知</li>
</ul>
<p>ET（edge - triggered）是高速工作方式，只支持 <strong>no-block socket</strong>。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">- EPOLLIN</span><br><span class="line">- EPOLLOUT</span><br><span class="line">- EPOLLERR</span><br><span class="line">- EPOLLET <span class="comment">// 边沿触发</span></span><br></pre></td></tr></table></figure>
<h5 id="注意信号量打断导致非阻塞"><a class="markdownIt-Anchor" href="#注意信号量打断导致非阻塞"></a> 注意信号量打断导致非阻塞</h5>
<p>对于阻塞的 IO 操作，如果被信号打断，那么会返回-1，并且 errno 被设置为 EINTR，此时需要重新进行 IO 操作。比如 read，如果被信号打断，那么会返回-1，并且 errno 被设置为 EINTR，此时需要重新进行 IO 操作。当文件描述符（fd）指向一个非套接字文件（例如普通文件、管道或 FIFO）时，如果该文件描述符被设置为非阻塞模式（通过 O_NONBLOCK 标志），并且当前操作（如 read）会阻塞（即没有数据可读），系统调用会返回 EAGAIN。</p>
<p>为了防止阻塞被打断，应该再阻塞的 IO 之后判断 errno，然后进行错误处理。</p>
<h3 id="udp-通信"><a class="markdownIt-Anchor" href="#udp-通信"></a> UDP 通信</h3>
<p>相对于 TCP 通信，UDP 通信比较简单。</p>
<p>大致的流程图如下所示：<br />
<img src="https://raw.githubusercontent.com/utmux/pictures/main/img/80b07ea464dba90815cc278735d4fe9d.png" alt="UDP 通信流程图" /></p>
<p>用到的 API 如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通信的fd</span><br><span class="line">- buf : 要发送的数据</span><br><span class="line">- len : 发送数据的长度</span><br><span class="line">- flags : <span class="number">0</span></span><br><span class="line">- dest_addr : 通信的另外一端的地址信息</span><br><span class="line">- addrlen : 地址的内存大小</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通信的fd</span><br><span class="line">- buf : 接收数据的数组</span><br><span class="line">- len : 数组的大小</span><br><span class="line">- flags : <span class="number">0</span></span><br><span class="line">- src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">- addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure>
<h4 id="广播"><a class="markdownIt-Anchor" href="#广播"></a> 广播</h4>
<p>UDP 可以使用广播，但是需要设置 SO_BROADCAST 选项，此时客户端需要绑定一个固定的端口，才能接收到服务器发送的广播数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span></span></span><br><span class="line"><span class="params">optlen)</span>;</span><br><span class="line">- sockfd : 文件描述符</span><br><span class="line">- level : SOL_SOCKET</span><br><span class="line">- optname : SO_BROADCAST</span><br><span class="line">- optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播</span><br><span class="line">- optlen : optval的大小</span><br></pre></td></tr></table></figure>
<h4 id="组播"><a class="markdownIt-Anchor" href="#组播"></a> 组播</h4>
<p>UDP 还能进行组播</p>
<p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。</p>
<p>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。</p>
<ul>
<li>a.组播既可以用于局域网，也可以用于广域网</li>
<li>b.客户端需要加入多播组，才能接收到多播的数据</li>
</ul>
<h5 id="组播地址"><a class="markdownIt-Anchor" href="#组播地址"></a> 组播地址</h5>
<p>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code> ，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</p>
<table>
<thead>
<tr>
<th>IP 地址范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>224.0.0.0 ~ 224.0.0.255</td>
<td>局部链接多播地址：为路由协议和其它用途保留的地址，路由器不转发此范围的 IP 包。</td>
</tr>
<tr>
<td>224.0.1.0 ~ 224.0.1.255</td>
<td>预留多播地址：公用组播地址，可用于 Internet；使用前需要申请。</td>
</tr>
<tr>
<td>224.0.2.0 ~ 238.255.255.255</td>
<td>预留多播地址：用户可用组播地址（临时组地址），全网范围内有效。</td>
</tr>
<tr>
<td>239.0.0.0 ~ 239.255.255.255</td>
<td>本地管理组播地址：可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围。</td>
</tr>
</tbody>
</table>
<p>具体设置组播的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval,</span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"><span class="comment">// 服务器设置多播的信息，外出接口，此时属性为：</span></span><br><span class="line">- level : IPPROTO_IP</span><br><span class="line">- optname : IP_MULTICAST_IF</span><br><span class="line">- optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">// 客户端加入到多播组设置的<span class="title">socket</span>属性：</span></span><br><span class="line"><span class="class">- <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">- optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* IP multicast address of group. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址</span></span><br><span class="line"><span class="comment">/* Local IP address of interface. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="本地套接字"><a class="markdownIt-Anchor" href="#本地套接字"></a> 本地套接字</h3>
<p>本地套接字的作用：本地的进程间通信</p>
<ul>
<li>有关系的进程间的通信</li>
<li>没有关系的进程间的通信</li>
</ul>
<p>本地套接字实现流程和网络套接字类似，一般采用 TCP 的通信流程</p>
<p><img src="https://raw.githubusercontent.com/utmux/pictures/main/img/77dfee0c4b96764e1c397f6969d6303e.png" alt="本地套接字" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 本地套接字通信的流程 - tcp</span><br><span class="line">// 服务器端</span><br><span class="line">1. 创建监听的套接字</span><br><span class="line">int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);</span><br><span class="line">2. 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line">struct sockaddr_un addr;</span><br><span class="line">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span><br><span class="line">bind(lfd, addr, len);</span><br><span class="line">3. 监听</span><br><span class="line">listen(lfd, 100);</span><br><span class="line">4. 等待并接受连接请求</span><br><span class="line">struct sockaddr_un cliaddr;</span><br><span class="line">int cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line">5. 通信</span><br><span class="line">接收数据：read/recv</span><br><span class="line">发送数据：write/send</span><br><span class="line">6. 关闭连接</span><br><span class="line">close();</span><br><span class="line">// 客户端的流程</span><br><span class="line">1. 创建通信的套接字</span><br><span class="line">int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);</span><br><span class="line">2. 监听的套接字绑定本地的IP 端口</span><br><span class="line">struct sockaddr_un addr;</span><br><span class="line">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span><br><span class="line">bind(lfd, addr, len);</span><br><span class="line">3. 连接服务器</span><br><span class="line">struct sockaddr_un serveraddr;</span><br><span class="line">connect(fd, &amp;serveraddr, sizeof(serveraddr));</span><br><span class="line">4. 通信</span><br><span class="line">接收数据：read/recv</span><br><span class="line">发送数据：write/send</span><br><span class="line">5. 关闭连接</span><br><span class="line">close();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line"><span class="type">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text"> 网络结构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cs-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> C&#x2F;S 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bs-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> B&#x2F;S 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mac-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.</span> <span class="toc-text"> MAC 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text"> IP 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">1.5.</span> <span class="toc-text"> 子网掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text"> 端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text"> 网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text"> 七层网络模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcpip-%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text"> TCP&#x2F;IP 四层网络模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.</span> <span class="toc-text"> 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#udp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text"> UDP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text"> TCP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.3.</span> <span class="toc-text"> IP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arp-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.4.</span> <span class="toc-text"> ARP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%B0%81%E8%A3%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.5.</span> <span class="toc-text"> 以太网帧封装协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text"> 字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#socket-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.1.</span> <span class="toc-text"> socket 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8-socket-%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.9.1.1.</span> <span class="toc-text"> 通用 socket 地址结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%93%E7%94%A8-socket-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.1.2.</span> <span class="toc-text"> 专用 socket 地址</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2-ip-%E6%95%B4%E6%95%B0-%E4%B8%BB%E6%9C%BA-%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.2.</span> <span class="toc-text"> IP 地址转换（字符串 ip-整数 ，主机、网络字节序的转换）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text"> TCP 通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text"> TCP 三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.10.2.</span> <span class="toc-text"> 滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.10.3.</span> <span class="toc-text"> 四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.4.</span> <span class="toc-text"> 半关闭状态的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#recv-%E5%AF%B9%E6%AF%94-read-%E8%AF%BB%E5%8F%96%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.10.4.1.</span> <span class="toc-text"> recv 对比 read 读取套接字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">1.10.5.</span> <span class="toc-text"> 端口复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text"> IO 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bio"><span class="toc-number">1.11.1.</span> <span class="toc-text"> BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BF%99%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.11.2.</span> <span class="toc-text"> 非阻塞，忙轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nio"><span class="toc-number">1.11.3.</span> <span class="toc-text"> NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">1.11.4.</span> <span class="toc-text"> select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">1.11.5.</span> <span class="toc-text"> poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">1.11.6.</span> <span class="toc-text"> epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%89%93%E6%96%AD%E5%AF%BC%E8%87%B4%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.11.6.1.</span> <span class="toc-text"> 注意信号量打断导致非阻塞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udp-%E9%80%9A%E4%BF%A1"><span class="toc-number">1.12.</span> <span class="toc-text"> UDP 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-number">1.12.1.</span> <span class="toc-text"> 广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%92%AD"><span class="toc-number">1.12.2.</span> <span class="toc-text"> 组播</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">1.12.2.1.</span> <span class="toc-text"> 组播地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.13.</span> <span class="toc-text"> 本地套接字</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&text=牛客项目教程3"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&is_video=false&description=牛客项目教程3"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=牛客项目教程3&body=Check out this article: https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&title=牛客项目教程3"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&name=牛客项目教程3&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/01/05/life/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B3/&t=牛客项目教程3"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
