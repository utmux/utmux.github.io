<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：下雨 心情：一般   嵌入式学习（一） 今天是2025年07月02日，从今天开始正式学习嵌入式相关的教程，根据我之前看到的一个很好的评论，很多东西没有记录，没有输出就代表没有学习过，从今天开始，我将和学习CPP一样，尝试来记录每天看到的教程。 当然，在如今的AI时代，一步步的对每个细节进行了解是非常没有必要了，只要知道大致的东西，甚至可以使用AI进行总结，我将会使用AI对每天的学习内容进行整">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式学习（一）">
<meta property="og:url" content="https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：下雨 心情：一般   嵌入式学习（一） 今天是2025年07月02日，从今天开始正式学习嵌入式相关的教程，根据我之前看到的一个很好的评论，很多东西没有记录，没有输出就代表没有学习过，从今天开始，我将和学习CPP一样，尝试来记录每天看到的教程。 当然，在如今的AI时代，一步步的对每个细节进行了解是非常没有必要了，只要知道大致的东西，甚至可以使用AI进行总结，我将会使用AI对每天的学习内容进行整">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-02T08:26:54.000Z">
<meta property="article:modified_time" content="2025-07-02T12:49:50.641Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>嵌入式学习（一）</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/07/04/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/06/13/think/%E8%BF%BD%E6%B1%82%E5%8D%93%E8%B6%8A/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&text=嵌入式学习（一）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&is_video=false&description=嵌入式学习（一）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=嵌入式学习（一）&body=Check out this article: https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&name=嵌入式学习（一）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&t=嵌入式学习（一）"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text"> 嵌入式学习（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">1.1.</span> <span class="toc-text"> 内联汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-arm-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%E6%96%B9%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. ARM 嵌入式系统汇编代码嵌入方法知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96-inline-assembly"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 1. 内联汇编 (Inline Assembly)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6-separate-assembly-files"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 2. 独立的汇编文件 (Separate Assembly Files)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AE%8F-compiler-intrinsicsmacros"><span class="toc-number">1.1.1.3.</span> <span class="toc-text"> 3. 编译器内建函数&#x2F;宏 (Compiler Intrinsics&#x2F;Macros)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%9A%84%E6%A0%BC%E5%BC%8F-gcc-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. 内联汇编的格式 (GCC 语法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97-assembler-template"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 1. 汇编指令序列 (Assembler Template)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C%E6%95%B0%E5%88%97%E8%A1%A8-output-operands"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 2. 输出操作数列表 (Output Operands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E5%88%97%E8%A1%A8-input-operands"><span class="toc-number">1.1.2.3.</span> <span class="toc-text"> 3. 输入操作数列表 (Input Operands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A0%B4%E5%9D%8F%E6%80%A7%E5%88%97%E8%A1%A8-clobber-list"><span class="toc-number">1.1.2.4.</span> <span class="toc-text"> 4. 破坏性列表 (Clobber List)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. 内联汇编的常用使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> 1. 简单的寄存器操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-c%E5%8F%98%E9%87%8F%E4%B8%8E%E6%B1%87%E7%BC%96%E4%BA%A4%E4%BA%92"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> 2. C变量与汇编交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%BB%E5%86%99%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8-sfr"><span class="toc-number">1.1.3.3.</span> <span class="toc-text"> 3. 读写特殊功能寄存器 (SFR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD-cortex-m"><span class="toc-number">1.1.3.4.</span> <span class="toc-text"> 4. 控制中断 (Cortex-M)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.1.3.5.</span> <span class="toc-text"> 5. 内存屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8D%E8%A6%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. 重要的注意事项和最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text"> 原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-arm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 1. ARM 体系结构中的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-linux-kernel"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2. 原子变量的内核操作函数 (Linux Kernel)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 3. 实现原理及对应的汇编代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 4. 知识点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text"> 同步锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 1. Linux 内核中的主要锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E-linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 2. 条件变量与 Linux 内核中的等待队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-spin_lock-%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 3. spin_lock (自旋锁)的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-mutex-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 4. mutex (互斥锁)的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 5. semaphore (信号量)的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93%E5%85%B3%E8%81%94"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 6. 总结关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lcd%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.</span> <span class="toc-text"> LCD基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lcd-%E5%B1%8F%E5%B9%95%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 1. LCD 屏幕的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B6%E8%A1%8C-rgb-%E6%8E%A5%E5%8F%A3-parallel-rgb-interface"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 1. 并行 RGB 接口 (Parallel RGB Interface)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mcu-%E6%8E%A5%E5%8F%A3-%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3-%E5%A6%82-8080-%E6%8E%A5%E5%8F%A3-6800-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> 2. MCU 接口 &#x2F; 并行总线接口 (如 8080 接口, 6800 接口)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-soc-%E9%9B%86%E6%88%90-lcd-%E6%8E%A7%E5%88%B6%E5%99%A8-%E9%AB%98%E9%80%9F%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3-%E5%A6%82-mipi-dsi-lvds-edp-hdmidp"><span class="toc-number">1.4.1.3.</span> <span class="toc-text"> 3. SoC 集成 LCD 控制器 + 高速串行接口 (如 MIPI DSI, LVDS, eDP, HDMI&#x2F;DP)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mipi-%E6%A0%87%E5%87%86"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 2. MIPI 标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81lcd-%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 3. 常见LCD 接口总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B9%B6%E8%A1%8C-rgb-%E6%8E%A5%E5%8F%A3%E5%BC%95%E8%84%9A-parallel-rgb-dpi-lcd-%E5%B9%B6%E8%A1%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 4. 并行 RGB 接口引脚 (Parallel RGB &#x2F; DPI &#x2F; LCD 并行接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8080-%E6%8E%A5%E5%8F%A3%E5%BC%95%E8%84%9A-mcu-%E6%8E%A5%E5%8F%A3-%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 5. 8080 接口引脚 (MCU 接口 &#x2F; 并行总线接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-lvds-%E6%8E%A5%E5%8F%A3%E5%BC%95%E8%84%9A-low-voltage-differential-signaling"><span class="toc-number">1.4.6.</span> <span class="toc-text"> 6. LVDS 接口引脚 (Low-Voltage Differential Signaling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-mipi-dsi-%E6%8E%A5%E5%8F%A3-display-serial-interface"><span class="toc-number">1.4.7.</span> <span class="toc-text"> 7. MIPI DSI 接口 (Display Serial Interface)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text"> 字符驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 1. 字符设备驱动程序概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 2. 字符设备驱动程序开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 3. 字符设备驱动程序用到的关键数据结构和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.1.</span> <span class="toc-text"> 关键数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.2.</span> <span class="toc-text"> 关键函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.3.3.</span> <span class="toc-text"> 示例代码框架 (伪代码)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-linux%E6%98%BE%E7%A4%BA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 4. Linux显示驱动程序介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-linux-framebuffer-fbdev-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 5. Linux Framebuffer (fbdev) 驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-fbdev-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.5.1.</span> <span class="toc-text"> 1. fbdev 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-fbdev-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.5.2.</span> <span class="toc-text"> 2. fbdev 驱动程序编写流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-fbdev-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.5.3.</span> <span class="toc-text"> 3. fbdev 涉及到的关键数据结构和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.5.5.3.1.</span> <span class="toc-text"> 关键数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.5.5.3.2.</span> <span class="toc-text"> 关键函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-fbdev-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.5.4.</span> <span class="toc-text"> 4. fbdev 驱动程序编写的简单流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%8E%B0%E4%BB%A3%E7%9A%84-drmkms-%E6%98%BE%E7%A4%BA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text"> 6. 现代的 DRM&#x2F;KMS 显示驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-drmkms-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.6.1.</span> <span class="toc-text"> 1. DRM&#x2F;KMS 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-drmkms-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B-%E9%AB%98%E5%BA%A6%E7%AE%80%E5%8C%96"><span class="toc-number">1.5.6.2.</span> <span class="toc-text"> 2. DRM&#x2F;KMS 驱动程序编写流程 (高度简化)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-drmkms-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0-%E9%83%A8%E5%88%86%E6%A0%B8%E5%BF%83"><span class="toc-number">1.5.6.3.</span> <span class="toc-text"> 3. DRM&#x2F;KMS 涉及到的关键数据结构和函数 (部分核心)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-drmkms-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.6.3.1.</span> <span class="toc-text"> 关键数据结构 (DRM&#x2F;KMS 模型)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0-drmkms"><span class="toc-number">1.5.6.3.2.</span> <span class="toc-text"> 关键函数 (DRM&#x2F;KMS)</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        嵌入式学习（一）
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-02T08:26:54.000Z" class="dt-published" itemprop="datePublished">2025-07-02</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/work/">work</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：下雨 心情：一般</p>
<hr />
<h1 id="嵌入式学习一"><a class="markdownIt-Anchor" href="#嵌入式学习一"></a> 嵌入式学习（一）</h1>
<p>今天是2025年07月02日，从今天开始正式学习嵌入式相关的教程，根据我之前看到的一个很好的评论，很多东西没有记录，没有输出就代表没有学习过，从今天开始，我将和学习CPP一样，尝试来记录每天看到的教程。</p>
<p>当然，在如今的AI时代，一步步的对每个细节进行了解是非常没有必要了，只要知道大致的东西，甚至可以使用AI进行总结，我将会使用AI对每天的学习内容进行整理总结。</p>
<h2 id="内联汇编"><a class="markdownIt-Anchor" href="#内联汇编"></a> 内联汇编</h2>
<hr />
<h3 id="1-arm-嵌入式系统汇编代码嵌入方法知识点"><a class="markdownIt-Anchor" href="#1-arm-嵌入式系统汇编代码嵌入方法知识点"></a> 1. ARM 嵌入式系统汇编代码嵌入方法知识点</h3>
<p>在 ARM 嵌入式系统开发中，有多种方法将汇编代码集成到 C/C++ 项目中，以实现性能优化、底层硬件控制或访问特定指令。主要方法包括：</p>
<h4 id="1-内联汇编-inline-assembly"><a class="markdownIt-Anchor" href="#1-内联汇编-inline-assembly"></a> 1. 内联汇编 (Inline Assembly)</h4>
<ul>
<li><strong>定义：</strong> 在 C/C++ 代码中直接嵌入汇编指令。</li>
<li><strong>语法：</strong> 编译器特定（例如 GCC 的 <code>asm</code>/<code>__asm__</code>/<code>__asm__ volatile</code>）。</li>
<li><strong>优点：</strong>
<ul>
<li>代码局部性强，与 C/C++ 逻辑紧密结合。</li>
<li>编译器可进行一定程度的上下文优化。</li>
<li>方便与 C/C++ 变量进行输入/输出交互。</li>
<li>调试时通常可显示 C/C++ 与汇编混合视图。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>编译器依赖性强，语法不易移植。</li>
<li>处理操作数、clobber 列表等细节复杂易错。</li>
<li>对于大型汇编块维护困难。</li>
</ul>
</li>
<li><strong>适用场景：</strong>
<ul>
<li>实现原子操作（如锁）。</li>
<li>性能关键的小段代码（如快速中断处理、位操作）。</li>
<li>直接访问特殊功能寄存器 (SFR)。</li>
<li>执行特定低级指令（如 <code>NOP</code>、<code>WFI</code>）。</li>
</ul>
</li>
<li><strong>示例指令：</strong> <code>cpsid i</code> (关闭中断), <code>cpsie i</code> (开启中断), <code>mrs</code> (读取特殊寄存器), <code>rbit</code> (位反转)。</li>
</ul>
<h4 id="2-独立的汇编文件-separate-assembly-files"><a class="markdownIt-Anchor" href="#2-独立的汇编文件-separate-assembly-files"></a> 2. 独立的汇编文件 (Separate Assembly Files)</h4>
<ul>
<li><strong>定义：</strong> 将汇编代码编写在 <code>.s</code> 或 <code>.S</code> 等独立文件中，编译成目标文件后与 C/C++ 目标文件链接。</li>
<li><strong>优点：</strong>
<ul>
<li>代码结构清晰，汇编与 C/C++ 模块化分离。</li>
<li>汇编器可进行专业的汇编代码优化。</li>
<li>易于独立调试，便于处理复杂汇编逻辑。</li>
<li>可使用汇编语言的完整特性（宏、条件编译等）。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>需手动遵循 ARM ABI（应用二进制接口）定义函数调用约定（参数、返回值、寄存器使用）。</li>
<li>需要额外的编译和链接步骤。</li>
<li>对于少量指令显得繁琐。</li>
</ul>
</li>
<li><strong>适用场景：</strong>
<ul>
<li><strong>启动代码 (Startup Code)：</strong> 初始化 CPU、栈、BSS 段、跳转 <code>main</code> 函数等。</li>
<li><strong>中断服务例程 (ISR) 入口/出口：</strong> 处理中断上下文切换。</li>
<li>操作系统内核的底层功能（任务切换、系统调用）。</li>
<li>需要极致性能且逻辑复杂的底层硬件驱动。</li>
</ul>
</li>
<li><strong>关键概念：</strong> <code>.global</code> (声明全局符号), <code>.thumb_func</code> (声明Thumb函数), <code>bx lr</code> (函数返回), AAPCS (ARM Architecture Procedure Call Standard)。</li>
</ul>
<h4 id="3-编译器内建函数宏-compiler-intrinsicsmacros"><a class="markdownIt-Anchor" href="#3-编译器内建函数宏-compiler-intrinsicsmacros"></a> 3. 编译器内建函数/宏 (Compiler Intrinsics/Macros)</h4>
<ul>
<li><strong>定义：</strong> 编译器（特别是针对特定 ARM 架构优化的）提供的一组特殊函数或宏，直接映射到单个或少量汇编指令。</li>
<li><strong>优点：</strong>
<ul>
<li>可移植性相对较好（在同一编译器家族内）。</li>
<li>安全性高，编译器处理底层细节，减少错误。</li>
<li>使用方便，如同调用普通 C 函数。</li>
<li>编译器可进行更优化的集成。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>功能受限于编译器预定义。</li>
<li>仍具有一定的编译器依赖性。</li>
</ul>
</li>
<li><strong>适用场景：</strong>
<ul>
<li>利用 ARM NEON/DSP 扩展指令集。</li>
<li>低级 CPU 控制（如 <code>__enable_irq()</code> / <code>__disable_irq()</code>）。</li>
<li>内存屏障（如 <code>__DMB()</code>）。</li>
<li>Cortex-M 特有指令（<code>__WFI()</code>、<code>__RBIT()</code> 等）。</li>
</ul>
</li>
<li><strong>常见头文件：</strong> <code>&lt;arm_acle.h&gt;</code> (ARM C Language Extensions)。</li>
</ul>
<hr />
<p><strong>总结与选择建议：</strong></p>
<ul>
<li><strong>首选：</strong> 如果编译器提供了相应的<strong>内建函数/宏</strong>，优先使用，因为它兼顾了性能、安全性、可读性和相对可移植性。</li>
<li><strong>次选（小段高性能代码）：</strong> 当内建函数无法满足需求，且代码量少、性能要求极高时，考虑使用<strong>内联汇编</strong>。</li>
<li><strong>次选（复杂底层模块）：</strong> 对于启动代码、操作系统内核、复杂硬件驱动等需要完全控制和独立维护的模块，使用<strong>独立的汇编文件</strong>。</li>
</ul>
<p>好的，我们来深入了解内联汇编的格式和常用的使用方法。这部分内容通常针对GCC编译器（包括ARM GCC）讲解，因为它是ARM嵌入式开发中最常用的工具链之一。</p>
<h3 id="2-内联汇编的格式-gcc-语法"><a class="markdownIt-Anchor" href="#2-内联汇编的格式-gcc-语法"></a> 2. 内联汇编的格式 (GCC 语法)</h3>
<p>GCC 的内联汇编使用 <code>asm</code> 或 <code>__asm__</code> 关键字。通常，我们会使用 <code>__asm__ volatile</code>。</p>
<ul>
<li><code>asm</code> 或 <code>__asm__</code>：表示一个汇编块。</li>
<li><code>volatile</code>：这是一个非常重要的修饰符。它告诉编译器不要对这段汇编代码进行任何优化（例如，重排、删除、合并等）。在嵌入式系统中，很多汇编操作是针对硬件的，具有副作用（Side Effect），不能被优化掉，因此几乎总是需要 <code>volatile</code>。</li>
</ul>
<p>基本的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;汇编指令序列&quot;</span></span></span><br><span class="line"><span class="params">    : 输出操作数列表      <span class="comment">/* Optional: &quot;=r&quot; (var), &quot;+m&quot; (mem) */</span></span></span><br><span class="line"><span class="params">    : 输入操作数列表      <span class="comment">/* Optional: &quot;r&quot; (var), &quot;i&quot; (const) */</span></span></span><br><span class="line"><span class="params">    : 破坏性列表          <span class="comment">/* Optional: &quot;r0&quot;, &quot;memory&quot;, &quot;cc&quot; */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>我们来逐一解释这四个部分：</p>
<h4 id="1-汇编指令序列-assembler-template"><a class="markdownIt-Anchor" href="#1-汇编指令序列-assembler-template"></a> 1. 汇编指令序列 (Assembler Template)</h4>
<ul>
<li><strong>字符串：</strong> 这部分是包含实际汇编指令的字符串。多条指令可以用分号 <code>;</code> 或换行符 <code>\n</code> 和 <code>\t</code> 分隔。</li>
<li><strong>占位符：</strong> 你可以使用 <code>%0</code>, <code>%1</code>, <code>%2</code>... 来引用操作数列表中的 C/C++ 变量。
<ul>
<li><code>%0</code> 对应第一个操作数，<code>%1</code> 对应第二个，以此类推。</li>
<li>在指令中，它们将被实际的寄存器或内存地址替换。</li>
</ul>
</li>
<li><strong>示例：</strong> <code>&quot;mov %0, #10&quot;</code> 表示将立即数10移动到由<code>%0</code>指定的寄存器中。</li>
</ul>
<h4 id="2-输出操作数列表-output-operands"><a class="markdownIt-Anchor" href="#2-输出操作数列表-output-operands"></a> 2. 输出操作数列表 (Output Operands)</h4>
<ul>
<li><strong>格式：</strong> <code>&quot;约束&quot;(变量)</code>，多个操作数用逗号 <code>,</code> 分隔。</li>
<li><strong>目的：</strong> 定义汇编代码的输出结果如何映射到 C/C++ 变量。</li>
<li><strong>约束：</strong>
<ul>
<li><code>=</code>：表示这是一个只写的输出操作数。</li>
<li><code>+</code>：表示这是一个读写操作数（既是输入又是输出）。通常用于对变量进行修改。</li>
<li><code>&amp;</code>：表示一个早期 clobber 输出操作数。它表示这个操作数在输入操作数被读入之前就会被修改。这对于某些寄存器重用优化很重要。</li>
</ul>
</li>
<li><strong>常用约束字符：</strong>
<ul>
<li><code>r</code>：表示任何通用寄存器。</li>
<li><code>m</code>：表示内存地址。</li>
<li><code>q</code>：表示四字寄存器（用于NEON）。</li>
<li><code>f</code>：表示浮点寄存器。</li>
</ul>
</li>
<li><strong>示例：</strong> <code>&quot;=r&quot; (result)</code> 表示将汇编结果放入一个通用寄存器，并将该寄存器的值赋给 C 变量 <code>result</code>。</li>
</ul>
<h4 id="3-输入操作数列表-input-operands"><a class="markdownIt-Anchor" href="#3-输入操作数列表-input-operands"></a> 3. 输入操作数列表 (Input Operands)</h4>
<ul>
<li><strong>格式：</strong> <code>&quot;约束&quot;(变量)</code>，多个操作数用逗号 <code>,</code> 分隔。</li>
<li><strong>目的：</strong> 定义 C/C++ 变量如何作为输入传递给汇编代码。</li>
<li><strong>约束：</strong>
<ul>
<li><code>r</code>：任何通用寄存器。</li>
<li><code>m</code>：内存地址。</li>
<li><code>i</code>：立即数（编译时常量）。</li>
<li><code>n</code>：立即数（针对特定的指令，如Thumb的16位指令）。</li>
<li><code>g</code>：通用（寄存器、内存或立即数）。</li>
<li><strong>数字约束 (<code>%number</code>)：</strong> 这是一个特殊的约束，表示使用与指定数字操作数相同的寄存器/内存位置。例如，<code>&quot;0&quot; (var)</code> 表示使用与第一个操作数 (<code>%0</code>) 相同的寄存器。这在输出和输入操作数是同一个变量时非常有用。</li>
</ul>
</li>
<li><strong>示例：</strong> <code>&quot;r&quot; (value)</code> 表示将 C 变量 <code>value</code> 的值放入一个通用寄存器，作为汇编指令的输入。</li>
</ul>
<h4 id="4-破坏性列表-clobber-list"><a class="markdownIt-Anchor" href="#4-破坏性列表-clobber-list"></a> 4. 破坏性列表 (Clobber List)</h4>
<ul>
<li><strong>格式：</strong> 双引号字符串，用逗号 <code>,</code> 分隔。</li>
<li><strong>目的：</strong> 告诉编译器，这段汇编代码会<strong>意外地</strong>修改（破坏）哪些寄存器或内存，而这些修改没有通过输出操作数明确声明。编译器在生成代码时会避免使用这些被破坏的寄存器，或者在使用它们之前保存/恢复它们。</li>
<li><strong>常用项：</strong>
<ul>
<li><strong>寄存器名称：</strong> <code>r0</code>, <code>r1</code>, <code>r2</code>, <code>lr</code> 等。如果你的汇编代码使用了某些寄存器但没有将其作为输入/输出操作数，就需要在这里声明。</li>
<li><code>&quot;memory&quot;</code>：<strong>极其重要</strong>。表示汇编代码可能修改了内存，而编译器无法通过 C/C++ 变量的映射来得知。这强制编译器在汇编块之前完成所有内存写入，并在之后重新从内存加载所有可能被修改的值。通常用于直接操作内存地址、DMA、或与外部设备交互的场景。</li>
<li><code>&quot;cc&quot;</code>：表示汇编代码修改了条件码寄存器 (Condition Code Register)，例如 <code>CMP</code>、<code>ADDS</code> 等指令会影响 <code>N, Z, C, V</code> 标志。如果你的汇编指令会改变条件码，且后续的 C/C++ 代码依赖于此，则需要声明。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="3-内联汇编的常用使用方法"><a class="markdownIt-Anchor" href="#3-内联汇编的常用使用方法"></a> 3. 内联汇编的常用使用方法</h3>
<p>理解了格式，我们来看看一些常用的应用场景和代码示例。</p>
<h4 id="1-简单的寄存器操作"><a class="markdownIt-Anchor" href="#1-简单的寄存器操作"></a> 1. 简单的寄存器操作</h4>
<p><strong>目标：</strong> 将一个立即数加载到某个寄存器，然后返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">load_value</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> result;</span><br><span class="line">    <span class="comment">// 将立即数 0x12345678 加载到 %0 指示的寄存器中，并将其值赋给 result</span></span><br><span class="line">    <span class="comment">// &quot;r&quot; 约束表示分配一个通用寄存器</span></span><br><span class="line">    <span class="comment">// &quot;memory&quot; 和 &quot;cc&quot; 在这里不是严格必须的，但作为良好习惯可以加上，除非你确定没有副作用。</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov %0, #0x12345678&quot;</span> <span class="comment">// ARM：mov rX, #immediate</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (result)       <span class="comment">// 输出：result 放入通用寄存器</span></span></span><br><span class="line"><span class="params">        :                     <span class="comment">// 无输入</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>      <span class="comment">// 破坏：可能影响内存和条件码</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例调用：</span></span><br><span class="line"><span class="comment">// uint32_t val = load_value(); // val 会得到 0x12345678</span></span><br></pre></td></tr></table></figure>
<h4 id="2-c变量与汇编交互"><a class="markdownIt-Anchor" href="#2-c变量与汇编交互"></a> 2. C变量与汇编交互</h4>
<p><strong>目标：</strong> 使用汇编指令对C变量进行加法操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">add_numbers</span><span class="params">(<span class="type">uint32_t</span> a, <span class="type">uint32_t</span> b)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum;</span><br><span class="line">    <span class="comment">// 将 a 和 b 相加，结果存入 sum</span></span><br><span class="line">    <span class="comment">// %0: sum (输出)</span></span><br><span class="line">    <span class="comment">// %1: a (输入)</span></span><br><span class="line">    <span class="comment">// %2: b (输入)</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;adds %0, %1, %2&quot;</span>  <span class="comment">// ARM：adds Rd, Rn, Rm (Rd = Rn + Rm)</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (sum)       <span class="comment">// 输出：sum 放入通用寄存器</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (a), <span class="string">&quot;r&quot;</span> (b) <span class="comment">// 输入：a 和 b 放入通用寄存器</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>   <span class="comment">// 破坏：可能影响内存和条件码 (因为是adds指令)</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例调用：</span></span><br><span class="line"><span class="comment">// uint32_t result = add_numbers(5, 7); // result 会得到 12</span></span><br></pre></td></tr></table></figure>
<h4 id="3-读写特殊功能寄存器-sfr"><a class="markdownIt-Anchor" href="#3-读写特殊功能寄存器-sfr"></a> 3. 读写特殊功能寄存器 (SFR)</h4>
<p><strong>目标：</strong> 读取ARM Cortex-M的MSP（主栈指针）寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_main_stack_pointer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> sp_value;</span><br><span class="line">    <span class="comment">// MRS指令：Move from System Register</span></span><br><span class="line">    <span class="comment">// 读取 MSP (Main Stack Pointer) 的值到 %0 指示的寄存器</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mrs %0, msp&quot;</span>     <span class="comment">// ARM：mrs Rd, special_register</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=r&quot;</span> (sp_value) <span class="comment">// 输出：sp_value 放入通用寄存器</span></span></span><br><span class="line"><span class="params">        :                 <span class="comment">// 无输入</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;memory&quot;</span>        <span class="comment">// 破坏：通常涉及系统状态，声明 memory 确保内存一致性</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> sp_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例调用：</span></span><br><span class="line"><span class="comment">// uint32_t current_msp = get_main_stack_pointer();</span></span><br></pre></td></tr></table></figure>
<h4 id="4-控制中断-cortex-m"><a class="markdownIt-Anchor" href="#4-控制中断-cortex-m"></a> 4. 控制中断 (Cortex-M)</h4>
<p><strong>目标：</strong> 禁用和启用中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用所有中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// CPSID I：Change Processor State, Disable Interrupts</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;cpsid i&quot;</span></span></span><br><span class="line"><span class="params">        : : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span> <span class="comment">// &quot;memory&quot; 确保在关闭中断前所有内存操作完成</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用所有中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// CPSIE I：Change Processor State, Enable Interrupts</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;cpsie i&quot;</span></span></span><br><span class="line"><span class="params">        : : : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例调用：</span></span><br><span class="line"><span class="comment">// disable_irq();</span></span><br><span class="line"><span class="comment">// // 执行中断敏感代码</span></span><br><span class="line"><span class="comment">// enable_irq();</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 对于禁用/启用中断，通常更推荐使用编译器内建函数 <code>__disable_irq()</code> 和 <code>__enable_irq()</code> (定义在 <code>&lt;arm_acle.h&gt;</code> 等)。</p>
<h4 id="5-内存屏障"><a class="markdownIt-Anchor" href="#5-内存屏障"></a> 5. 内存屏障</h4>
<p><strong>目标：</strong> 插入数据内存屏障 (DMB) 指令，确保内存操作的顺序性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">data_memory_barrier</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// DMB：Data Memory Barrier</span></span><br><span class="line">    <span class="comment">// 强制所有之前的内存访问指令完成，才能执行之后的内存访问指令</span></span><br><span class="line">    <span class="comment">// 主要用于多核、DMA 或共享内存场景</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;dmb&quot;</span></span></span><br><span class="line"><span class="params">        : : : <span class="string">&quot;memory&quot;</span> <span class="comment">// 必须声明 &quot;memory&quot;，因为它影响内存的可见性</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="comment">// volatile uint32_t shared_flag = 0;</span></span><br><span class="line"><span class="comment">// void write_flag_and_data(void) &#123;</span></span><br><span class="line"><span class="comment">//     some_data = 10; // 写入数据</span></span><br><span class="line"><span class="comment">//     data_memory_barrier(); // 确保数据写入完成</span></span><br><span class="line"><span class="comment">//     shared_flag = 1; // 再设置标志</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// void read_flag_and_data(void) &#123;</span></span><br><span class="line"><span class="comment">//     while (shared_flag == 0); // 等待标志</span></span><br><span class="line"><span class="comment">//     data_memory_barrier(); // 确保标志可见后，数据也可见</span></span><br><span class="line"><span class="comment">//     uint32_t val = some_data; // 读取数据</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 同样，对于内存屏障，更推荐使用 <code>__DMB()</code>、<code>__DSB()</code>、<code>__ISB()</code> 等编译器内建函数。</p>
<hr />
<h3 id="4-重要的注意事项和最佳实践"><a class="markdownIt-Anchor" href="#4-重要的注意事项和最佳实践"></a> 4. 重要的注意事项和最佳实践</h3>
<ol>
<li><strong><code>volatile</code> 关键字：</strong> 几乎总是使用 <code>volatile</code>。不加 <code>volatile</code> 可能会导致编译器移除或重排你的汇编代码，产生意想不到的错误。</li>
<li><strong><code>&quot;memory&quot;</code> 约束：</strong> 如果你的汇编代码直接或间接地修改了内存（比如通过指针），或者依赖于内存状态，并且编译器无法通过 C/C++ 变量的输入/输出操作数来跟踪这些修改，那么请务必在 clobber 列表中添加 <code>&quot;memory&quot;</code>。这会强制编译器在汇编块之前刷新所有缓冲的写入，并在之后重新加载所有可能缓存的内存值。</li>
<li><strong><code>&quot;cc&quot;</code> 约束：</strong> 如果你的汇编指令会改变条件码标志（如 <code>ADDS</code>, <code>SUBS</code>, <code>CMP</code> 等），并且后续的 C/C++ 代码或汇编代码可能依赖这些标志，请添加 <code>&quot;cc&quot;</code>。</li>
<li><strong>避免不必要的复杂性：</strong> 内联汇编非常强大，但也很容易出错。只有在<strong>确实需要</strong>（性能瓶颈、硬件交互、无 C/C++ 等价物）时才使用它。否则，优先使用 C/C++ 代码，或者编译器内建函数。</li>
<li><strong>阅读编译器文档：</strong> 不同的编译器（即使都是ARM GCC）在内联汇编的具体细节上可能略有差异。始终查阅您所使用的编译器版本的官方文档。</li>
<li><strong>调试：</strong> 内联汇编的调试可能比纯 C/C++ 更具挑战性。确保您熟悉汇编级别的调试工具。</li>
</ol>
<p>掌握了这些知识点和实践方法，您就能更有效地在ARM嵌入式开发中利用内联汇编了。</p>
<h2 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h2>
<hr />
<p>好的，我们来深入探讨 ARM 体系结构中的原子操作、原子变量的内核操作函数及其实现原理，并结合对应的汇编代码进行说明。</p>
<h3 id="1-arm-体系结构中的原子操作"><a class="markdownIt-Anchor" href="#1-arm-体系结构中的原子操作"></a> 1. ARM 体系结构中的原子操作</h3>
<p>在多核处理器或具有中断的单核处理器系统中，多个执行流（例如不同的CPU核心或中断处理程序与主程序）可能同时访问和修改共享变量。如果不对这些访问进行适当的同步，可能会导致数据竞争和不正确的结果。原子操作就是指那些不可中断的操作，它们要么完全执行，要么完全不执行，不会被其他操作打断。</p>
<p>ARM 架构为了支持原子操作，提供了特定的指令集。主要的原子操作指令包括：</p>
<ul>
<li><strong>独占加载/存储指令对 (Exclusive Load/Store Pair)：</strong> 这是 ARM 架构实现大多数原子操作的基础。
<ul>
<li><code>LDREX&#123;cond&#125; Rd, [Rn]</code>：<strong>独占加载 (Load Exclusive)</strong>。它从内存地址 <code>[Rn]</code> 加载数据到寄存器 <code>Rd</code>，并标记这个地址为“独占”，表示当前处理器正在关注这个内存区域。</li>
<li><code>STREX&#123;cond&#125; Rd, Rm, [Rn]</code>：<strong>独占存储 (Store Exclusive)</strong>。它尝试将寄存器 <code>Rm</code> 的数据存储到内存地址 <code>[Rn]</code>。如果这个地址的“独占”标记自上次 <code>LDREX</code> 以来没有被其他处理器或本处理器清除（意味着没有其他处理器写入这个地址，或者本处理器没有执行过会清除独占状态的操作），则存储成功，<code>Rd</code> 返回0。如果独占标记已被清除，则存储失败，<code>Rd</code> 返回非0（通常是1）。</li>
</ul>
</li>
<li><strong>内存屏障指令 (Memory Barrier Instructions)：</strong> 虽然不是直接的原子操作，但它们对于确保多核系统中的内存可见性和顺序性至关重要，常与独占指令结合使用。
<ul>
<li><code>DMB</code> (Data Memory Barrier)：数据内存屏障。确保所有在 <code>DMB</code> 之前的内存访问操作（包括加载和存储）都在 <code>DMB</code> 之后的内存访问操作之前完成。</li>
<li><code>DSB</code> (Data Synchronization Barrier)：数据同步屏障。比 <code>DMB</code> 更强，它会阻塞处理器，直到所有在 <code>DSB</code> 之前的指令（包括内存访问、缓存操作等）都完成。</li>
<li><code>ISB</code> (Instruction Synchronization Barrier)：指令同步屏障。刷新流水线，确保所有在 <code>ISB</code> 之后的指令都是从缓存或内存中重新获取的，而不是使用旧的流水线状态。</li>
</ul>
</li>
</ul>
<h3 id="2-原子变量的内核操作函数-linux-kernel"><a class="markdownIt-Anchor" href="#2-原子变量的内核操作函数-linux-kernel"></a> 2. 原子变量的内核操作函数 (Linux Kernel)</h3>
<p>在 Linux 内核中，为了方便开发者进行原子操作，提供了一系列封装好的原子变量操作函数。这些函数通常定义在 <code>&lt;asm/atomic.h&gt;</code> 或 <code>&lt;linux/atomic.h&gt;</code> 中，底层会使用上述 ARM 汇编指令实现。</p>
<p><strong>原子整数类型：</strong> <code>atomic_t</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>atomic_set(atomic_t *v, int i)</code></td>
<td style="text-align:left">设置原子变量 <code>v</code> 的值为 <code>i</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_read(atomic_t *v)</code></td>
<td style="text-align:left">读取原子变量 <code>v</code> 的值。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_add(int i, atomic_t *v)</code></td>
<td style="text-align:left">将 <code>i</code> 加到原子变量 <code>v</code> 上。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_sub(int i, atomic_t *v)</code></td>
<td style="text-align:left">从原子变量 <code>v</code> 中减去 <code>i</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_inc(atomic_t *v)</code></td>
<td style="text-align:left">原子变量 <code>v</code> 自增1。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_dec(atomic_t *v)</code></td>
<td style="text-align:left">原子变量 <code>v</code> 自减1。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_add_return(int i, atomic_t *v)</code></td>
<td style="text-align:left">将 <code>i</code> 加到 <code>v</code> 上，并返回新值。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_sub_return(int i, atomic_t *v)</code></td>
<td style="text-align:left">从 <code>v</code> 中减去 <code>i</code>，并返回新值。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_inc_and_test(atomic_t *v)</code></td>
<td style="text-align:left"><code>v</code> 自增1，如果新值为0则返回true。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_dec_and_test(atomic_t *v)</code></td>
<td style="text-align:left"><code>v</code> 自减1，如果新值为0则返回true。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_add_unless(atomic_t *v, int i, int u)</code></td>
<td style="text-align:left">如果 <code>v</code> 不等于 <code>u</code>，则 <code>v += i</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>atomic_cmpxchg(atomic_t *v, int old, int new)</code></td>
<td style="text-align:left"><strong>比较并交换 (Compare and Exchange)</strong>。如果 <code>v</code> 的当前值等于 <code>old</code>，则将 <code>v</code> 设置为 <code>new</code>，并返回 <code>old</code>；否则返回 <code>v</code> 的当前值。这是实现自旋锁等更复杂同步机制的基础。</td>
</tr>
</tbody>
</table>
<p><strong>原子位操作类型：</strong> (通常直接对 <code>unsigned long</code> 类型进行操作)</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>test_and_set_bit(nr, addr)</code></td>
<td style="text-align:left">原子设置 <code>addr</code> 地址的第 <code>nr</code> 位，并返回旧值。</td>
</tr>
<tr>
<td style="text-align:left"><code>test_and_clear_bit(nr, addr)</code></td>
<td style="text-align:left">原子清除 <code>addr</code> 地址的第 <code>nr</code> 位，并返回旧值。</td>
</tr>
<tr>
<td style="text-align:left"><code>test_and_change_bit(nr, addr)</code></td>
<td style="text-align:left">原子翻转 <code>addr</code> 地址的第 <code>nr</code> 位，并返回旧值。</td>
</tr>
</tbody>
</table>
<h3 id="3-实现原理及对应的汇编代码"><a class="markdownIt-Anchor" href="#3-实现原理及对应的汇编代码"></a> 3. 实现原理及对应的汇编代码</h3>
<p>大多数原子操作（除了简单的读写）都是通过 <strong>独占加载/存储循环 (Load-Exclusive/Store-Exclusive Loop)</strong> 配合内存屏障来实现的。这种模式也被称为 <strong>LL/SC (Load-Link / Store-Conditional)</strong> 或 <strong>乐观锁</strong>。</p>
<p><strong>实现原理：</strong></p>
<ol>
<li><strong>加载独占 (LDREX)：</strong> 首先使用 <code>LDREX</code> 指令从内存加载共享变量的当前值。这会标记该内存地址为“独占监视”，表示当前处理器正在独占地关注这个地址。</li>
<li><strong>执行操作：</strong> 在加载的值上执行所需的算术或逻辑操作（例如，加1、减1、比较等）。这个操作是在本地寄存器中进行的，不会影响内存。</li>
<li><strong>尝试存储独占 (STREX)：</strong> 尝试使用 <code>STREX</code> 指令将修改后的值写回内存。
<ul>
<li><strong>成功：</strong> 如果 <code>STREX</code> 成功（即 <code>Rd</code> 返回0），说明在 <code>LDREX</code> 和 <code>STREX</code> 之间没有其他处理器或本处理器破坏独占状态（即没有其他执行流修改该内存），则操作完成，可以退出循环。</li>
<li><strong>失败：</strong> 如果 <code>STREX</code> 失败（即 <code>Rd</code> 返回非0），说明在 <code>LDREX</code> 和 <code>STREX</code> 之间该内存地址已被其他执行流修改，或者独占状态被清除，当前操作无效。此时，需要重新回到步骤1，再次执行 <code>LDREX</code>，重试整个操作，直到成功。</li>
</ul>
</li>
<li><strong>内存屏障 (DMB)：</strong> 在 <code>LDREX</code> 和 <code>STREX</code> 循环的外部，通常会配合 <code>DMB</code> 指令，以确保所有内存访问的顺序性和可见性，特别是在多核处理器或编译器优化可能导致指令重排的情况下。</li>
</ol>
<p><strong>汇编代码示例 (以 <code>atomic_inc</code> 为例，简化版)：</strong></p>
<p>假设我们有一个 <code>atomic_t *v</code> 类型的原子变量，它的底层是一个 <code>int</code> 或 <code>long</code> 类型的值。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; atomic_inc(atomic_t *v) 的大致汇编实现</span></span><br><span class="line"><span class="comment">; r0 寄存器作为输入参数，指向 atomic_t 结构体的地址</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">atomic_inc:</span></span><br><span class="line">    <span class="keyword">dmb</span>                 <span class="comment">; 内存屏障：确保之前的内存操作都已完成</span></span><br><span class="line"><span class="symbol">.L_loop:</span></span><br><span class="line">    ldrex   <span class="built_in">r1</span>, [<span class="built_in">r0</span>]    <span class="comment">; 1. 独占加载原子变量的当前值到 r1</span></span><br><span class="line">    <span class="keyword">adds</span>    <span class="built_in">r1</span>, <span class="built_in">r1</span>, <span class="number">#1</span>  <span class="comment">; 2. 将 r1 的值加 1</span></span><br><span class="line">    <span class="keyword">strex</span>   <span class="built_in">r2</span>, <span class="built_in">r1</span>, [<span class="built_in">r0</span>] <span class="comment">; 3. 尝试独占存储新值到内存，结果存入 r2</span></span><br><span class="line">    <span class="keyword">cmp</span>     <span class="built_in">r2</span>, <span class="number">#0</span>      <span class="comment">; 检查 strex 是否成功 (r2 == 0)</span></span><br><span class="line">    <span class="keyword">bne</span>     .L_loop     <span class="comment">; 如果失败 (r2 != 0)，则跳转到 .L_loop 重新尝试</span></span><br><span class="line">    <span class="keyword">dmb</span>                 <span class="comment">; 内存屏障：确保本次原子操作的写入在后续操作之前可见</span></span><br><span class="line">    <span class="keyword">bx</span>      <span class="built_in">lr</span>          <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>
<p><strong>汇编代码示例 (以 <code>atomic_cmpxchg</code> 为例，简化版)：</strong></p>
<p><code>atomic_cmpxchg(atomic_t *v, int old_val, int new_val)</code></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; atomic_cmpxchg(atomic_t *v, int old_val, int new_val) 的大致汇编实现</span></span><br><span class="line"><span class="comment">; r0: *v (地址)</span></span><br><span class="line"><span class="comment">; r1: old_val</span></span><br><span class="line"><span class="comment">; r2: new_val</span></span><br><span class="line"><span class="comment">; 返回值在 r0 (旧值)</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">atomic_cmpxchg:</span></span><br><span class="line">    <span class="keyword">dmb</span>                     <span class="comment">; 内存屏障</span></span><br><span class="line"><span class="symbol">.L_cmpxchg_loop:</span></span><br><span class="line">    ldrex   <span class="built_in">r3</span>, [<span class="built_in">r0</span>]        <span class="comment">; 1. 独占加载当前值到 r3</span></span><br><span class="line">    <span class="keyword">cmp</span>     <span class="built_in">r3</span>, <span class="built_in">r1</span>          <span class="comment">; 2. 比较当前值 (r3) 是否等于 old_val (r1)</span></span><br><span class="line">    <span class="keyword">bne</span>     .L_cmpxchg_fail <span class="comment">; 如果不相等，跳到失败分支 (不进行存储)</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">strex</span>   <span class="built_in">r4</span>, <span class="built_in">r2</span>, [<span class="built_in">r0</span>]    <span class="comment">; 3. 如果相等，尝试独占存储 new_val (r2) 到内存</span></span><br><span class="line">    <span class="keyword">cmp</span>     <span class="built_in">r4</span>, <span class="number">#0</span>          <span class="comment">; 检查 strex 是否成功 (r4 == 0)</span></span><br><span class="line">    <span class="keyword">bne</span>     .L_cmpxchg_loop <span class="comment">; 如果失败 (被其他核修改了)，则跳转到 .L_cmpxchg_loop 重新尝试</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.L_cmpxchg_success:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r3</span>          <span class="comment">; 成功，将旧值 (r3) 作为返回值</span></span><br><span class="line">    <span class="keyword">dmb</span>                     <span class="comment">; 内存屏障</span></span><br><span class="line">    <span class="keyword">bx</span>      <span class="built_in">lr</span>              <span class="comment">; 返回</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.L_cmpxchg_fail:</span></span><br><span class="line">    <span class="keyword">clrex</span>                   <span class="comment">; 清除当前处理器的独占状态，避免死锁或不必要的独占冲突</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r3</span>          <span class="comment">; 将当前值 (r3) 作为返回值</span></span><br><span class="line">    <span class="keyword">dmb</span>                     <span class="comment">; 内存屏障</span></span><br><span class="line">    <span class="keyword">bx</span>      <span class="built_in">lr</span>              <span class="comment">; 返回</span></span><br></pre></td></tr></table></figure>
<p><strong><code>clrex</code> 指令：</strong> 在 <code>atomic_cmpxchg</code> 的失败路径中，<code>clrex</code> 是重要的。如果 <code>ldrex</code> 加载的值不等于 <code>old_val</code>，那么就不会执行 <code>strex</code>。此时独占状态仍然存在，为了避免阻塞其他处理器或后续操作，需要显式地清除独占状态。</p>
<hr />
<h3 id="4-知识点总结"><a class="markdownIt-Anchor" href="#4-知识点总结"></a> 4. 知识点总结</h3>
<ol>
<li>
<p><strong>ARM 原子操作核心：</strong></p>
<ul>
<li><strong>独占加载/存储指令对 (<code>LDREX</code>/<code>STREX</code>)</strong> 是 ARM 实现无锁原子操作的基础。</li>
<li><code>LDREX</code> 标记内存为独占，<code>STREX</code> 检查独占标记是否被破坏，并决定存储是否成功。</li>
<li><strong>内存屏障 (<code>DMB</code>/<code>DSB</code>/<code>ISB</code>)</strong> 确保多处理器环境下的内存顺序性和可见性。</li>
</ul>
</li>
<li>
<p><strong>原子操作的实现原理：独占加载/存储循环 (LL/SC)</strong></p>
<ul>
<li>这是一个<strong>乐观并发控制</strong>机制。</li>
<li><strong>步骤：</strong>
<ol>
<li><code>LDREX</code> 读入当前值。</li>
<li>在寄存器中对值进行修改。</li>
<li><code>STREX</code> 尝试写回新值。</li>
<li>如果 <code>STREX</code> 失败，则说明有冲突，<strong>循环重试</strong>整个过程，直到成功。</li>
</ol>
</li>
<li>这种机制保证了在<strong>单次成功存储</strong>发生时，操作是原子性的。</li>
</ul>
</li>
<li>
<p><strong>Linux 内核原子API：</strong></p>
<ul>
<li>提供高级抽象层 <code>atomic_t</code> 类型和一系列函数（如 <code>atomic_add</code>, <code>atomic_inc</code>, <code>atomic_cmpxchg</code> 等）。</li>
<li>这些函数在底层使用 <code>LDREX</code>/<code>STREX</code> 循环和内存屏障指令实现，简化了驱动和内核开发中的并发控制。</li>
<li><code>atomic_cmpxchg</code>（比较并交换）是实现更复杂同步原语（如自旋锁、信号量）的关键原子操作。</li>
</ul>
</li>
<li>
<p><strong><code>volatile</code> 关键字和内存屏障的重要性：</strong></p>
<ul>
<li>在 C/C++ 代码中使用原子变量时，应声明为 <code>volatile atomic_t</code>，以防止编译器过度优化。</li>
<li>原子操作函数内部通常会包含 <code>DMB</code> 等内存屏障，以确保操作的内存可见性，防止指令重排导致的并发问题。</li>
</ul>
</li>
</ol>
<p>理解这些概念对于进行高性能、高可靠性的 ARM 嵌入式系统开发至关重要，特别是在涉及多线程、中断或多核并发的场景下。</p>
<h2 id="同步锁"><a class="markdownIt-Anchor" href="#同步锁"></a> 同步锁</h2>
<hr />
<h3 id="1-linux-内核中的主要锁机制"><a class="markdownIt-Anchor" href="#1-linux-内核中的主要锁机制"></a> 1. Linux 内核中的主要锁机制</h3>
<p>Linux 内核提供了多种锁机制，每种都有其特定的设计目的和适用场景。选择正确的锁是确保并发程序正确性和高性能的关键。</p>
<p><strong>核心思想：根据临界区特性（长度、是否允许睡眠、读写模式等）选择最合适的锁。</strong></p>
<ol>
<li><strong>自旋锁 (Spinlock)：</strong>
<ul>
<li><strong>特点：</strong> 忙等待，不允许睡眠，极短临界区。</li>
<li><strong>适用：</strong> 中断上下文、短时间独占访问。</li>
</ul>
</li>
<li><strong>信号量 (Semaphore)：</strong>
<ul>
<li><strong>特点：</strong> 允许睡眠，可计数，可作互斥量。</li>
<li><strong>适用：</strong> 较长临界区、资源计数、进程/线程间同步互斥。</li>
</ul>
</li>
<li><strong>互斥锁 (Mutex)：</strong>
<ul>
<li><strong>特点：</strong> 信号量特例，只提供独占互斥，允许睡眠。</li>
<li><strong>适用：</strong> 线程/进程间独占访问共享资源。</li>
</ul>
</li>
<li><strong>读写锁 (Reader-Writer Lock)：</strong>
<ul>
<li><strong>特点：</strong> 允许多个读者并行，写者独占。</li>
<li><strong>适用：</strong> 读多写少、追求高并发读的场景。</li>
</ul>
</li>
<li><strong>完成变量 (Completion Variable)：</strong>
<ul>
<li><strong>特点：</strong> 简单事件通知机制，一个线程等待另一个线程完成。</li>
<li><strong>适用：</strong> 异步操作完成通知、父子线程简单同步。</li>
</ul>
</li>
<li><strong>顺序锁 (Seqlock)：</strong>
<ul>
<li><strong>特点：</strong> 读写并行，读者可能需要重试，写操作不阻塞读者。</li>
<li><strong>适用：</strong> 写操作非常少但影响多字段、读操作频繁且对延迟敏感但可容忍重试。</li>
</ul>
</li>
<li><strong>RCU (Read-Copy Update)：</strong>
<ul>
<li><strong>特点：</strong> 读者无锁并行，写者通过复制-修改-更新指针，旧数据延迟回收。</li>
<li><strong>适用：</strong> 极高并发读、数据更新不频繁的场景。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="2-条件变量与-linux-内核中的等待队列"><a class="markdownIt-Anchor" href="#2-条件变量与-linux-内核中的等待队列"></a> 2. 条件变量与 Linux 内核中的等待队列</h3>
<p>条件变量是一种高级同步原语，用于线程之间<strong>基于特定条件</strong>进行等待和通知。在 Linux 内核中，其功能主要通过<strong>等待队列 (Wait Queue)</strong> 机制与<strong>互斥锁/自旋锁</strong>结合实现。</p>
<p><strong>核心思想：条件变量解决“什么时候可以访问”的问题，依赖互斥锁解决“谁能访问”的问题。</strong></p>
<ul>
<li><strong>条件变量的本质：</strong> 允许线程在某个<strong>业务条件</strong>不满足时安全地进入睡眠状态，直到该条件被其他线程满足并通知。</li>
<li><strong>为何与互斥锁配合：</strong> 必须使用互斥锁（或自旋锁）来保护共享条件的检查和修改过程，防止<strong>竞态条件</strong>（如“丢失的唤醒”）的发生。
<ul>
<li><strong>等待者：</strong> 在获取互斥锁后检查条件，若不满足，则释放锁并睡眠在等待队列上。被唤醒后重新获取锁并再次检查。</li>
<li><strong>通知者：</strong> 在获取互斥锁后修改条件，然后唤醒等待队列上的一个或所有线程，最后释放锁。</li>
</ul>
</li>
<li><strong>Linux 内核实现：</strong>
<ul>
<li>没有独立的用户空间 <code>pthread_cond_t</code> 结构。</li>
<li>其功能由<strong>等待队列 (Wait Queue)</strong> 及其相关的 API（如 <code>wait_event*</code>、<code>wake_up*</code>）实现。</li>
<li>这些 API 内部会处理锁的释放和重新获取，确保原子性。</li>
</ul>
</li>
<li><strong>适用场景：</strong>
<ul>
<li><strong>资源可用性等待：</strong> 生产者-消费者模型中等待数据可用。</li>
<li><strong>事件通知：</strong> 等待某个特定事件的发生。</li>
<li><strong>复杂同步：</strong> 当线程需要等待共享状态满足复杂条件时。</li>
</ul>
</li>
</ul>
<p><strong>区别与联系：</strong></p>
<ul>
<li><strong>互斥锁/信号量</strong>提供的是<strong>互斥访问</strong>和<strong>资源数量控制</strong>，当锁被占用或资源耗尽时阻塞。它们不知道阻塞的具体“业务条件”。</li>
<li><strong>条件变量</strong>提供的是<strong>基于条件判断的阻塞与唤醒</strong>，它本身不提供互斥，必须与互斥锁协同工作，以安全地管理和判断共享条件。</li>
</ul>
<h3 id="3-spin_lock-自旋锁的实现"><a class="markdownIt-Anchor" href="#3-spin_lock-自旋锁的实现"></a> 3. <code>spin_lock</code> (自旋锁)的实现</h3>
<ul>
<li><strong>特点：</strong> 忙等待 (busy-waiting)，适用于临界区很短、不允许睡眠的场景。</li>
<li><strong>基本实现原理：</strong>
<ul>
<li>自旋锁的本质是一个<strong>状态变量</strong>（通常是 <code>0</code> 表示未锁定，<code>1</code> 表示已锁定）。</li>
<li><strong>加锁 (<code>spin_lock</code>)：</strong> 线程会<strong>原子地尝试将这个状态变量从 <code>0</code> 设置为 <code>1</code></strong>。
<ul>
<li>如果设置成功（即之前是 <code>0</code>），说明获取到锁，进入临界区。</li>
<li>如果设置失败（即之前是 <code>1</code>），说明锁已被占用，线程会进入一个<strong>循环</strong>，不断地<strong>原子地尝试设置</strong>，直到成功为止（这就是“自旋”）。</li>
</ul>
</li>
<li><strong>解锁 (<code>spin_unlock</code>)：</strong> 线程会<strong>原子地将状态变量从 <code>1</code> 设置回 <code>0</code></strong>，表示锁已释放。</li>
<li><strong>原子操作：</strong> 这通常通过处理器提供的<strong>原子交换 (atomic exchange)</strong>、<strong>比较并交换 (Compare-And-Swap, CAS)</strong> 或<strong>测试并设置 (Test-And-Set)</strong> 等指令来实现。这些指令确保了读取、修改、写入变量是一个不可中断的操作。</li>
<li><strong>中断处理：</strong> 在单核系统中，为了防止中断打断持有自旋锁的临界区，自旋锁通常还会禁用当前CPU的中断。在多核系统中，还会涉及内存屏障来保证内存顺序。</li>
</ul>
</li>
</ul>
<h3 id="4-mutex-互斥锁的实现"><a class="markdownIt-Anchor" href="#4-mutex-互斥锁的实现"></a> 4. <code>mutex</code> (互斥锁)的实现</h3>
<ul>
<li><strong>特点：</strong> 允许睡眠，适用于临界区较长、线程可以睡眠等待的场景。</li>
<li><strong>基本实现原理：</strong>
<ul>
<li>互斥锁同样有一个<strong>状态变量</strong>（比如 <code>0</code> 表示未锁定，<code>1</code> 表示已锁定）。</li>
<li><strong>加锁 (<code>mutex_lock</code>)：</strong>
<ul>
<li>线程会<strong>原子地尝试将状态变量从 <code>0</code> 设置为 <code>1</code></strong>。</li>
<li>如果成功，获取到锁。</li>
<li>如果失败（锁已被占用），当前线程不会自旋，而是会<strong>将自己添加到互斥锁内部维护的一个等待队列中，然后进入睡眠状态 (TASK_UNINTERRUPTIBLE/TASK_INTERRUPTIBLE)</strong>。操作系统调度器会将 CPU 分配给其他可运行的线程。</li>
</ul>
</li>
<li><strong>解锁 (<code>mutex_unlock</code>)：</strong>
<ul>
<li>线程会<strong>原子地将状态变量从 <code>1</code> 设置回 <code>0</code></strong>。</li>
<li>如果等待队列中有线程在等待，会<strong>唤醒</strong>队列中的一个（或多个，具体取决于实现）等待线程，使其变为可运行状态。</li>
</ul>
</li>
<li><strong>原子操作与等待队列：</strong> 互斥锁的实现结合了原子操作（用于状态变量的改变）和<strong>等待队列</strong>（用于管理和调度那些因锁被占用而睡眠的线程）。<code>mutex</code> 的原子操作确保了对锁状态的判断和修改是安全的，而等待队列则实现了当锁不可用时的有效调度。</li>
</ul>
</li>
</ul>
<h3 id="5-semaphore-信号量的实现"><a class="markdownIt-Anchor" href="#5-semaphore-信号量的实现"></a> 5. <code>semaphore</code> (信号量)的实现</h3>
<ul>
<li><strong>特点：</strong> 允许睡眠，可计数，用于资源计数或更通用的事件同步。</li>
<li><strong>基本实现原理：</strong>
<ul>
<li>信号量有一个<strong>内部计数器</strong>（<code>count</code>），初始化为某个正整数（表示可用资源数量或允许的并发数）。</li>
<li><strong>P 操作 / <code>down()</code> (获取资源/减计数)：</strong>
<ul>
<li>线程会<strong>原子地检查计数器</strong>。</li>
<li>如果计数器<strong>大于 0</strong>，线程会<strong>原子地将计数器减 1</strong>，然后获取资源，继续执行。</li>
<li>如果计数器<strong>等于 0</strong>，说明资源已耗尽，线程会将自己<strong>添加到信号量内部的等待队列中，然后进入睡眠状态</strong>。</li>
</ul>
</li>
<li><strong>V 操作 / <code>up()</code> (释放资源/增计数)：</strong>
<ul>
<li>线程会<strong>原子地将计数器加 1</strong>。</li>
<li>如果等待队列中有线程在等待（因为计数器曾为0），会<strong>唤醒</strong>队列中的一个（或多个）等待线程。</li>
</ul>
</li>
<li><strong>原子操作与等待队列：</strong> 信号量的实现同样依赖于<strong>原子操作</strong>（对计数器的读取、递增、递减必须是原子的）和<strong>等待队列</strong>（用于管理因计数器为0而阻塞的线程）。原子操作确保了计数器的正确性，等待队列则实现了线程的有效阻塞和唤醒。</li>
</ul>
</li>
</ul>
<h3 id="6-总结关联"><a class="markdownIt-Anchor" href="#6-总结关联"></a> 6. 总结关联</h3>
<ul>
<li><strong>原子操作是基础：</strong> 无论是自旋锁的忙等待，还是互斥锁和信号量的睡眠等待，它们在改变和检查锁/计数器状态时，都必须依赖底层的<strong>原子操作</strong>（如 <code>atomic_inc</code>、<code>atomic_dec</code>、<code>cmpxchg</code> 等），以防止多个 CPU 同时修改同一变量导致数据损坏或逻辑错误。</li>
<li><strong>效率与场景：</strong>
<ul>
<li><code>spin_lock</code> 因为忙等待，在锁竞争激烈或临界区长时效率低下，但它<strong>不涉及上下文切换</strong>，因此在短临界区和不允许睡眠的上下文（如中断处理程序）中非常高效。</li>
<li><code>mutex</code> 和 <code>semaphore</code> 因为允许睡眠，在锁竞争激烈或临界区长时效率更高，因为它们会<strong>触发上下文切换</strong>，让出 CPU 给其他线程运行，而不是浪费 CPU 周期自旋。但上下文切换本身是有开销的。</li>
</ul>
</li>
</ul>
<h2 id="lcd基本知识"><a class="markdownIt-Anchor" href="#lcd基本知识"></a> LCD基本知识</h2>
<h3 id="1-lcd-屏幕的种类"><a class="markdownIt-Anchor" href="#1-lcd-屏幕的种类"></a> 1. LCD 屏幕的种类</h3>
<p>LCD 屏幕与主控芯片（MCU/SoC）的连接方式主要围绕<strong>数据传输效率</strong>和<strong>显存的存放位置</strong>展开，这直接影响了屏幕的成本、尺寸、功耗和显示性能。</p>
<p>根据显存的托管方式和数据传输协议，我们可以将常见的 LCD 接口分为三大类：</p>
<hr />
<h4 id="1-并行-rgb-接口-parallel-rgb-interface"><a class="markdownIt-Anchor" href="#1-并行-rgb-接口-parallel-rgb-interface"></a> 1. 并行 RGB 接口 (Parallel RGB Interface)</h4>
<ul>
<li><strong>显存位置：</strong> <strong>主控芯片（SoC）的外部 DDR SDRAM</strong>。LCD 屏内部通常只含有极小的缓冲，不存储完整的帧数据。</li>
<li><strong>数据传输：</strong>
<ul>
<li><strong>流式传输：</strong> SoC 的显示控制器直接从其外部 DDR 读取像素数据，并通过 <strong>独立的 R/G/B 数据线（18 或 24 位）</strong> 将像素流连续、同步地推送到 LCD 屏。</li>
<li><strong>时序信号：</strong> 配合 <strong>像素时钟 (PCLK)</strong>、<strong>水平同步 (HSYNC)</strong>、<strong>垂直同步 (VSYNC)</strong> 和 <strong>数据使能 (DE)</strong> 等信号进行严格的时序控制。</li>
<li><strong>无地址线：</strong> 这种接口<strong>不使用独立的地址线</strong>。像素数据按固定的扫描顺序（从左到右，从上到下）发送，LCD 内部的驱动芯片通过同步信号自动定位。</li>
</ul>
</li>
<li><strong>特点：</strong>
<ul>
<li><strong>优点：</strong> 结构简单，数据传输效率高，易于驱动中、大尺寸高分辨率屏幕。成本相对较低（屏幕本身），但要求 SoC 具备强大的并行 RGB 接口和充足的外部 DDR。</li>
<li><strong>缺点：</strong> 需要较多的数据引脚，布线复杂，抗干扰能力一般。主控芯片负担较重。</li>
<li><strong>适用场景：</strong> 早期中高端嵌入式设备、工业控制、车载信息娱乐系统等。</li>
</ul>
</li>
</ul>
<hr />
<h4 id="2-mcu-接口-并行总线接口-如-8080-接口-6800-接口"><a class="markdownIt-Anchor" href="#2-mcu-接口-并行总线接口-如-8080-接口-6800-接口"></a> 2. MCU 接口 / 并行总线接口 (如 8080 接口, 6800 接口)</h4>
<ul>
<li><strong>显存位置：</strong> <strong>LCD 屏幕内部集成的 SRAM</strong>（在显示驱动芯片 DDIC 内部）。</li>
<li><strong>数据传输：</strong>
<ul>
<li><strong>总线通信：</strong> 通过**并行数据线（8 位或 16 位）**和少量控制线（如 <code>RS/DC</code> [命令/数据选择]、<code>CS</code> [片选]、<code>WR</code> [写]、<code>RD</code> [读]）进行通信。</li>
<li><strong>命令/数据模式：</strong> <code>RS/DC</code> 引脚用于指示当前传输的是<strong>命令</strong>（配置寄存器）还是<strong>像素数据</strong>（写入内部显存）。</li>
<li><strong>间接访问：</strong> 主控芯片（MCU）需要发送命令来设置显示区域、地址指针，然后才能写入像素数据。一旦数据写入内部显存，DDIC 会独立刷新显示。</li>
<li><strong>无独立地址线：</strong> 通常通过命令和内部指针来管理显存地址，无需外部提供独立的地址线。</li>
</ul>
</li>
<li><strong>特点：</strong>
<ul>
<li><strong>优点：</strong> 简化了主控芯片的负担（无需承担显存和复杂的时序控制），引脚数量相对 RGB 接口较少。</li>
<li><strong>缺点：</strong> <strong>内部 SRAM 成本高且容量有限</strong>，严重限制了屏幕的<strong>最大分辨率和颜色深度</strong>。数据传输速度相对较慢（需要总线操作）。</li>
<li><strong>适用场景：</strong> 小尺寸、低分辨率的屏幕，如功能手机、小型HMI、物联网设备、智能家电等，对成本和功耗敏感的应用。</li>
</ul>
</li>
</ul>
<hr />
<h4 id="3-soc-集成-lcd-控制器-高速串行接口-如-mipi-dsi-lvds-edp-hdmidp"><a class="markdownIt-Anchor" href="#3-soc-集成-lcd-控制器-高速串行接口-如-mipi-dsi-lvds-edp-hdmidp"></a> 3. SoC 集成 LCD 控制器 + 高速串行接口 (如 MIPI DSI, LVDS, eDP, HDMI/DP)</h4>
<ul>
<li><strong>显存位置：</strong> <strong>主控芯片（SoC）的外部 DDR SDRAM</strong>。</li>
<li><strong>数据传输：</strong>
<ul>
<li><strong>高速串行：</strong> SoC 内部的专用显示控制器从外部 DDR 读取帧数据，并将其转换为高速串行差分信号（MIPI DSI、LVDS、eDP 等）或标准协议信号（HDMI/DP）传输给屏幕。</li>
<li><strong>高度集成：</strong> 包含了复杂的时序生成、色彩空间转换、多层叠加（Plane）等功能。</li>
<li><strong>总线/通道：</strong> 不同于简单的并行线，这些接口通常通过差分对或多条通道进行高速数据传输，抗干扰能力强。</li>
</ul>
</li>
<li><strong>特点：</strong>
<ul>
<li><strong>优点：</strong> 支持<strong>高分辨率、高刷新率、高颜色深度</strong>。引脚数量远少于并行 RGB 接口，布线简单，抗干扰能力强。通常具备硬件加速、电源管理等高级特性。</li>
<li><strong>缺点：</strong> SoC 本身成本较高，系统设计复杂（需要管理高速信号、DDR、电源）。</li>
<li><strong>适用场景：</strong> 现代智能手机、平板电脑、笔记本电脑、智能电视、高性能嵌入式设备、高端车载系统等。<strong>这是当前主流的高性能显示方案。</strong></li>
</ul>
</li>
</ul>
<h3 id="2-mipi-标准"><a class="markdownIt-Anchor" href="#2-mipi-标准"></a> 2. MIPI 标准</h3>
<p><strong>MIPI (Mobile Industry Processor Interface) 联盟</strong> 是一个致力于为移动和相关设备定义和推广开放标准接口规范的全球性组织。其核心目标是提供<strong>统一、高性能、低功耗、低 EMI 的串行接口</strong>，以解决传统并行接口的诸多问题，并加速移动产业发展。</p>
<p><strong>MIPI 体系的构成：</strong></p>
<p>MIPI 标准是一个<strong>模块化、分层</strong>的设计。通常由一个<strong>物理层 (Physical Layer)</strong> 和一个或多个<strong>协议层 (Protocol Layer)</strong> 组成。</p>
<ol>
<li>
<p><strong>MIPI 物理层 (Physical Layer):</strong></p>
<ul>
<li><strong>D-PHY (Differential PHY):</strong> 最常用且成熟的物理层，采用差分信号，支持高速数据和低功耗控制。是 DSI 和 CSI-2 的主要基础。</li>
<li><strong>C-PHY (Compact PHY):</strong> 更高效的物理层，采用三相信号和嵌入式时钟，提供更高带宽效率和更低功耗，是DSI和CSI-2未来的发展方向。</li>
<li><strong>M-PHY (Multi-Lane PHY):</strong> 更高性能的物理层，支持极高带宽，主要用于存储 (UFS) 和其他需要超高速度的应用。</li>
</ul>
</li>
<li>
<p><strong>MIPI 协议层 (Protocol Layer) / 应用接口:</strong></p>
<ul>
<li><strong>MIPI DSI (Display Serial Interface):</strong> <strong>显示屏接口</strong>。用于 SoC 到 LCD/OLED 显示面板。</li>
<li><strong>MIPI CSI-2 (Camera Serial Interface 2):</strong> <strong>摄像头接口</strong>。用于图像传感器到 SoC 的 ISP。</li>
<li><strong>MIPI RFFE (RF Front-End Control Interface):</strong> <strong>射频前端控制接口</strong>。用于 SoC 控制无线通信的射频组件。</li>
<li><strong>MIPI I3C (Improved Inter-Integrated Circuit):</strong> <strong>传感器/低速外设接口</strong>。旨在取代/增强 I2C/SPI，兼具高速和低功耗。</li>
<li><strong>MIPI SoundWire:</strong> <strong>音频接口</strong>。用于音频编解码器与处理器之间的数字音频传输。</li>
<li><strong>MIPI UniPro (Unified Protocol):</strong> <strong>通用分层协议</strong>。作为 M-PHY/C-PHY 之上的高层协议，支持可靠传输，是 UFS 的基础。</li>
<li><strong>MIPI UFS (Universal Flash Storage):</strong> <strong>高性能闪存接口</strong>。基于 UniPro 和 M-PHY，是取代 eMMC 的新一代移动存储标准。</li>
</ul>
</li>
</ol>
<p><strong>总结性思考：</strong></p>
<p>在进行嵌入式系统开发时，选择合适的 LCD 接口至关重要。</p>
<ul>
<li>对于<strong>简单、低成本、对性能要求不高</strong>的项目，并行 RGB 或 8080 接口可能足够。</li>
<li>对于<strong>中等分辨率、需要一定抗干扰能力和传输距离</strong>的项目，LVDS 是一个不错的选择。</li>
<li>对于<strong>高性能、高分辨率、低功耗、体积受限</strong>的移动或高端嵌入式设备，<strong>MIPI DSI 接口</strong>无疑是首选。</li>
</ul>
<p>MIPI 联盟通过其一系列规范，为移动和嵌入式设备内部的高效、可靠通信奠定了基础，极大地简化了系统设计，并推动了整个行业的技术进步。理解这些接口的原理和适用性，将使你在嵌入式系统开发中做出更明智的技术选型。</p>
<h3 id="3-常见lcd-接口总结"><a class="markdownIt-Anchor" href="#3-常见lcd-接口总结"></a> 3. 常见LCD 接口总结</h3>
<p>在嵌入式系统中，连接处理器和 LCD 显示面板的接口种类繁多，各有其特点和适用场景。我们可以将其大致分为几类：</p>
<ol>
<li>
<p><strong>并行 RGB (Parallel RGB / DPI / LCD 并行接口)</strong></p>
<ul>
<li><strong>特点：</strong> 最直接、简单，数据和同步信号各占一根线，引脚数量多（如 24 位 RGB 需 24 根数据线 + 4-5 根控制线），布线复杂，抗干扰能力相对较弱。</li>
<li><strong>优点：</strong> 硬件实现简单，驱动无需复杂协议，直接输出像素流。</li>
<li><strong>缺点：</strong> 功耗相对高，EMI 风险大，传输距离受限，不适合高分辨率和高速应用。</li>
<li><strong>适用场景：</strong> 低分辨率、低成本的 MCU 或简单 SoC 系统。</li>
</ul>
</li>
<li>
<p><strong>8080 接口 (或称 MCU 接口 / 并行总线接口)</strong></p>
<ul>
<li><strong>特点：</strong> 基于并行总线读写模式，LCD 模块内部集成显存 (SRAM)。需要数据线 (8/16 位)、读写控制线 (RD#, WR#)、数据/命令选择线 (RS/DC)、片选线 (CS#)。</li>
<li><strong>优点：</strong> 主控芯片无需帧缓冲，极大减轻 MCU 资源占用；接口引脚数量较少（相对于并行 RGB）。</li>
<li><strong>缺点：</strong> 模块自带显存成本高，支持的分辨率和颜色深度有限；通信效率较低，不适合实时高速刷新和复杂图形显示。</li>
<li><strong>适用场景：</strong> 小型、低分辨率的字符屏或简单图形屏，尤其适合资源有限的单片机 (MCU) 系统。</li>
</ul>
</li>
<li>
<p><strong>LVDS (Low-Voltage Differential Signaling) 接口</strong></p>
<ul>
<li><strong>特点：</strong> 一种高速、低功耗的差分串行传输技术。将并行数据串行化后通过多对差分线传输（数据对和时钟对）。</li>
<li><strong>优点：</strong> 高速、抗干扰能力强、传输距离远、功耗相对较低、引脚数量适中。</li>
<li><strong>缺点：</strong> 需要 LVDS 发送器/接收器芯片（或 SoC 集成），布线对阻抗匹配有要求。</li>
<li><strong>适用场景：</strong> 中高分辨率的笔记本电脑、桌面显示器、工业控制面板以及一些中大尺寸的嵌入式设备。</li>
</ul>
</li>
<li>
<p><strong>MIPI DSI (Display Serial Interface)</strong></p>
<ul>
<li><strong>特点：</strong> 基于 MIPI D-PHY/C-PHY 物理层的高速串行接口，是 MIPI 联盟为显示应用定义的协议。通常只有几对差分线（1-4 对数据线 + 1 对时钟线），支持高速模式和低功耗模式。</li>
<li><strong>优点：</strong> 高速（支持高分辨率、高刷新率）、极低功耗、极低 EMI、引脚数量最少、简化 PCB 布线。支持流式视频模式和命令模式。</li>
<li><strong>缺点：</strong> 协议相对复杂，需要支持 MIPI DSI 的 SoC。</li>
<li><strong>适用场景：</strong> 智能手机、平板电脑、高端嵌入式设备、虚拟现实/增强现实设备等，是目前移动显示领域的绝对主流。</li>
</ul>
</li>
</ol>
<p>好的，我们来详细总结一下前面提到的几种常用 LCD 接口的引脚和它们对应的功能。</p>
<hr />
<h3 id="4-并行-rgb-接口引脚-parallel-rgb-dpi-lcd-并行接口"><a class="markdownIt-Anchor" href="#4-并行-rgb-接口引脚-parallel-rgb-dpi-lcd-并行接口"></a> 4. 并行 RGB 接口引脚 (Parallel RGB / DPI / LCD 并行接口)</h3>
<p>并行 RGB 接口是最直接的视频数据传输方式，每个像素的颜色分量通常用多位并行传输。</p>
<ul>
<li><strong>特点：</strong> 每个颜色分量（红、绿、蓝）都有独立的引脚，同步信号也独立。</li>
<li><strong>常见位宽：</strong> 16位 (RGB565)、18位 (RGB666)、24位 (RGB888)。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">引脚名称 (常见缩写)</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>PCLK</strong> (Pixel Clock)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>像素时钟</strong>：同步数据传输。每个 PCLK 周期传输一个像素的数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>HSYNC</strong> (Horizontal Sync)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>水平同步信号</strong>：指示一行的开始。</td>
</tr>
<tr>
<td style="text-align:left"><strong>VSYNC</strong> (Vertical Sync)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>垂直同步信号</strong>：指示一帧的开始。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DE</strong> (Data Enable)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>数据使能信号</strong>：指示当前像素数据是否有效（高有效）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>R[n:0]</strong> (Red Data)</td>
<td style="text-align:left">5-8</td>
<td style="text-align:left"><strong>红色数据线</strong>：传输红色分量数据。例如 R7-R0 代表 8 位红色数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>G[n:0]</strong> (Green Data)</td>
<td style="text-align:left">6-8</td>
<td style="text-align:left"><strong>绿色数据线</strong>：传输绿色分量数据。例如 G7-G0 代表 8 位绿色数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>B[n:0]</strong> (Blue Data)</td>
<td style="text-align:left">5-8</td>
<td style="text-align:left"><strong>蓝色数据线</strong>：传输蓝色分量数据。例如 B7-B0 代表 8 位蓝色数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>GND</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>地线</strong>：电源和信号参考地。</td>
</tr>
<tr>
<td style="text-align:left"><strong>VCC/VDD</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>电源</strong>：为 LCD 模块供电。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Backlight Control</strong></td>
<td style="text-align:left">1-2</td>
<td style="text-align:left"><strong>背光控制</strong>：通常是 PWM 信号（亮度调节）和使能信号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RESET</strong></td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>复位信号</strong>：硬件复位 LCD 模块。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>引脚总数示例 (24位 RGB888):</strong> PCLK + HSYNC + VSYNC + DE + 24 (RGB) = <strong>28 根信号线</strong> (不含电源地和背光)。</li>
</ul>
<hr />
<h3 id="5-8080-接口引脚-mcu-接口-并行总线接口"><a class="markdownIt-Anchor" href="#5-8080-接口引脚-mcu-接口-并行总线接口"></a> 5. 8080 接口引脚 (MCU 接口 / 并行总线接口)</h3>
<p>8080 接口模拟了微处理器与内存或外设的总线接口，LCD 模块内部通常有显存。</p>
<ul>
<li><strong>特点：</strong> 通过读写命令和数据线与 LCD 模块通信。</li>
<li><strong>常见位宽：</strong> 8位或16位。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">引脚名称 (常见缩写)</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>D[n:0]</strong> (Data)</td>
<td style="text-align:left">8/16</td>
<td style="text-align:left"><strong>数据线</strong>：传输命令、参数或像素数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>WR#</strong> (Write Strobe)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>写信号</strong>：低电平有效，表示数据总线上的数据被写入 LCD 模块。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RD#</strong> (Read Strobe)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>读信号</strong>：低电平有效，表示从 LCD 模块读取数据到数据总线。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RS / DC</strong> (Register Select / Data/Command)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>寄存器选择 / 数据/命令选择</strong>：高电平表示数据，低电平表示命令。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CS#</strong> (Chip Select)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>片选信号</strong>：低电平有效，选择当前的 LCD 模块进行通信。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RESET#</strong></td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>复位信号</strong>：低电平有效，硬件复位 LCD 模块。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Backlight Control</strong></td>
<td style="text-align:left">1-2</td>
<td style="text-align:left"><strong>背光控制</strong>：通常是 PWM 信号和使能信号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>GND</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>地线</strong>：电源和信号参考地。</td>
</tr>
<tr>
<td style="text-align:left"><strong>VCC/VDD</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>电源</strong>：为 LCD 模块供电。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>引脚总数示例 (8位):</strong> 8 (D) + WR# + RD# + RS/DC + CS# + RESET# = <strong>13 根信号线</strong> (不含电源地和背光)。</li>
</ul>
<hr />
<h3 id="6-lvds-接口引脚-low-voltage-differential-signaling"><a class="markdownIt-Anchor" href="#6-lvds-接口引脚-low-voltage-differential-signaling"></a> 6. LVDS 接口引脚 (Low-Voltage Differential Signaling)</h3>
<p>LVDS 接口通过差分信号传输数据，适用于中高速、长距离传输。</p>
<ul>
<li><strong>特点：</strong> 数据和时钟信号都通过差分对传输，抗干扰能力强。</li>
<li><strong>常见通道数：</strong> 1、2、4 对 (Pair)。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">引脚名称 (常见缩写)</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>TxCLK+/-</strong> (Transmitter Clock Pair)</td>
<td style="text-align:left">1 对</td>
<td style="text-align:left"><strong>LVDS 差分时钟对</strong>：传输同步时钟信号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>TxDATA[n]+/-</strong> (Transmitter Data Pair)</td>
<td style="text-align:left">1-4 对</td>
<td style="text-align:left"><strong>LVDS 差分数据对</strong>：传输串行化的像素数据和控制信号。每对传输约 7-8 位并行数据。</td>
</tr>
<tr>
<td style="text-align:left"><strong>GND</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>地线</strong>：电源和信号参考地。</td>
</tr>
<tr>
<td style="text-align:left"><strong>VCC/VDD</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>电源</strong>：为 LCD 模块供电。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Backlight Control</strong></td>
<td style="text-align:left">1-2</td>
<td style="text-align:left"><strong>背光控制</strong>：通常是 PWM 信号和使能信号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RESET</strong></td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>复位信号</strong>：硬件复位 LCD 模块。</td>
</tr>
<tr>
<td style="text-align:left"><strong>EDID_DATA/CLK</strong></td>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>DDC (Display Data Channel) 数据/时钟</strong>：可选，用于显示器和主机之间的信息交换（如显示器分辨率、时序信息）。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>引脚总数示例 (双通道 LVDS):</strong> 1 对 (CLK) + 2 对 (DATA) = <strong>6 根信号线</strong> (不含电源地、背光和 EDID)。</li>
</ul>
<hr />
<h3 id="7-mipi-dsi-接口-display-serial-interface"><a class="markdownIt-Anchor" href="#7-mipi-dsi-接口-display-serial-interface"></a> 7. MIPI DSI 接口 (Display Serial Interface)</h3>
<p>MIPI DSI 基于 MIPI D-PHY/C-PHY 物理层，是为移动显示优化的高速串行接口。</p>
<ul>
<li><strong>特点：</strong> 极少的引脚数量，高速差分传输，支持命令模式和视频模式，低功耗。</li>
<li><strong>常见通道数 (Lane)：</strong> 1、2、3、4 条数据通道 (Lane)。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">引脚名称 (常见缩写)</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>DSI_CLK+/-</strong> (Clock Lane)</td>
<td style="text-align:left">1 对</td>
<td style="text-align:left"><strong>MIPI D-PHY 差分时钟通道</strong>：提供同步时钟。在 LP 模式下用于控制，HS 模式下用于高速时钟。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DSI_DATA[n]+/-</strong> (Data Lane)</td>
<td style="text-align:left">1-4 对</td>
<td style="text-align:left"><strong>MIPI D-PHY 差分数据通道</strong>：传输串行化的像素数据、命令、短包等。支持 HS (高速) 和 LP (低功耗) 模式。</td>
</tr>
<tr>
<td style="text-align:left"><strong>GND</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>地线</strong>：电源和信号参考地。</td>
</tr>
<tr>
<td style="text-align:left"><strong>VCC/VDD</strong></td>
<td style="text-align:left">若干</td>
<td style="text-align:left"><strong>电源</strong>：为 LCD 模块供电。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Backlight Control</strong></td>
<td style="text-align:left">1-2</td>
<td style="text-align:left"><strong>背光控制</strong>：通常是 PWM 信号和使能信号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>RESET</strong></td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>复位信号</strong>：硬件复位 LCD 模块。</td>
</tr>
<tr>
<td style="text-align:left"><strong>I2C_SDA/SCL</strong></td>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>I2C 接口</strong>：通常用于与 LCD 驱动芯片或触摸屏控制器进行初始化、配置或触摸数据交互。</td>
</tr>
<tr>
<td style="text-align:left"><strong>TE</strong> (Tearing Effect)</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>撕裂效果信号</strong>：可选，由 LCD 驱动芯片输出，表示新一帧图像已经准备好，可避免画面撕裂。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>引脚总数示例 (4 通道 MIPI DSI):</strong> 1 对 (CLK) + 4 对 (DATA) = <strong>10 根信号线</strong> (不含电源地、背光、I2C 和 TE)。</li>
</ul>
<hr />
<h2 id="字符驱动程序"><a class="markdownIt-Anchor" href="#字符驱动程序"></a> 字符驱动程序</h2>
<p>好的，作为嵌入式系统开发专家，我来详细为你讲解 Linux 字符设备驱动程序。字符设备驱动是 Linux 设备驱动中最基础、也是最常用的一种类型。</p>
<hr />
<h3 id="1-字符设备驱动程序概述"><a class="markdownIt-Anchor" href="#1-字符设备驱动程序概述"></a> 1. 字符设备驱动程序概述</h3>
<p>在 Linux 中，设备大致分为三类：</p>
<ol>
<li><strong>字符设备 (Character Devices):</strong> 数据传输以字节流（字符）的形式进行，不缓冲，支持随机访问。例如：串口、键盘、鼠标、LCD（通过显存映射）、触摸屏等。</li>
<li><strong>块设备 (Block Devices):</strong> 数据传输以固定大小的数据块（通常是 512 字节的整数倍）进行，支持缓冲和随机访问。例如：硬盘、SD 卡、U 盘等。</li>
<li><strong>网络设备 (Network Devices):</strong> 处理网络数据包，具有特殊的网络接口。例如：以太网卡、Wi-Fi 模块等。</li>
</ol>
<p><strong>字符设备驱动程序</strong>就是内核中负责管理字符设备的软件模块。它为用户空间应用程序提供标准的访问接口（如 <code>/dev/xxx</code>），使得应用程序可以通过文件操作（<code>open()</code>, <code>read()</code>, <code>write()</code>, <code>ioctl()</code>, <code>close()</code> 等）来控制硬件设备。</p>
<h3 id="2-字符设备驱动程序开发流程"><a class="markdownIt-Anchor" href="#2-字符设备驱动程序开发流程"></a> 2. 字符设备驱动程序开发流程</h3>
<p>开发一个字符设备驱动程序，主要包含以下几个步骤：</p>
<ol>
<li>
<p><strong>设备号的分配与注册：</strong></p>
<ul>
<li>每个设备在 Linux 系统中都有一个唯一的设备号，由<strong>主设备号 (Major Number)</strong> 和 <strong>次设备号 (Minor Number)</strong> 组成。</li>
<li>主设备号标识设备类型（或驱动程序），次设备号标识同一类型下的具体设备。</li>
<li>驱动程序需要向内核申请一个主设备号，或者使用静态分配的设备号。</li>
</ul>
</li>
<li>
<p><strong>设备文件的创建：</strong></p>
<ul>
<li>在 <code>/dev</code> 目录下创建与设备号对应的设备文件（如 <code>mknod /dev/my_device c Major Minor</code>）。这样用户空间才能通过这个文件访问设备。</li>
<li>现代 Linux 通常使用 <code>udev</code> 或 <code>mdev</code> 机制，驱动程序只需向内核注册设备，设备文件会自动创建。</li>
</ul>
</li>
<li>
<p><strong>实现文件操作方法：</strong></p>
<ul>
<li>字符设备驱动的核心是实现一组标准的<strong>文件操作方法</strong>（<code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, <code>close</code> 等）。</li>
<li>这些方法被封装在一个 <code>struct file_operations</code> 结构体中。</li>
<li>当用户空间对设备文件执行相应的系统调用时，内核会调用 <code>file_operations</code> 中对应的函数。</li>
</ul>
</li>
<li>
<p><strong>驱动的加载与卸载：</strong></p>
<ul>
<li>驱动程序通常作为<strong>内核模块</strong> (<code>.ko</code> 文件) 存在，可以在系统运行时动态加载和卸载。</li>
<li>模块需要实现 <code>module_init()</code> 和 <code>module_exit()</code> 函数，分别作为模块的入口和出口。</li>
</ul>
</li>
</ol>
<h3 id="3-字符设备驱动程序用到的关键数据结构和函数"><a class="markdownIt-Anchor" href="#3-字符设备驱动程序用到的关键数据结构和函数"></a> 3. 字符设备驱动程序用到的关键数据结构和函数</h3>
<h4 id="关键数据结构"><a class="markdownIt-Anchor" href="#关键数据结构"></a> 关键数据结构</h4>
<ol>
<li>
<p><strong><code>struct file_operations</code></strong><br />
这是字符设备驱动的核心，定义了用户空间对设备文件操作的各种接口函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">// 指向拥有该结构的模块，通常设置为 THIS_MODULE</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>); <span class="comment">// 文件位置定位</span></span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *); <span class="comment">// 从设备读数据</span></span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *); <span class="comment">// 向设备写数据</span></span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *); <span class="comment">// 目录读（仅对目录文件有效）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>; <span class="comment">// 轮询，非阻塞 I/O</span></span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">// I/O 控制</span></span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">// 兼容 32 位 I/O 控制</span></span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *); <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *); <span class="comment">// 打开设备文件</span></span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id); <span class="comment">// 刷新数据（不常用）</span></span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *); <span class="comment">// 关闭设备文件</span></span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync); <span class="comment">// 同步数据</span></span><br><span class="line">    <span class="comment">// ... 其他不常用或更复杂的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct cdev</code></strong><br />
这是 Linux 内核中表示一个字符设备的结构体。每个字符设备都需要一个 <code>cdev</code> 结构体来向内核注册。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>         <span class="comment">// 内核对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>        <span class="comment">// 指向拥有该 cdev 的模块</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">// 指向文件操作结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>       <span class="comment">// 链表节点，用于连接到 cdev 列表中</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                   <span class="comment">// 设备号 (主设备号 + 次设备号)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;          <span class="comment">// 关联的次设备号数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct inode</code></strong><br />
表示一个文件系统节点（文件或目录）。当 <code>open()</code> 被调用时，会传入一个 <code>struct inode</code> 指针，通过它获取设备的主/次设备号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版，实际更复杂</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span> i_rdev; <span class="comment">// 对于设备文件，这里存储设备号</span></span><br><span class="line">    <span class="comment">// ... 其他文件系统相关成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct file</code></strong><br />
表示一个打开的文件实例。每次调用 <code>open()</code> 都会创建一个新的 <code>struct file</code> 实例。这个结构体在文件打开期间一直存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化版，实际更复杂</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>      <span class="title">f_path</span>;</span>      <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>     *<span class="title">f_inode</span>;</span>    <span class="comment">// 关联的 inode</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">// 关联的文件操作</span></span><br><span class="line">    <span class="type">void</span>             *private_data; <span class="comment">// 驱动程序可以在 open 中设置私有数据</span></span><br><span class="line">    <span class="type">loff_t</span>           f_pos;       <span class="comment">// 当前文件读写位置</span></span><br><span class="line">    <span class="comment">// ... 其他文件操作相关成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="关键函数"><a class="markdownIt-Anchor" href="#关键函数"></a> 关键函数</h4>
<ol>
<li>
<p><strong>设备号分配与注册：</strong></p>
<ul>
<li>
<p><strong><code>alloc_chrdev_region(dev_t *dev, unsigned minor, unsigned count, const char *name)</code></strong></p>
<ul>
<li><strong>功能：</strong> 动态分配主设备号。</li>
<li><strong>参数：</strong>
<ul>
<li><code>dev</code>：输出参数，分配到的起始设备号。</li>
<li><code>minor</code>：次设备号的起始值（通常为 0）。</li>
<li><code>count</code>：要分配的设备号数量。</li>
<li><code>name</code>：设备名称，会在 <code>/proc/devices</code> 中显示。</li>
</ul>
</li>
<li><strong>返回值：</strong> 成功返回 0，失败返回负数。</li>
<li><strong>特点：</strong> 推荐使用，避免与现有设备号冲突。</li>
</ul>
</li>
<li>
<p><strong><code>register_chrdev_region(dev_t from, unsigned count, const char *name)</code></strong></p>
<ul>
<li><strong>功能：</strong> 注册静态分配的主设备号。</li>
<li><strong>参数：</strong> <code>from</code> (起始设备号)、<code>count</code>、<code>name</code>。</li>
<li><strong>特点：</strong> 适合主设备号已知的场景，但易冲突。</li>
</ul>
</li>
<li>
<p><strong><code>unregister_chrdev_region(dev_t from, unsigned count)</code></strong></p>
<ul>
<li><strong>功能：</strong> 释放已分配或注册的设备号。</li>
<li><strong>参数：</strong> <code>from</code> (起始设备号)、<code>count</code>。</li>
<li><strong>时机：</strong> 模块卸载时调用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>cdev</code> 操作：</strong></p>
<ul>
<li>
<p><strong><code>cdev_init(struct cdev *cdev, const struct file_operations *fops)</code></strong></p>
<ul>
<li><strong>功能：</strong> 初始化 <code>cdev</code> 结构体，并将其与 <code>file_operations</code> 关联。</li>
<li><strong>参数：</strong> <code>cdev</code> (要初始化的 <code>cdev</code> 指针)、<code>fops</code> (文件操作结构体指针)。</li>
</ul>
</li>
<li>
<p><strong><code>cdev_add(struct cdev *p, dev_t dev, unsigned count)</code></strong></p>
<ul>
<li><strong>功能：</strong> 将 <code>cdev</code> 注册到内核，使其可被用户空间访问。</li>
<li><strong>参数：</strong> <code>p</code> (<code>cdev</code> 指针)、<code>dev</code> (起始设备号)、<code>count</code> (次设备号数量)。</li>
<li><strong>返回值：</strong> 成功返回 0，失败返回负数。</li>
</ul>
</li>
<li>
<p><strong><code>cdev_del(struct cdev *p)</code></strong></p>
<ul>
<li><strong>功能：</strong> 从内核中注销 <code>cdev</code>。</li>
<li><strong>参数：</strong> <code>p</code> (<code>cdev</code> 指针)。</li>
<li><strong>时机：</strong> 模块卸载时调用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>设备文件自动创建 (udev/mdev 机制)：</strong></p>
<ul>
<li>
<p><strong><code>struct class *class_create(struct module *owner, const char *name)</code></strong></p>
<ul>
<li><strong>功能：</strong> 创建一个设备类。这个类会在 <code>/sys/class</code> 目录下创建一个目录。</li>
<li><strong>参数：</strong> <code>owner</code> (通常是 <code>THIS_MODULE</code>)、<code>name</code> (类名，如 &quot;my_device_class&quot;)。</li>
<li><strong>返回值：</strong> 成功返回 <code>struct class</code> 指针，失败返回 <code>NULL</code>。</li>
</ul>
</li>
<li>
<p><strong><code>void class_destroy(struct class *cls)</code></strong></p>
<ul>
<li><strong>功能：</strong> 销毁一个设备类。</li>
<li><strong>参数：</strong> <code>cls</code> (要销毁的类指针)。</li>
<li><strong>时机：</strong> 模块卸载时调用。</li>
</ul>
</li>
<li>
<p><strong><code>struct device *device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)</code></strong></p>
<ul>
<li><strong>功能：</strong> 在 <code>/sys/class/类名</code> 目录下创建设备节点，并通知 <code>udev/mdev</code> 在 <code>/dev</code> 目录下创建设备文件。</li>
<li><strong>参数：</strong>
<ul>
<li><code>cls</code>：之前创建的设备类。</li>
<li><code>parent</code>：父设备（可选，通常为 NULL）。</li>
<li><code>devt</code>：设备的设备号。</li>
<li><code>drvdata</code>：私有数据，可用于后续的 <code>device_get_drvdata()</code>。</li>
<li><code>fmt</code>：设备文件名格式字符串（如 &quot;my_device%d&quot;）。</li>
</ul>
</li>
<li><strong>返回值：</strong> 成功返回 <code>struct device</code> 指针，失败返回 <code>NULL</code>。</li>
</ul>
</li>
<li>
<p><strong><code>void device_destroy(struct class *cls, dev_t devt)</code></strong></p>
<ul>
<li><strong>功能：</strong> 销毁设备节点，并通知 <code>udev/mdev</code> 删除 <code>/dev</code> 下的设备文件。</li>
<li><strong>参数：</strong> <code>cls</code>、<code>devt</code>。</li>
<li><strong>时机：</strong> 模块卸载时调用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>模块加载/卸载函数：</strong></p>
<ul>
<li><strong><code>module_init(init_function)</code></strong>
<ul>
<li><strong>功能：</strong> 宏定义，指定模块加载时执行的初始化函数。</li>
</ul>
</li>
<li><strong><code>module_exit(exit_function)</code></strong>
<ul>
<li><strong>功能：</strong> 宏定义，指定模块卸载时执行的清理函数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="示例代码框架-伪代码"><a class="markdownIt-Anchor" href="#示例代码框架-伪代码"></a> 示例代码框架 (伪代码)</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>     <span class="comment">// 模块定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span>         <span class="comment">// 文件系统相关，file_operations</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span>       <span class="comment">// cdev 结构体和操作函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span>     <span class="comment">// device_create/destroy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span>    <span class="comment">// copy_to_user / copy_from_user</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;my_char_device&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_COUNT 1 <span class="comment">// 只创建一个设备</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> my_dev_num;       <span class="comment">// 保存设备号</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">my_cdev</span>;</span>     <span class="comment">// 字符设备结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">my_class</span>;</span> <span class="comment">// 设备类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. open 函数实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取设备次设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s device opened, minor: %d\n&quot;</span>, DRIVER_NAME, minor);</span><br><span class="line">    <span class="comment">// 可以在这里进行硬件初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. read 函数实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从硬件读取数据，然后 copy_to_user 到用户空间</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s device read, count: %zu\n&quot;</span>, DRIVER_NAME, count);</span><br><span class="line">    <span class="comment">// 假设从硬件读取了一个字节 &#x27;A&#x27;</span></span><br><span class="line">    <span class="type">char</span> data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, &amp;data, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回读取的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. write 函数实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从用户空间 copy_from_user 数据，然后写入硬件</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s device write, count: %zu\n&quot;</span>, DRIVER_NAME, count);</span><br><span class="line">    <span class="type">char</span> kbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kbuf, buf, (count &gt; <span class="keyword">sizeof</span>(kbuf) ? <span class="keyword">sizeof</span>(kbuf) : count))) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    kbuf[<span class="keyword">sizeof</span>(kbuf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串结束</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Data from user: %s\n&quot;</span>, kbuf);</span><br><span class="line">    <span class="comment">// 这里可以将数据写入硬件</span></span><br><span class="line">    <span class="keyword">return</span> count; <span class="comment">// 返回写入的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ioctl 函数实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">my_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s device ioctl, cmd: %u, arg: %lu\n&quot;</span>, DRIVER_NAME, cmd, arg);</span><br><span class="line">    <span class="comment">// 根据 cmd 执行不同的控制操作</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="comment">// 定义一些命令宏</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -ENOTTY; <span class="comment">// 无效命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. release (close) 函数实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s device closed\n&quot;</span>, DRIVER_NAME);</span><br><span class="line">    <span class="comment">// 可以在这里进行硬件清理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_fops</span> =</span> &#123;</span><br><span class="line">    .owner          = THIS_MODULE,</span><br><span class="line">    .open           = my_open,</span><br><span class="line">    .read           = my_read,</span><br><span class="line">    .write          = my_write,</span><br><span class="line">    .unlocked_ioctl = my_ioctl,</span><br><span class="line">    .release        = my_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_char_device_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Initializing %s device driver\n&quot;</span>, DRIVER_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 动态分配设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;my_dev_num, <span class="number">0</span>, DEVICE_COUNT, DRIVER_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to allocate char device region\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Allocated device major: %d, minor: %d\n&quot;</span>, MAJOR(my_dev_num), MINOR(my_dev_num));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化 cdev 结构体</span></span><br><span class="line">    cdev_init(&amp;my_cdev, &amp;my_fops);</span><br><span class="line">    my_cdev.owner = THIS_MODULE; <span class="comment">// 也可以在 cdev_init 内部设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册 cdev</span></span><br><span class="line">    ret = cdev_add(&amp;my_cdev, my_dev_num, DEVICE_COUNT);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to add cdev\n&quot;</span>);</span><br><span class="line">        unregister_chrdev_region(my_dev_num, DEVICE_COUNT);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建设备类和设备节点 (方便 udev 自动创建 /dev 文件)</span></span><br><span class="line">    my_class = class_create(THIS_MODULE, DRIVER_NAME <span class="string">&quot;_class&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(my_class)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to create device class\n&quot;</span>);</span><br><span class="line">        cdev_del(&amp;my_cdev);</span><br><span class="line">        unregister_chrdev_region(my_dev_num, DEVICE_COUNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(my_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device_create(my_class, <span class="literal">NULL</span>, my_dev_num, <span class="literal">NULL</span>, DRIVER_NAME <span class="string">&quot;%d&quot;</span>, MINOR(my_dev_num));</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Device node /dev/%s%d created\n&quot;</span>, DRIVER_NAME, MINOR(my_dev_num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_char_device_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Exiting %s device driver\n&quot;</span>, DRIVER_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 销毁设备节点</span></span><br><span class="line">    device_destroy(my_class, my_dev_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 销毁设备类</span></span><br><span class="line">    class_destroy(my_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注销 cdev</span></span><br><span class="line">    cdev_del(&amp;my_cdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 释放设备号</span></span><br><span class="line">    unregister_chrdev_region(my_dev_num, DEVICE_COUNT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册模块初始化和退出函数</span></span><br><span class="line">module_init(my_char_device_init);</span><br><span class="line">module_exit(my_char_device_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块许可证和作者信息</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name &lt;your.email@example.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple character device driver example&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;1.0&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个框架包含了字符设备驱动程序的核心要素。在实际开发中，你需要在 <code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code> 等函数中加入与具体硬件交互的逻辑（如寄存器操作、中断处理、DMA 等）。</p>
<h3 id="4-linux显示驱动程序介绍"><a class="markdownIt-Anchor" href="#4-linux显示驱动程序介绍"></a> 4. Linux显示驱动程序介绍</h3>
<p>Linux的显示驱动程序有传统的 fbdev（Framebuffer Device）以及现代的 DRM/KMS（Direct Rendering Manager / Kernel Mode Setting），其中：</p>
<ul>
<li><strong>简单场景 / 资源有限 / 旧系统：</strong> 考虑 <code>fbdev</code>，它易于理解和实现，但功能有限。</li>
<li><strong>现代系统 / 需要硬件加速 / 复杂图形：</strong> 必须使用 <code>DRM/KMS</code>。它提供了强大的功能和性能，但学习曲线陡峭，实现复杂。</li>
</ul>
<p>在嵌入式领域，尤其是在 Android 或需要图形界面的 Linux 发行版上，DRM/KMS 已经成为主流。对于那些只需要在 LCD 上显示简单静态图像或通过 CPU 绘制图像的低成本设备，<code>fbdev</code> 仍然是一个可行的选择。</p>
<h3 id="5-linux-framebuffer-fbdev-驱动程序"><a class="markdownIt-Anchor" href="#5-linux-framebuffer-fbdev-驱动程序"></a> 5. Linux Framebuffer (fbdev) 驱动程序</h3>
<h4 id="1-fbdev-概述"><a class="markdownIt-Anchor" href="#1-fbdev-概述"></a> 1. fbdev 概述</h4>
<p><code>fbdev</code> 是 Linux 提供的一种抽象图形硬件的机制。它将显存映射到用户空间，允许用户应用程序通过直接读写显存或使用 <code>ioctl</code> 命令来操作显示器，而无需关心底层硬件细节。这提供了一种简单的、硬件无关的图形输出接口。</p>
<ul>
<li><strong>优点：</strong> 简单、直接，易于理解和实现。对于简单的嵌入式系统或不需要复杂图形加速的场景非常适用。</li>
<li><strong>缺点：</strong> 缺乏硬件加速支持（通常只支持 CPU 渲染），不支持多层叠加、垂直同步等高级特性，难以处理复杂的显示模式切换和电源管理，不适合现代 GPU 架构。</li>
</ul>
<h4 id="2-fbdev-驱动程序编写流程"><a class="markdownIt-Anchor" href="#2-fbdev-驱动程序编写流程"></a> 2. fbdev 驱动程序编写流程</h4>
<p>编写一个 <code>fbdev</code> 驱动程序主要包括以下步骤：</p>
<ol>
<li><strong>分配和初始化 <code>struct fb_info</code>：</strong> 这是 <code>fbdev</code> 驱动的核心数据结构，包含了 framebuffer 的所有信息。</li>
<li><strong>设置 <code>fb_info</code> 的成员：</strong> 填充显示器参数（分辨率、颜色深度、像素格式等）、显存信息、文件操作回调函数等。</li>
<li><strong>实现 <code>struct fb_ops</code> 中的回调函数：</strong> 这些函数是 <code>fbdev</code> 驱动的核心逻辑，处理用户空间的请求。</li>
<li><strong>注册 <code>fb_info</code>：</strong> 调用 <code>register_framebuffer()</code> 将驱动注册到内核。</li>
<li><strong>内存映射：</strong> 通常，需要将物理显存映射到内核虚拟地址，并在 <code>fb_info</code> 中设置。</li>
<li><strong>硬件初始化：</strong> 配置显示控制器、时钟、时序等，启动显示。</li>
<li><strong>模块加载/卸载：</strong> 实现 <code>module_init()</code> 和 <code>module_exit()</code>。</li>
</ol>
<h4 id="3-fbdev-涉及到的关键数据结构和函数"><a class="markdownIt-Anchor" href="#3-fbdev-涉及到的关键数据结构和函数"></a> 3. fbdev 涉及到的关键数据结构和函数</h4>
<h5 id="关键数据结构-2"><a class="markdownIt-Anchor" href="#关键数据结构-2"></a> 关键数据结构</h5>
<ol>
<li>
<p><strong><code>struct fb_info</code></strong><br />
这是 <code>fbdev</code> 驱动的核心，它包含了帧缓冲设备的所有信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> node;                 <span class="comment">// 设备节点号，用于 /dev/fbX</span></span><br><span class="line">    <span class="type">int</span> flags;                <span class="comment">// 标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span>        <span class="comment">// 互斥锁，保护 fb_info</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span> <span class="comment">// 屏幕可变参数（分辨率、颜色深度等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span> <span class="comment">// 屏幕固定参数（显存大小、物理地址等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span> <span class="comment">// 显示器规格</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span>      <span class="comment">// 颜色映射表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span>     <span class="comment">// 帧缓冲操作函数集</span></span><br><span class="line">    <span class="type">void</span> __iomem *screen_base; <span class="comment">// 显存的虚拟地址 (内核空间)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> screen_size; <span class="comment">// 显存大小</span></span><br><span class="line">    <span class="type">char</span> *pseudo_palette;     <span class="comment">// 伪调色板</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> state;       <span class="comment">// 状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>    <span class="comment">// 关联的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fb_info_list</span>;</span> <span class="comment">// fb_info 链表</span></span><br><span class="line">    <span class="comment">// ... 其他成员，如私有数据 private_data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct fb_var_screeninfo</code> (<code>var</code>)</strong><br />
描述了帧缓冲设备的可变参数，用户空间可以通过 <code>ioctl(FBIOPUT_VSCREENINFO)</code> 修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> &#123;</span></span><br><span class="line">    __u32 xres;            <span class="comment">// 可视区域 x 轴分辨率</span></span><br><span class="line">    __u32 yres;            <span class="comment">// 可视区域 y 轴分辨率</span></span><br><span class="line">    __u32 xres_virtual;    <span class="comment">// 虚拟分辨率 x (可能大于 xres，实现平移)</span></span><br><span class="line">    __u32 yres_virtual;    <span class="comment">// 虚拟分辨率 y</span></span><br><span class="line">    __u32 xoffset;         <span class="comment">// 虚拟屏幕 x 偏移</span></span><br><span class="line">    __u32 yoffset;         <span class="comment">// 虚拟屏幕 y 偏移</span></span><br><span class="line">    __u32 bits_per_pixel;  <span class="comment">// 每像素位数 (bpp)</span></span><br><span class="line">    __u32 grayscale;       <span class="comment">// 灰度模式 (0: 彩色, 1: 灰度)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span>   <span class="comment">// 红色分量位域信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span> <span class="comment">// 绿色分量位域信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span>  <span class="comment">// 蓝色分量位域信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span> <span class="comment">// 透明度分量位域信息</span></span><br><span class="line">    __u32 nonstd;          <span class="comment">// 非标准模式</span></span><br><span class="line">    __u32 activate;        <span class="comment">// 激活标志</span></span><br><span class="line">    __u32 height;          <span class="comment">// 显示器高度 (mm)</span></span><br><span class="line">    __u32 width;           <span class="comment">// 显示器宽度 (mm)</span></span><br><span class="line">    __u32 accel_flags;     <span class="comment">// 加速器标志</span></span><br><span class="line">    __u32 pixclock;        <span class="comment">// 像素时钟 (ps)</span></span><br><span class="line">    __u32 left_margin;     <span class="comment">// 水平同步前间隙</span></span><br><span class="line">    __u32 right_margin;    <span class="comment">// 水平同步后间隙</span></span><br><span class="line">    __u32 upper_margin;    <span class="comment">// 垂直同步前间隙</span></span><br><span class="line">    __u32 lower_margin;    <span class="comment">// 垂直同步后间隙</span></span><br><span class="line">    __u32 hsync_len;       <span class="comment">// 水平同步脉冲宽度</span></span><br><span class="line">    __u32 vsync_len;       <span class="comment">// 垂直同步脉冲宽度</span></span><br><span class="line">    __u32 sync;            <span class="comment">// 同步信号极性</span></span><br><span class="line">    __u32 vmode;           <span class="comment">// 视频模式</span></span><br><span class="line">    __u32 rotate;          <span class="comment">// 旋转角度</span></span><br><span class="line">    __u32 colorspace;      <span class="comment">// 颜色空间</span></span><br><span class="line">    __u32 reserved[<span class="number">4</span>];     <span class="comment">// 保留</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct fb_fix_screeninfo</code> (<code>fix</code>)</strong><br />
描述了帧缓冲设备的固定参数，这些参数在设备生命周期内不会改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>];           <span class="comment">// 驱动 ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> smem_start; <span class="comment">// 显存物理起始地址</span></span><br><span class="line">    __u32 smem_len;        <span class="comment">// 显存长度 (字节)</span></span><br><span class="line">    __u32 type;            <span class="comment">// fb 类型 (如 FB_TYPE_PACKED_PIXELS)</span></span><br><span class="line">    __u32 type_aux;        <span class="comment">// 辅助 fb 类型</span></span><br><span class="line">    __u32 visual;          <span class="comment">// 视觉类型 (如 FB_VISUAL_TRUECOLOR)</span></span><br><span class="line">    __u16 xpanstep;        <span class="comment">// x 轴平移步长</span></span><br><span class="line">    __u16 ypanstep;        <span class="comment">// y 轴平移步长</span></span><br><span class="line">    __u16 ywrapstep;       <span class="comment">// y 轴回绕步长</span></span><br><span class="line">    __u32 line_length;     <span class="comment">// 一行像素的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmio_start; <span class="comment">// MMIO 区域物理起始地址</span></span><br><span class="line">    __u32 mmio_len;        <span class="comment">// MMIO 区域长度</span></span><br><span class="line">    __u32 accel;           <span class="comment">// 加速器类型</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct fb_ops</code></strong><br />
帧缓冲设备的操作函数集，是驱动程序与内核交互的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">int</span> (*fb_open)(<span class="keyword">struct</span> fb_info *info, <span class="type">int</span> user);</span><br><span class="line">    <span class="type">int</span> (*fb_release)(<span class="keyword">struct</span> fb_info *info, <span class="type">int</span> user);</span><br><span class="line">    <span class="type">ssize_t</span> (*fb_read)(<span class="keyword">struct</span> fb_info *info, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos);</span><br><span class="line">    <span class="type">ssize_t</span> (*fb_write)(<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos);</span><br><span class="line">    <span class="type">int</span> (*fb_check_var)(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info); <span class="comment">// 检查可变参数</span></span><br><span class="line">    <span class="type">int</span> (*fb_set_par)(<span class="keyword">struct</span> fb_info *info); <span class="comment">// 设置可变参数</span></span><br><span class="line">    <span class="type">int</span> (*fb_setcolreg)(<span class="type">unsigned</span> <span class="type">int</span> regno, <span class="type">unsigned</span> <span class="type">int</span> red, <span class="type">unsigned</span> <span class="type">int</span> green, <span class="type">unsigned</span> <span class="type">int</span> blue, <span class="type">unsigned</span> <span class="type">int</span> transp, <span class="keyword">struct</span> fb_info *info); <span class="comment">// 设置调色板</span></span><br><span class="line">    <span class="type">int</span> (*fb_blank)(<span class="type">int</span> blank, <span class="keyword">struct</span> fb_info *info); <span class="comment">// 屏幕空白/唤醒</span></span><br><span class="line">    <span class="type">int</span> (*fb_pan_display)(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info); <span class="comment">// 屏幕平移</span></span><br><span class="line">    <span class="type">int</span> (*fb_ioctl)(<span class="keyword">struct</span> fb_info *info, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg); <span class="comment">// ioctl 接口</span></span><br><span class="line">    <span class="comment">// ... 其他成员，如 mmap, fillrect, copyarea, imageblit 等用于软件绘图加速</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="关键函数-2"><a class="markdownIt-Anchor" href="#关键函数-2"></a> 关键函数</h5>
<ol>
<li>
<p><strong><code>framebuffer_alloc(size_t size, struct device *dev)</code></strong></p>
<ul>
<li><strong>功能：</strong> 分配并初始化 <code>struct fb_info</code> 结构体，并为 <code>private_data</code> 成员分配 <code>size</code> 字节内存。</li>
<li><strong>参数：</strong> <code>size</code> (私有数据大小)、<code>dev</code> (关联的设备)。</li>
<li><strong>返回值：</strong> 成功返回 <code>fb_info</code> 指针，失败返回 <code>NULL</code>。</li>
</ul>
</li>
<li>
<p><strong><code>register_framebuffer(struct fb_info *info)</code></strong></p>
<ul>
<li><strong>功能：</strong> 将 <code>fb_info</code> 注册到内核，使得 <code>/dev/fbX</code> 设备文件被创建。</li>
<li><strong>参数：</strong> <code>info</code> (要注册的 <code>fb_info</code> 指针)。</li>
<li><strong>返回值：</strong> 成功返回 0，失败返回负数。</li>
</ul>
</li>
<li>
<p><strong><code>unregister_framebuffer(struct fb_info *info)</code></strong></p>
<ul>
<li><strong>功能：</strong> 从内核注销 <code>fb_info</code>，删除 <code>/dev/fbX</code> 设备文件。</li>
<li><strong>参数：</strong> <code>info</code>。</li>
<li><strong>时机：</strong> 模块卸载时调用。</li>
</ul>
</li>
<li>
<p><strong><code>framebuffer_release(struct fb_info *info)</code></strong></p>
<ul>
<li><strong>功能：</strong> 释放 <code>fb_info</code> 结构体及相关资源。</li>
<li><strong>参数：</strong> <code>info</code>。</li>
<li><strong>时机：</strong> 模块卸载时调用。</li>
</ul>
</li>
<li>
<p><strong>内存映射相关 (I/O 内存操作)：</strong></p>
<ul>
<li><strong><code>ioremap(phys_addr_t phys_addr, unsigned long size)</code></strong>
<ul>
<li><strong>功能：</strong> 将物理地址 <code>phys_addr</code> 开始的 <code>size</code> 字节物理内存映射到内核虚拟地址空间。</li>
<li><strong>返回值：</strong> 成功返回虚拟地址，失败返回 <code>NULL</code>。</li>
<li><strong>用途：</strong> 用于映射显存、MMIO 寄存器等。</li>
</ul>
</li>
<li><strong><code>iounmap(void __iomem *addr)</code></strong>
<ul>
<li><strong>功能：</strong> 解除 <code>ioremap</code> 映射。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-fbdev-驱动程序编写的简单流程"><a class="markdownIt-Anchor" href="#4-fbdev-驱动程序编写的简单流程"></a> 4. <code>fbdev</code> 驱动程序编写的简单流程</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 fb_ops</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> <span class="title">my_fb_ops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .fb_check_var = my_fb_check_var,</span><br><span class="line">    .fb_set_par = my_fb_set_par,</span><br><span class="line">    .fb_blank = my_fb_blank,</span><br><span class="line">    <span class="comment">// ... 其他实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_fb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// a. 分配 fb_info</span></span><br><span class="line">    info = framebuffer_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> my_private_data), <span class="literal">NULL</span>); <span class="comment">// private_data 包含驱动私有信息</span></span><br><span class="line">    <span class="keyword">if</span> (!info) <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 填充 fb_info 的 fix 和 var 成员</span></span><br><span class="line">    <span class="comment">// 填充 info-&gt;fix (固定参数: id, smem_start, smem_len, line_length, visual, type 等)</span></span><br><span class="line">    info-&gt;fix.smem_start = MY_DISPLAY_MEM_PHYS_ADDR; <span class="comment">// 显存物理地址</span></span><br><span class="line">    info-&gt;fix.smem_len = MY_DISPLAY_MEM_SIZE;      <span class="comment">// 显存大小</span></span><br><span class="line">    <span class="comment">// ... 其他 fix 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充 info-&gt;var (可变参数: xres, yres, bits_per_pixel, timing 等)</span></span><br><span class="line">    info-&gt;var.xres = MY_DISPLAY_XRES;</span><br><span class="line">    info-&gt;var.yres = MY_DISPLAY_YRES;</span><br><span class="line">    info-&gt;var.bits_per_pixel = MY_DISPLAY_BPP;</span><br><span class="line">    <span class="comment">// ... 其他 var 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. 映射显存到内核虚拟地址</span></span><br><span class="line">    info-&gt;screen_base = ioremap(info-&gt;fix.smem_start, info-&gt;fix.smem_len);</span><br><span class="line">    <span class="keyword">if</span> (!info-&gt;screen_base) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_ioremep;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;screen_size = info-&gt;fix.smem_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. 设置 fb_ops</span></span><br><span class="line">    info-&gt;fbops = &amp;my_fb_ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// e. 初始化私有数据 (如果需要)</span></span><br><span class="line">    <span class="comment">// struct my_private_data *priv = info-&gt;private_data;</span></span><br><span class="line">    <span class="comment">// priv-&gt;reg_base = ioremap(...);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// f. 硬件初始化 (配置显示控制器寄存器、时钟、引脚等)</span></span><br><span class="line">    my_display_hw_init(info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g. 注册 framebuffer</span></span><br><span class="line">    ret = register_framebuffer(info);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register framebuffer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_register_fb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Framebuffer driver initialized.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_register_fb:</span><br><span class="line">    iounmap(info-&gt;screen_base);</span><br><span class="line">err_ioremep:</span><br><span class="line">    framebuffer_release(info);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模块卸载函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_fb_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// a. 销毁硬件 (关断显示控制器)</span></span><br><span class="line">    <span class="comment">// my_display_hw_exit(info);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 注销 framebuffer</span></span><br><span class="line">    unregister_framebuffer(info); <span class="comment">// info 在 my_fb_init 中定义为全局或静态变量</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// c. 解除显存映射</span></span><br><span class="line">    iounmap(info-&gt;screen_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d. 释放 fb_info</span></span><br><span class="line">    framebuffer_release(info);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Framebuffer driver exited.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_fb_init);</span><br><span class="line">module_exit(my_fb_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="6-现代的-drmkms-显示驱动程序"><a class="markdownIt-Anchor" href="#6-现代的-drmkms-显示驱动程序"></a> 6. 现代的 DRM/KMS 显示驱动程序</h3>
<h4 id="1-drmkms-概述"><a class="markdownIt-Anchor" href="#1-drmkms-概述"></a> 1. DRM/KMS 概述</h4>
<p>随着 GPU 硬件的复杂化和桌面图形栈的发展，<code>fbdev</code> 的局限性越来越明显。<code>DRM (Direct Rendering Manager)</code> 应运而生，它为用户空间的图形应用程序（如 Mesa 3D、Wayland/Xorg 显示服务器）提供了直接访问 GPU 硬件的接口，并管理资源。<code>KMS (Kernel Mode Setting)</code> 是 DRM 的一个重要组成部分，负责在内核空间进行显示模式设置。</p>
<ul>
<li><strong>DRM 的主要组成部分：</strong>
<ul>
<li><strong>内存管理：</strong> 通过 <code>GEM (Graphics Execution Manager)</code> 或 <code>TTM (Translation Table Manager)</code> 管理 GPU 显存。</li>
<li><strong>命令提交：</strong> 允许用户空间将图形命令提交给 GPU 执行。</li>
<li><strong><code>KMS (Kernel Mode Setting)</code>：</strong> 管理显示输出（显示模式、分辨率、屏幕刷新率等）、层（plane）、编码器（encoder）、连接器（connector）等。</li>
</ul>
</li>
<li><strong>优点：</strong>
<ul>
<li><strong>硬件加速：</strong> 充分利用 GPU 进行图形渲染、视频解码等。</li>
<li><strong>高级显示特性：</strong> 支持多层叠加 (Overlay)、垂直同步 (VSync)、原子模式设置、热插拔检测等。</li>
<li><strong>电源管理：</strong> 更精细的电源管理。</li>
<li><strong>多显示器支持：</strong> 更好地支持多显示器配置。</li>
<li><strong>标准化接口：</strong> 为用户空间（Mesa, Wayland, Xorg）提供统一的 API。</li>
</ul>
</li>
<li><strong>缺点：</strong> 复杂性大大增加，需要深入理解图形硬件和 DRM 框架。</li>
</ul>
<h4 id="2-drmkms-驱动程序编写流程-高度简化"><a class="markdownIt-Anchor" href="#2-drmkms-驱动程序编写流程-高度简化"></a> 2. DRM/KMS 驱动程序编写流程 (高度简化)</h4>
<p>编写一个 DRM/KMS 驱动是一个相当复杂的任务，通常涉及以下几个关键组件的实现：</p>
<ol>
<li>
<p><strong>设备注册与初始化：</strong></p>
<ul>
<li>作为 PCI 或 Platform 设备驱动，使用 <code>platform_driver</code> 或 <code>pci_driver</code> 框架注册。</li>
<li>分配和初始化 <code>struct drm_device</code>。</li>
</ul>
</li>
<li>
<p><strong><code>DRM CRTC/Encoder/Connector/Plane</code> 模型实现：</strong></p>
<ul>
<li><strong><code>CRTC (Cathode Ray Tube Controller)</code>：</strong> 虚拟显示控制器，负责从显存中读取像素数据并将其传输到显示管道。对应一个扫描引擎。</li>
<li><strong><code>Encoder (编码器)</code>：</strong> 将 CRTC 的数字输出编码成特定接口的信号（如 DSI、LVDS、HDMI、DP 等）。</li>
<li><strong><code>Connector (连接器)</code>：</strong> 表示一个物理输出端口（如 HDMI 接口、LCD 接口），能检测显示器连接状态 (Hotplug Detect, HPD) 和读取 EDID。</li>
<li><strong><code>Plane (层)</code>：</strong> 负责从显存中获取像素数据。有 Primary Plane (主层，显示主画面)、Cursor Plane (光标层)、Overlay Plane (叠加层，用于视频播放、UI 元素等)。</li>
</ul>
<p>驱动需要创建并注册这些对象，并实现它们的 <code>ops</code>（操作函数），例如：</p>
<ul>
<li><code>drm_encoder_ops</code>: <code>mode_set</code>, <code>enable</code>, <code>disable</code></li>
<li><code>drm_connector_ops</code>: <code>fill_modes</code>, <code>detect</code>, <code>get_modes</code></li>
<li><code>drm_crtc_ops</code>: <code>set_config</code>, <code>enable</code>, <code>disable</code>, <code>atomic_begin</code>, <code>atomic_flush</code></li>
<li><code>drm_plane_ops</code>: <code>atomic_update</code>, <code>atomic_disable</code></li>
</ul>
</li>
<li>
<p><strong>内存管理：</strong></p>
<ul>
<li>实现 <code>GEM</code> 或 <code>TTM</code> 的后端，管理 GPU 显存的分配、释放和同步。</li>
<li>通过 <code>mmap</code> 支持用户空间访问显存。</li>
</ul>
</li>
<li>
<p><strong>IRQ 和 VSync (垂直同步) 处理：</strong></p>
<ul>
<li>处理显示相关的中断（如 VSync 中断），用于同步帧缓冲区交换。</li>
</ul>
</li>
<li>
<p><strong>模式设置 (KMS)：</strong></p>
<ul>
<li>在 <code>drm_mode_config_funcs</code> 中实现 <code>dm_mode_set</code>，这是进行显示模式切换的核心。</li>
<li>实现原子模式设置 (<code>atomic</code> 相关的 <code>ops</code>)，允许一次性提交多个显示属性的改变。</li>
</ul>
</li>
<li>
<p><strong>Framebuffer (DRM Framebuffer) 和 Blob：</strong></p>
<ul>
<li>不同于 <code>fbdev</code> 的 <code>fb_info</code>，DRM 有自己的 <code>struct drm_framebuffer</code>，它表示一个用于显示的可绘制区域（通常是显存中的一个缓冲区）。</li>
<li><code>drm_mode_config_init</code> 初始化 KMS 配置。</li>
<li><code>drm_mode_create_dumb_buffer</code> 和 <code>drm_mode_destroy_dumb_buffer</code> 用于创建和销毁简单的显存缓冲区。</li>
</ul>
</li>
<li>
<p><strong>PM (电源管理) 和运行时 PM：</strong></p>
<ul>
<li>实现设备电源状态的切换。</li>
</ul>
</li>
</ol>
<h4 id="3-drmkms-涉及到的关键数据结构和函数-部分核心"><a class="markdownIt-Anchor" href="#3-drmkms-涉及到的关键数据结构和函数-部分核心"></a> 3. DRM/KMS 涉及到的关键数据结构和函数 (部分核心)</h4>
<h5 id="关键数据结构-drmkms-模型"><a class="markdownIt-Anchor" href="#关键数据结构-drmkms-模型"></a> 关键数据结构 (DRM/KMS 模型)</h5>
<ol>
<li>
<p><strong><code>struct drm_device</code></strong><br />
代表一个 DRM 驱动实例，包含了该 GPU 所有的 DRM 资源和状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config</span> <span class="title">mode_config</span>;</span> <span class="comment">// 核心：KMS 配置信息</span></span><br><span class="line">    <span class="type">void</span> *dev_private;             <span class="comment">// 驱动私有数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct drm_mode_config</code></strong><br />
管理所有 DRM 对象的集合，是 KMS 的入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lists of objects</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">crtc_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">connector_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">encoder_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">plane_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fb_list</span>;</span> <span class="comment">// DRM framebuffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointers to core CRTC/Encoder/Connector functions</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config_funcs</span> *<span class="title">funcs</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct drm_crtc</code></strong><br />
表示一个虚拟显示控制器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_crtc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_crtc_funcs</span> *<span class="title">funcs</span>;</span> <span class="comment">// CRTC 操作函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_framebuffer</span> *<span class="title">primary_fb</span>;</span> <span class="comment">// 当前 primary plane 关联的 framebuffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_plane</span> *<span class="title">primary</span>;</span>          <span class="comment">// 主层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_plane</span> *<span class="title">cursor</span>;</span>           <span class="comment">// 光标层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_atomic_state</span> *<span class="title">state</span>;</span>     <span class="comment">// 原子模式设置状态</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct drm_encoder</code></strong><br />
表示一个将 CRTC 输出转换为物理信号的编码器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder_funcs</span> *<span class="title">funcs</span>;</span> <span class="comment">// 编码器操作函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_crtc</span> *<span class="title">crtc</span>;</span>               <span class="comment">// 关联的 CRTC</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct drm_connector</code></strong><br />
表示一个物理显示输出接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_funcs</span> *<span class="title">funcs</span>;</span> <span class="comment">// 连接器操作函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_property_blob</span> *<span class="title">edid_blob_ptr</span>;</span> <span class="comment">// EDID 数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct drm_plane</code></strong><br />
表示一个显示层，可以从显存中获取数据并发送给 CRTC。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_plane</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_plane_funcs</span> *<span class="title">funcs</span>;</span> <span class="comment">// Plane 操作函数</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">drm_plane_type</span> <span class="title">type</span>;</span>            <span class="comment">// Primary, Overlay, Cursor</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_framebuffer</span> *<span class="title">fb</span>;</span>          <span class="comment">// 当前关联的 framebuffer</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>struct drm_framebuffer</code></strong><br />
DRM 中的帧缓冲区，是实际的像素数据存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_framebuffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// ... 尺寸、像素格式等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drm_gem_object</span> *<span class="title">obj</span>[<span class="title">DRM_MAX_FB_GEM_OBJECTS</span>];</span> <span class="comment">// GEM 对象，指向显存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="关键函数-drmkms"><a class="markdownIt-Anchor" href="#关键函数-drmkms"></a> 关键函数 (DRM/KMS)</h5>
<ol>
<li>
<p><strong>DRM 设备注册：</strong></p>
<ul>
<li><code>drm_dev_init(struct drm_device *dev, struct driver *driver)</code></li>
<li><code>drm_dev_register(struct drm_device *dev, unsigned long flags)</code></li>
</ul>
</li>
<li>
<p><strong>KMS 初始化：</strong></p>
<ul>
<li><code>drm_mode_config_init(struct drm_device *dev)</code>：初始化 <code>drm_mode_config</code>。</li>
<li><code>drm_mode_config_cleanup(struct drm_device *dev)</code>：清理 KMS 配置。</li>
</ul>
</li>
<li>
<p><strong>对象创建和注册：</strong></p>
<ul>
<li><code>drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc, struct drm_plane *primary, struct drm_plane *cursor, const struct drm_crtc_funcs *funcs, const char *name, ...)</code></li>
<li><code>drm_encoder_init(struct drm_device *dev, struct drm_encoder *encoder, const struct drm_encoder_funcs *funcs, int type, const char *name, ...)</code></li>
<li><code>drm_connector_init_with_panel(struct drm_device *dev, struct drm_connector *connector, const struct drm_connector_funcs *funcs, int interface, struct drm_panel *panel)</code></li>
<li><code>drm_plane_init(struct drm_device *dev, struct drm_plane *plane, unsigned long possible_crtcs, const struct drm_plane_funcs *funcs, const uint32_t *formats, unsigned int format_count, const uint64_t *modifiers, unsigned int modifier_count, enum drm_plane_type type, const char *name, ...)</code></li>
</ul>
</li>
<li>
<p><strong>模式设置：</strong></p>
<ul>
<li><code>drm_mode_set_name(struct drm_display_mode *mode)</code>：为模式设置名称。</li>
<li><code>drm_mode_config_reset(struct drm_device *dev)</code>：重置模式配置。</li>
<li><code>drm_mode_connector_update_modes(struct drm_connector *connector, const int width, const int height)</code>：更新连接器支持的模式。</li>
<li><code>drm_atomic_helper_set_config(struct drm_mode_set *set)</code>：原子模式设置的辅助函数。</li>
</ul>
</li>
<li>
<p><strong>GEM 内存管理 (简化)：</strong></p>
<ul>
<li><code>drm_gem_object_init(struct drm_device *dev, struct drm_gem_object *obj, size_t size)</code></li>
<li><code>drm_gem_cma_alloc(struct drm_device *dev, size_t size)</code>：在 CMA 区域分配内存作为 GEM 对象。</li>
<li><code>drm_gem_object_release(struct kref *kref)</code></li>
</ul>
</li>
</ol>
<p>DRM/KMS 驱动的编写是一个庞大的工程，通常需要参考现有 GPU 驱动（如 Intel i915、AMDGPU、Nouvaeu、Rockchip DRM 等）的代码，并根据具体的显示控制器和 GPU 架构进行适配。对于一个全新的 SoC，从头编写 DRM 驱动通常是 SoC 厂商或专业团队的工作。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text"> 嵌入式学习（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">1.1.</span> <span class="toc-text"> 内联汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-arm-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%E6%96%B9%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. ARM 嵌入式系统汇编代码嵌入方法知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96-inline-assembly"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 1. 内联汇编 (Inline Assembly)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6-separate-assembly-files"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 2. 独立的汇编文件 (Separate Assembly Files)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AE%8F-compiler-intrinsicsmacros"><span class="toc-number">1.1.1.3.</span> <span class="toc-text"> 3. 编译器内建函数&#x2F;宏 (Compiler Intrinsics&#x2F;Macros)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%9A%84%E6%A0%BC%E5%BC%8F-gcc-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. 内联汇编的格式 (GCC 语法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97-assembler-template"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 1. 汇编指令序列 (Assembler Template)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C%E6%95%B0%E5%88%97%E8%A1%A8-output-operands"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 2. 输出操作数列表 (Output Operands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E5%88%97%E8%A1%A8-input-operands"><span class="toc-number">1.1.2.3.</span> <span class="toc-text"> 3. 输入操作数列表 (Input Operands)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A0%B4%E5%9D%8F%E6%80%A7%E5%88%97%E8%A1%A8-clobber-list"><span class="toc-number">1.1.2.4.</span> <span class="toc-text"> 4. 破坏性列表 (Clobber List)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. 内联汇编的常用使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> 1. 简单的寄存器操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-c%E5%8F%98%E9%87%8F%E4%B8%8E%E6%B1%87%E7%BC%96%E4%BA%A4%E4%BA%92"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> 2. C变量与汇编交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%BB%E5%86%99%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8-sfr"><span class="toc-number">1.1.3.3.</span> <span class="toc-text"> 3. 读写特殊功能寄存器 (SFR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD-cortex-m"><span class="toc-number">1.1.3.4.</span> <span class="toc-text"> 4. 控制中断 (Cortex-M)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.1.3.5.</span> <span class="toc-text"> 5. 内存屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8D%E8%A6%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. 重要的注意事项和最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text"> 原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-arm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 1. ARM 体系结构中的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-linux-kernel"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2. 原子变量的内核操作函数 (Linux Kernel)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 3. 实现原理及对应的汇编代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 4. 知识点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text"> 同步锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 1. Linux 内核中的主要锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E4%B8%8E-linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 2. 条件变量与 Linux 内核中的等待队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-spin_lock-%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 3. spin_lock (自旋锁)的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-mutex-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 4. mutex (互斥锁)的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 5. semaphore (信号量)的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93%E5%85%B3%E8%81%94"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 6. 总结关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lcd%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.</span> <span class="toc-text"> LCD基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lcd-%E5%B1%8F%E5%B9%95%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 1. LCD 屏幕的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B6%E8%A1%8C-rgb-%E6%8E%A5%E5%8F%A3-parallel-rgb-interface"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 1. 并行 RGB 接口 (Parallel RGB Interface)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mcu-%E6%8E%A5%E5%8F%A3-%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3-%E5%A6%82-8080-%E6%8E%A5%E5%8F%A3-6800-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> 2. MCU 接口 &#x2F; 并行总线接口 (如 8080 接口, 6800 接口)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-soc-%E9%9B%86%E6%88%90-lcd-%E6%8E%A7%E5%88%B6%E5%99%A8-%E9%AB%98%E9%80%9F%E4%B8%B2%E8%A1%8C%E6%8E%A5%E5%8F%A3-%E5%A6%82-mipi-dsi-lvds-edp-hdmidp"><span class="toc-number">1.4.1.3.</span> <span class="toc-text"> 3. SoC 集成 LCD 控制器 + 高速串行接口 (如 MIPI DSI, LVDS, eDP, HDMI&#x2F;DP)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mipi-%E6%A0%87%E5%87%86"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 2. MIPI 标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81lcd-%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 3. 常见LCD 接口总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B9%B6%E8%A1%8C-rgb-%E6%8E%A5%E5%8F%A3%E5%BC%95%E8%84%9A-parallel-rgb-dpi-lcd-%E5%B9%B6%E8%A1%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 4. 并行 RGB 接口引脚 (Parallel RGB &#x2F; DPI &#x2F; LCD 并行接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8080-%E6%8E%A5%E5%8F%A3%E5%BC%95%E8%84%9A-mcu-%E6%8E%A5%E5%8F%A3-%E5%B9%B6%E8%A1%8C%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 5. 8080 接口引脚 (MCU 接口 &#x2F; 并行总线接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-lvds-%E6%8E%A5%E5%8F%A3%E5%BC%95%E8%84%9A-low-voltage-differential-signaling"><span class="toc-number">1.4.6.</span> <span class="toc-text"> 6. LVDS 接口引脚 (Low-Voltage Differential Signaling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-mipi-dsi-%E6%8E%A5%E5%8F%A3-display-serial-interface"><span class="toc-number">1.4.7.</span> <span class="toc-text"> 7. MIPI DSI 接口 (Display Serial Interface)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text"> 字符驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 1. 字符设备驱动程序概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 2. 字符设备驱动程序开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 3. 字符设备驱动程序用到的关键数据结构和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.1.</span> <span class="toc-text"> 关键数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.2.</span> <span class="toc-text"> 关键函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.3.3.</span> <span class="toc-text"> 示例代码框架 (伪代码)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-linux%E6%98%BE%E7%A4%BA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 4. Linux显示驱动程序介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-linux-framebuffer-fbdev-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 5. Linux Framebuffer (fbdev) 驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-fbdev-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.5.1.</span> <span class="toc-text"> 1. fbdev 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-fbdev-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.5.2.</span> <span class="toc-text"> 2. fbdev 驱动程序编写流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-fbdev-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.5.3.</span> <span class="toc-text"> 3. fbdev 涉及到的关键数据结构和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.5.5.3.1.</span> <span class="toc-text"> 关键数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.5.5.3.2.</span> <span class="toc-text"> 关键函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-fbdev-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.5.4.</span> <span class="toc-text"> 4. fbdev 驱动程序编写的简单流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%8E%B0%E4%BB%A3%E7%9A%84-drmkms-%E6%98%BE%E7%A4%BA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text"> 6. 现代的 DRM&#x2F;KMS 显示驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-drmkms-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.6.1.</span> <span class="toc-text"> 1. DRM&#x2F;KMS 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-drmkms-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B-%E9%AB%98%E5%BA%A6%E7%AE%80%E5%8C%96"><span class="toc-number">1.5.6.2.</span> <span class="toc-text"> 2. DRM&#x2F;KMS 驱动程序编写流程 (高度简化)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-drmkms-%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0-%E9%83%A8%E5%88%86%E6%A0%B8%E5%BF%83"><span class="toc-number">1.5.6.3.</span> <span class="toc-text"> 3. DRM&#x2F;KMS 涉及到的关键数据结构和函数 (部分核心)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-drmkms-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.6.3.1.</span> <span class="toc-text"> 关键数据结构 (DRM&#x2F;KMS 模型)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0-drmkms"><span class="toc-number">1.5.6.3.2.</span> <span class="toc-text"> 关键函数 (DRM&#x2F;KMS)</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&text=嵌入式学习（一）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&is_video=false&description=嵌入式学习（一）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=嵌入式学习（一）&body=Check out this article: https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&title=嵌入式学习（一）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&name=嵌入式学习（一）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/02/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/&t=嵌入式学习（一）"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
