<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：一般   嵌入式学习（九）  1. Linux pinctrl 子系统深度解析  1. pinctrl 子系统核心思想  1.1 背景与目标 在现代 SoC (System on Chip) 中，有限的物理引脚需要被多个外设（如 UART, SPI, I2C, GPIO 等）共享，同时还需要精细配置其电气特性（上拉&#x2F;下拉、驱动强度、压摆率等）。pinctrl 子系统旨在解决传统直">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式学习（九）">
<meta property="og:url" content="https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：一般   嵌入式学习（九）  1. Linux pinctrl 子系统深度解析  1. pinctrl 子系统核心思想  1.1 背景与目标 在现代 SoC (System on Chip) 中，有限的物理引脚需要被多个外设（如 UART, SPI, I2C, GPIO 等）共享，同时还需要精细配置其电气特性（上拉&#x2F;下拉、驱动强度、压摆率等）。pinctrl 子系统旨在解决传统直">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-21T11:11:19.000Z">
<meta property="article:modified_time" content="2025-07-23T13:51:04.649Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>嵌入式学习（九）</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/07/16/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&text=嵌入式学习（九）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&is_video=false&description=嵌入式学习（九）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=嵌入式学习（九）&body=Check out this article: https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&name=嵌入式学习（九）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&t=嵌入式学习（九）"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%9D"><span class="toc-number">1.</span> <span class="toc-text"> 嵌入式学习（九）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-linux-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. Linux pinctrl 子系统深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. pinctrl 子系统核心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%83%8C%E6%99%AF%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 1.1 背景与目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 1.2 核心目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-device-tree-%E4%B8%AD%E7%9A%84-pinctrl-%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. Device Tree 中的 pinctrl 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-pinctrl-%E9%85%8D%E7%BD%AE%E7%AB%AF-%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 2.1 Pinctrl 配置端 (硬件能力描述)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-pinctrl-%E5%BC%95%E7%94%A8%E7%AB%AF-%E8%AE%BE%E5%A4%87%E7%89%B9%E5%AE%9A%E5%BC%95%E8%84%9A%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 2.2 Pinctrl 引用端 (设备特定引脚需求)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-pinctrl-%E5%AE%9E%E7%8E%B0-gpio-%E5%A4%8D%E7%94%A8%E5%8F%8A%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. pinctrl 实现 GPIO 复用及状态切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> 3.1 核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> 3.2 运行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-default-%E4%B8%8E-sleep-%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.3.</span> <span class="toc-text"> 3.3 default 与 sleep 状态切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84core-%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. pinctrl 子系统架构：Core + 硬件驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41-pinctrl-core-%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text"> 4.1 pinctrl Core 的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-struct-pin_control_description"><span class="toc-number">1.1.4.2.</span> <span class="toc-text"> 4.2 struct pin_control_description</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA-gpio-%E5%A4%8D%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5. 与单片机 GPIO 复用对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-linux-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%90%84%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. Linux pinctrl 子系统各个结构体和工作调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 引言与核心概念回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 关键结构体详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_pin_desc"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"> struct pinctrl_pin_desc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_ops"><span class="toc-number">1.2.2.2.</span> <span class="toc-text"> struct pinctrl_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinmux_ops"><span class="toc-number">1.2.2.3.</span> <span class="toc-text"> struct pinmux_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinconf_ops"><span class="toc-number">1.2.2.4.</span> <span class="toc-text"> struct pinconf_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_desc"><span class="toc-number">1.2.2.5.</span> <span class="toc-text"> struct pinctrl_desc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_dev"><span class="toc-number">1.2.2.6.</span> <span class="toc-text"> struct pinctrl_dev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-device_node"><span class="toc-number">1.2.2.7.</span> <span class="toc-text"> struct device_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_map"><span class="toc-number">1.2.2.8.</span> <span class="toc-text"> struct pinctrl_map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_setting"><span class="toc-number">1.2.2.9.</span> <span class="toc-text"> struct pinctrl_setting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_state"><span class="toc-number">1.2.2.10.</span> <span class="toc-text"> struct pinctrl_state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl"><span class="toc-number">1.2.2.11.</span> <span class="toc-text"> struct pinctrl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-dev_pin_info-%E5%9C%A8-struct-device-%E4%B8%AD"><span class="toc-number">1.2.2.12.</span> <span class="toc-text"> struct dev_pin_info (在 struct device 中)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text"> pinctrl 子系统的工作流程：从初始化到应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80pin-controller-%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-%E9%9D%99%E6%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="toc-number">1.2.3.1.</span> <span class="toc-text"> 阶段一：Pin Controller 驱动的初始化 (静态定义与注册)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8Cclient-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90-device-tree"><span class="toc-number">1.2.3.2.</span> <span class="toc-text"> 阶段二：Client 设备驱动的初始化与引脚状态解析 (动态解析 Device Tree)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%E5%BA%94%E7%94%A8-pinctrl_setting-%E9%80%89%E6%8B%A9%E7%8A%B6%E6%80%81%E4%B8%8E%E5%AE%9E%E9%99%85%E7%A1%AC%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">1.2.3.3.</span> <span class="toc-text"> 阶段三：应用 pinctrl_setting (选择状态与实际硬件“绑定”)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%BA%90%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 结构体来源与初始化关系总结表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        嵌入式学习（九）
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-21T11:11:19.000Z" class="dt-published" itemprop="datePublished">2025-07-21</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/work/">work</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：一般</p>
<hr />
<h1 id="嵌入式学习九"><a class="markdownIt-Anchor" href="#嵌入式学习九"></a> 嵌入式学习（九）</h1>
<h2 id="1-linux-pinctrl-子系统深度解析"><a class="markdownIt-Anchor" href="#1-linux-pinctrl-子系统深度解析"></a> 1. Linux <code>pinctrl</code> 子系统深度解析</h2>
<h3 id="1-pinctrl-子系统核心思想"><a class="markdownIt-Anchor" href="#1-pinctrl-子系统核心思想"></a> 1. <code>pinctrl</code> 子系统核心思想</h3>
<h4 id="11-背景与目标"><a class="markdownIt-Anchor" href="#11-背景与目标"></a> 1.1 背景与目标</h4>
<p>在现代 SoC (System on Chip) 中，有限的物理引脚需要被多个外设（如 UART, SPI, I2C, GPIO 等）共享，同时还需要精细配置其电气特性（上拉/下拉、驱动强度、压摆率等）。<code>pinctrl</code> 子系统旨在解决传统直接操作寄存器带来的代码重复、可维护性差、容易冲突和平台依赖等问题。</p>
<h4 id="12-核心目标"><a class="markdownIt-Anchor" href="#12-核心目标"></a> 1.2 核心目标</h4>
<p>提供一个统一的、硬件无关的 API 来管理 SoC 上的引脚的功能复用 (Pin Multiplexing) 和电气特性配置 (Pin Configuration)。它将引脚管理从具体设备驱动中剥离，实现 <strong>抽象和集中管理</strong>。</p>
<h3 id="2-device-tree-中的-pinctrl-结构"><a class="markdownIt-Anchor" href="#2-device-tree-中的-pinctrl-结构"></a> 2. Device Tree 中的 <code>pinctrl</code> 结构</h3>
<p><code>pinctrl</code> 的配置在 Device Tree 中通常分为两大部分：</p>
<h4 id="21-pinctrl-配置端-硬件能力描述"><a class="markdownIt-Anchor" href="#21-pinctrl-配置端-硬件能力描述"></a> 2.1 Pinctrl 配置端 (硬件能力描述)</h4>
<ul>
<li><strong>位置：</strong> 通常位于 SoC 相关的 <code>.dtsi</code> 文件中（如 <code>imx6ul.dtsi</code>），描述 <strong>SoC 芯片固有的引脚配置能力</strong>。</li>
<li><strong>内容：</strong>
<ul>
<li>
<p><strong>Pin Controller 节点：</strong> 对应 SoC 中的引脚控制器硬件。</p>
</li>
<li>
<p><strong>Pin Group (引脚组)：</strong> 一组具有相同复用功能或电气配置需求的引脚的集合。</p>
</li>
<li>
<p><strong>Pin Function (引脚功能)：</strong> 某个引脚组在特定功能下扮演的角色（如 UART TX/RX，GPIO）。</p>
</li>
<li>
<p><strong>Pin Configuration (电气特性)：</strong> 对引脚组中的引脚进行电气参数配置（<code>pull-up</code>, <code>drive-strength</code>, <code>slew-rate</code> 等）。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 概念性示例：imx6ul.dtsi</span></span><br><span class="line"><span class="title class_">pinctrl@20e0000</span> <span class="punctuation">&#123;</span> <span class="comment">// Pin Controller 节点</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fsl,imx6ul-pinctrl&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">    pinctrl_uart2:</span> <span class="title class_">uart2grp</span> <span class="punctuation">&#123;</span> <span class="comment">// 引脚组定义</span></span><br><span class="line">        <span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">            MX6UL_PAD_UART2_TX_DATA__UART2_TX_DATA    <span class="number">0x1b0b1</span> // 功能复用和电气配置</span></span><br><span class="line"><span class="params">            MX6UL_PAD_UART2_RX_DATA__UART2_RX_DATA    <span class="number">0x1b0b1</span></span></span><br><span class="line"><span class="params">        &gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">    pinctrl_uart2_sleep:</span> <span class="title class_">uart2sleepgrp</span> <span class="punctuation">&#123;</span> <span class="comment">// 另一个状态下的引脚组定义</span></span><br><span class="line">        <span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">            MX6UL_PAD_UART2_TX_DATA__GPIO1_IO03       <span class="number">0x170b0</span></span></span><br><span class="line"><span class="params">            MX6UL_PAD_UART2_RX_DATA__GPIO1_IO04       <span class="number">0x170b0</span></span></span><br><span class="line"><span class="params">        &gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="22-pinctrl-引用端-设备特定引脚需求"><a class="markdownIt-Anchor" href="#22-pinctrl-引用端-设备特定引脚需求"></a> 2.2 Pinctrl 引用端 (设备特定引脚需求)</h4>
<ul>
<li><strong>位置：</strong> 通常位于具体的板级 <code>.dts</code> 文件中（如 <code>imx6ul-board.dts</code>），描述特定板子上某个设备如何使用引脚。</li>
<li><strong>内容：</strong> 具体的设备节点通过 <code>pinctrl-names</code> 和 <code>pinctrl-N</code> 属性来引用上方定义的引脚组。
<ul>
<li>
<p><code>pinctrl-names</code>：定义设备可能需要的引脚状态名称（如 &quot;default&quot;, &quot;sleep&quot;）。</p>
</li>
<li>
<p><code>pinctrl-N</code>：索引到 <code>pinctrl-names</code> 中的名称，指向上面定义的具体引脚组的 phandle。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 概念性示例：imx6ul-board.dts</span></span><br><span class="line"><span class="variable">&amp;uart2</span> <span class="punctuation">&#123;</span> <span class="comment">// 引用 UART2 设备节点</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;sleep&quot;</span><span class="punctuation">;</span> <span class="comment">// 定义引脚状态名称</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_uart2</span>&gt;</span><span class="punctuation">;</span>      <span class="comment">// &quot;default&quot; 状态引用 uart2grp</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_uart2_sleep</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// &quot;sleep&quot; 状态引用 uart2sleepgrp</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-pinctrl-实现-gpio-复用及状态切换"><a class="markdownIt-Anchor" href="#3-pinctrl-实现-gpio-复用及状态切换"></a> 3. <code>pinctrl</code> 实现 GPIO 复用及状态切换</h3>
<h4 id="31-核心原理"><a class="markdownIt-Anchor" href="#31-核心原理"></a> 3.1 核心原理</h4>
<p><code>pinctrl</code> 子系统充当设备驱动和底层硬件之间的 <strong>“翻译官”和“管理者”</strong>。它将高层抽象的“状态”请求，通过底层的 <code>pinctrl</code> 硬件驱动，转化为对 <strong>SoC 的 IOMUXC (Input/Output Multiplex Controller) 寄存器</strong> 和其他引脚配置寄存器的具体操作。</p>
<h4 id="32-运行流程"><a class="markdownIt-Anchor" href="#32-运行流程"></a> 3.2 运行流程</h4>
<ol>
<li><strong>内核启动与 DT 解析：</strong> 内核解析 Device Tree，加载对应的 <code>pinctrl</code> 硬件驱动，并注册其管理能力。</li>
<li><strong>设备驱动加载：</strong> 当设备驱动（如 UART 驱动）加载时：
<ul>
<li>调用 <code>devm_pinctrl_get()</code> 获取 <code>pinctrl</code> 句柄。</li>
<li>调用 <code>pinctrl_lookup_state()</code> 查找所需状态（如 &quot;default&quot;, &quot;sleep&quot;）对应的引脚组信息。</li>
<li>调用 <code>pinctrl_select_state()</code> 请求将引脚配置到特定状态。</li>
</ul>
</li>
<li><strong>Core 与硬件驱动协作：</strong>
<ul>
<li><code>pinctrl</code> Core 接收请求，并通知对应的 SoC 特定 <code>pinctrl</code> 硬件驱动。</li>
<li>硬件驱动根据 Device Tree 中定义的引脚组信息，将抽象配置翻译成对底层 <strong>IOMUXC 寄存器</strong> 的位操作，实现引脚的功能复用切换和电气特性配置。</li>
</ul>
</li>
</ol>
<h4 id="33-default-与-sleep-状态切换"><a class="markdownIt-Anchor" href="#33-default-与-sleep-状态切换"></a> 3.3 <code>default</code> 与 <code>sleep</code> 状态切换</h4>
<ul>
<li><strong><code>default</code> 状态：</strong> 设备正常工作模式下的引脚配置，确保设备功能的高效稳定运行。通常由设备驱动在 <code>probe</code> 阶段请求激活。</li>
<li><strong><code>sleep</code> 状态：</strong> 设备进入低功耗模式（挂起、休眠）时的引脚配置，旨在 <strong>降低功耗</strong>。
<ul>
<li>可能将外设引脚 <strong>切换为 GPIO 功能</strong>，并设置为输入模式。</li>
<li>调整电气特性（如关闭上拉/下拉，降低驱动强度）。</li>
<li>通常由内核的 <strong>电源管理 (PM) 框架</strong> 在系统挂起/唤醒时，自动或通过设备驱动回调函数触发状态切换。</li>
</ul>
</li>
<li><strong>切换方式：</strong> 并不是 GPIO 模块自身切换，而是 <strong>SoC 的 IOMUXC 硬件</strong> 在 <code>pinctrl</code> 硬件驱动的控制下，将物理引脚的内部连接从一个功能模块（如 UART）切换到另一个功能模块（如 GPIO）。</li>
</ul>
<h3 id="4-pinctrl-子系统架构core-硬件驱动"><a class="markdownIt-Anchor" href="#4-pinctrl-子系统架构core-硬件驱动"></a> 4. <code>pinctrl</code> 子系统架构：Core + 硬件驱动</h3>
<p><code>pinctrl</code> 子系统采用了经典的 Linux 内核 <strong>“Core 系统 + 硬件驱动”</strong> 架构，与 I2C、Input、Framebuffer 等子系统类似。</p>
<h4 id="41-pinctrl-core-的角色"><a class="markdownIt-Anchor" href="#41-pinctrl-core-的角色"></a> 4.1 <code>pinctrl</code> Core 的角色</h4>
<ul>
<li>位于 <code>drivers/pinctrl/core.c</code> 及其相关文件。</li>
<li><strong>统一 API 接口：</strong> 提供 <code>devm_pinctrl_get()</code>, <code>pinctrl_lookup_state()</code>, <code>pinctrl_select_state()</code> 等通用函数供设备驱动调用。</li>
<li><strong>管理硬件驱动：</strong> 维护已注册的 SoC 特定 Pin Controller 驱动实例列表。</li>
<li><strong>解析 Device Tree：</strong> 识别 Pin Controller、引脚组及状态定义。</li>
<li><strong>资源抽象与冲突管理：</strong> 抽象底层引脚，检测和管理引脚资源冲突。</li>
<li><strong>电源管理集成：</strong> 响应系统挂起/唤醒事件，通知硬件驱动切换引脚状态。</li>
</ul>
<h4 id="42-struct-pin_control_description"><a class="markdownIt-Anchor" href="#42-struct-pin_control_description"></a> 4.2 <code>struct pin_control_description</code></h4>
<ul>
<li>这是 <strong>SoC 特定 <code>pinctrl</code> 硬件驱动</strong>（如 <code>drivers/pinctrl/freescale/pinctrl-imx.c</code>）用来 <strong>向 <code>pinctrl</code> Core 注册自己的关键数据结构</strong>。</li>
<li><strong>内容：</strong> 包含了该硬件 Pin Controller 的所有能力和操作函数指针：
<ul>
<li><code>pins</code> / <code>npins</code>：管理的物理引脚列表和数量。</li>
<li><code>pincfg_ops</code> (<code>struct pinconf_ops</code>)：用于配置引脚电气特性（如 <code>pinconf_group_set()</code>）。</li>
<li><code>pinmux_ops</code> (<code>struct pinmux_ops</code>)：用于配置引脚功能复用（如 <code>set_mux()</code>，<strong>负责对 IOMUXC 寄存器的实际操作</strong>）。</li>
</ul>
</li>
<li><strong>注册流程：</strong>
<ol>
<li>SoC 特定 <code>pinctrl</code> 驱动在 <code>probe</code> 函数中创建并填充 <code>pin_control_description</code> 实例。</li>
<li>调用 <code>pinctrl_register(&amp;desc, dev)</code> 将自身注册到 <code>pinctrl</code> Core，成功后返回一个 <code>struct pinctrl_dev *</code> (即 <code>pin_dev</code>)，代表该硬件 Pin Controller 在内核中的管理实例。</li>
<li>当设备驱动请求引脚操作时，<code>pinctrl</code> Core 会调度对应的 <code>pin_dev</code> 中的 <code>ops</code> 函数来执行底层硬件操作。</li>
</ol>
</li>
</ul>
<h3 id="5-与单片机-gpio-复用对比"><a class="markdownIt-Anchor" href="#5-与单片机-gpio-复用对比"></a> 5. 与单片机 GPIO 复用对比</h3>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">单片机开发 (如 STM32)</th>
<th style="text-align:left">Linux <code>pinctrl</code> 子系统 (SoC)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>配置方式</strong></td>
<td style="text-align:left">代码中直接操作寄存器或使用 HAL 库</td>
<td style="text-align:left">通过 Device Tree 描述，由内核 <code>pinctrl</code> Core + 硬件驱动管理</td>
</tr>
<tr>
<td style="text-align:left"><strong>抽象层级</strong></td>
<td style="text-align:left">低抽象，直接面向硬件寄存器</td>
<td style="text-align:left">高抽象，硬件细节封装在 <code>pinctrl</code> 驱动中</td>
</tr>
<tr>
<td style="text-align:left"><strong>配置粒度</strong></td>
<td style="text-align:left">通常针对单个引脚一对一配置</td>
<td style="text-align:left">可针对单个引脚，更常以“引脚组”批量配置</td>
</tr>
<tr>
<td style="text-align:left"><strong>可维护性</strong></td>
<td style="text-align:left">更改配置需修改多处代码，易错</td>
<td style="text-align:left">集中在 Device Tree 中，修改简单，冲突易发现</td>
</tr>
<tr>
<td style="text-align:left"><strong>运行时切换</strong></td>
<td style="text-align:left">应用代码直接调用函数切换寄存器位</td>
<td style="text-align:left">设备驱动请求 <code>pinctrl_select_state()</code>，Core 协调硬件驱动执行</td>
</tr>
<tr>
<td style="text-align:left"><strong>冲突管理</strong></td>
<td style="text-align:left">开发者手动避免冲突</td>
<td style="text-align:left"><code>pinctrl</code> Core 能检查并报告资源冲突</td>
</tr>
<tr>
<td style="text-align:left"><strong>通用性</strong></td>
<td style="text-align:left">代码与特定 MCU 紧密耦合</td>
<td style="text-align:left">设备驱动与 <code>pinctrl</code> Core API 交互，具有更好的跨平台通用性</td>
</tr>
<tr>
<td style="text-align:left"><strong>电源管理</strong></td>
<td style="text-align:left">开发者自行处理低功耗引脚配置</td>
<td style="text-align:left">支持不同电源状态下的引脚自动配置，与 PM 框架集成</td>
</tr>
</tbody>
</table>
<hr />
<p>好的，非常乐意为您提供一份关于 Linux <code>pinctrl</code> 子系统、其核心结构体以及工作流程的详细深度解析，并以 Markdown 格式呈现。</p>
<hr />
<h2 id="2-linux-pinctrl-子系统各个结构体和工作调用流程"><a class="markdownIt-Anchor" href="#2-linux-pinctrl-子系统各个结构体和工作调用流程"></a> 2. Linux <code>pinctrl</code> 子系统各个结构体和工作调用流程</h2>
<h3 id="引言与核心概念回顾"><a class="markdownIt-Anchor" href="#引言与核心概念回顾"></a> 引言与核心概念回顾</h3>
<p>在嵌入式系统中，CPU 的许多引脚都是多功能复用的。同一个物理引脚可以被配置为 GPIO、UART、SPI、I2C 等不同外设的功能，同时其电气特性（如上拉/下拉、驱动强度、开漏/推挽等）也可能需要调整。Linux 内核的 <code>pinctrl</code> (Pin Control) 子系统正是为了管理这些复杂的引脚复用和配置而设计的一套框架。</p>
<p>理解 <code>pinctrl</code> 子系统，需要先明确几个核心概念：</p>
<ul>
<li>
<p><strong>Pin Controller (引脚控制器)</strong>：</p>
<ul>
<li>这指的是 SoC (System on Chip) 内部一个实际的 <strong>硬件模块</strong>（例如在 NXP <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 系列 SoC 中通常是 IOMUXC 模块，或在 STM32MP1 中是专门的 <code>pinctrl</code> 模块）。</li>
<li>它的核心职责是对 SoC 上 <strong>所有或部分物理引脚</strong> 的功能进行复用选择（Pin Multiplexing，MUX）和电气特性配置（Pin Configuration，CONF）。</li>
<li>在 Linux 内核中，每个 Pin Controller 硬件块都会对应一个 <code>struct pinctrl_desc</code> 的定义和一个注册后得到的 <code>struct pinctrl_dev</code> 实例。Pin Controller 驱动负责实现其特有的硬件寄存器操作，以响应 <code>pinctrl</code> Core 的请求。</li>
</ul>
</li>
<li>
<p><strong>Pin Group (引脚组)</strong>：</p>
<ul>
<li>这是一个 <strong>逻辑概念</strong>，并非一个独立的硬件模块。它是一组关联的物理引脚集合，这些引脚通常为了实现某个特定的功能（如 UART2 的 TX/RX 引脚，GPIO LED 的单个引脚）而被一起管理和配置。</li>
<li>引脚组主要在 <strong>Device Tree (设备树)</strong> 中定义，描述了特定功能所需的物理引脚及其对应的复用和电气配置。例如，<code>pinctrl_uart2: uart2grp</code> 就是一个引脚组，它包含了 UART2_TX 和 UART2_RX 两个物理引脚，以及它们作为 UART 功能时的配置。</li>
</ul>
</li>
<li>
<p><strong>Client Device (客户端设备)</strong>：</p>
<ul>
<li>任何需要使用 SoC 引脚的外设驱动，如 UART 驱动、SPI 驱动、I2C 驱动或通用 GPIO 驱动本身，都是 <code>pinctrl</code> 子系统的客户端。</li>
<li>它们通过 <code>pinctrl</code> Core 提供的 APIs (<code>pinctrl_get</code>, <code>pinctrl_select_state</code> 等) 来声明和请求所需的引脚状态，而无需直接操控底层 Pin Controller 的硬件寄存器。</li>
</ul>
</li>
</ul>
<h3 id="关键结构体详解"><a class="markdownIt-Anchor" href="#关键结构体详解"></a> 关键结构体详解</h3>
<p>以下是 <code>pinctrl</code> 子系统涉及的一些核心结构体，按其在整个流程中的逻辑顺序进行说明：</p>
<h4 id="struct-pinctrl_pin_desc"><a class="markdownIt-Anchor" href="#struct-pinctrl_pin_desc"></a> <code>struct pinctrl_pin_desc</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> number;    <span class="comment">// 引脚的唯一ID</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 引脚的可读名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 用于描述一个独立的 <strong>物理引脚</strong>。<code>number</code> 通常是该引脚在 Pin Controller 硬件抽象层中的一个索引或 ID，<code>name</code> 是为了方便调试和阅读的人性化名称。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 它是 <strong>静态定义</strong> 在特定 SoC 的 Pin Controller 驱动源代码中（例如，<code>drivers/pinctrl/freescale/pinctrl-imx.c</code>）。驱动开发者根据 SoC 厂商的硬件手册，硬编码了该 Pin Controller 所能管理的所有物理引脚的清单。</p>
</li>
<li>
<p><strong>关联：</strong> 多个 <code>pinctrl_pin_desc</code> 组成一个数组，这个数组的指针会被赋值给 <code>struct pinctrl_desc</code> 的 <code>pins</code> 字段。</p>
</li>
</ul>
<h4 id="struct-pinctrl_ops"><a class="markdownIt-Anchor" href="#struct-pinctrl_ops"></a> <code>struct pinctrl_ops</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 获取Pin Group数量、名称、引脚列表等</span></span><br><span class="line">    <span class="type">int</span> (*get_groups_count)(<span class="keyword">struct</span> pinctrl_dev *pctldev);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *(*get_group_name)(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">                                  <span class="type">unsigned</span> <span class="type">int</span> selector);</span><br><span class="line">    <span class="type">int</span> (*get_group_pins)(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">                          <span class="type">unsigned</span> <span class="type">int</span> selector,</span><br><span class="line">                          <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> **pins,</span><br><span class="line">                          <span class="type">unsigned</span> <span class="type">int</span> *num_pins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 核心功能，用于解析设备树 --</span></span><br><span class="line">    <span class="type">int</span> (*dt_node_to_map)(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">                          <span class="keyword">struct</span> device_node *np,</span><br><span class="line">                          <span class="keyword">struct</span> pinctrl_map **<span class="built_in">map</span>, <span class="type">unsigned</span> <span class="type">int</span> *num_maps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与Pin Group相关的操作...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 定义了 Pin Controller 驱动与 <code>pinctrl</code> Core 之间进行核心交互的接口。它包含了一系列函数指针，用于管理 Pin Group 的元数据以及 <strong>解析设备树中定义的引脚配置</strong>。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 它是 <strong>静态定义</strong> 在 Pin Controller 驱动源代码中，由驱动开发者实现具体的函数逻辑。</p>
</li>
<li>
<p><strong>关联：</strong> <code>struct pinctrl_desc</code> 的 <code>pinctrl_ops</code> 字段会指向这个结构体。其中 <code>dt_node_to_map</code> 是关键函数，负责将 Device Tree 中的引脚组配置转换为内部的 <code>pinctrl_map</code> 结构。</p>
</li>
</ul>
<h4 id="struct-pinmux_ops"><a class="markdownIt-Anchor" href="#struct-pinmux_ops"></a> <code>struct pinmux_ops</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 获取引脚复用功能数量、名称、引脚组等</span></span><br><span class="line">    <span class="type">int</span> (*get_functions_count)(<span class="keyword">struct</span> pinctrl_dev *pctldev);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *(*get_function_name)(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">                                     <span class="type">unsigned</span> <span class="type">int</span> selector);</span><br><span class="line">    <span class="type">int</span> (*get_function_groups)(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">int</span> selector,</span><br><span class="line">                               <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> **groups,</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">int</span> *num_groups);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 核心功能，用于执行引脚复用 --</span></span><br><span class="line">    <span class="type">int</span> (*set_mux)(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> func_selector,</span><br><span class="line">                   <span class="type">unsigned</span> <span class="type">int</span> group_selector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与引脚复用相关的操作...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 定义了 Pin Controller 驱动进行 <strong>引脚功能复用</strong>（Pin Multiplexing）操作的接口。<code>set_mux</code> 是其核心，负责将一个引脚组复用到特定的功能上。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 它是 <strong>静态定义</strong> 在 Pin Controller 驱动源代码中，由驱动开发者实现具体的函数逻辑，这些函数会直接操作 SoC 的硬件寄存器（如 IOMUXC 寄存器）。</p>
</li>
<li>
<p><strong>关联：</strong> <code>struct pinctrl_desc</code> 的 <code>pinmux_ops</code> 字段会指向这个结构体。</p>
</li>
</ul>
<h4 id="struct-pinconf_ops"><a class="markdownIt-Anchor" href="#struct-pinconf_ops"></a> <code>struct pinconf_ops</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 获取引脚配置参数</span></span><br><span class="line">    <span class="type">int</span> (*pin_config_get)(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> pin,</span><br><span class="line">                          <span class="type">unsigned</span> <span class="type">long</span> *config);</span><br><span class="line">    <span class="comment">// -- 核心功能，用于设置引脚配置 --</span></span><br><span class="line">    <span class="type">int</span> (*pin_config_set)(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> pin,</span><br><span class="line">                          <span class="type">unsigned</span> <span class="type">long</span> *configs, <span class="type">unsigned</span> <span class="type">int</span> num_configs);</span><br><span class="line">    <span class="type">int</span> (*pin_config_group_set)(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">int</span> group,</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">long</span> *configs,</span><br><span class="line">                               <span class="type">unsigned</span> <span class="type">int</span> num_configs);</span><br><span class="line">    <span class="comment">// 其他与引脚配置相关的操作...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 定义了 Pin Controller 驱动进行 <strong>引脚电气特性配置</strong>（Pin Configuration）操作的接口。<code>pin_config_set</code> 或 <code>pin_config_group_set</code> 是其核心，负责设置引脚的电气属性，如上拉/下拉、驱动强度、速率、施密特触发等。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 它是 <strong>静态定义</strong> 在 Pin Controller 驱动源代码中，由驱动开发者实现具体的函数逻辑，这些函数会直接操作 SoC 的硬件寄存器（如 Pad Control 寄存器）。</p>
</li>
<li>
<p><strong>关联：</strong> <code>struct pinctrl_desc</code> 的 <code>pinconf_ops</code> 字段会指向这个结构体。</p>
</li>
</ul>
<h4 id="struct-pinctrl_desc"><a class="markdownIt-Anchor" href="#struct-pinctrl_desc"></a> <code>struct pinctrl_desc</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    owner: THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向 Pin Controller 的各种操作方法</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pinctrl_ops</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pinmux_ops</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">pinconf_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 核心：这个Pin Controller硬件所能管理的物理引脚清单 --</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span> <span class="comment">// 指向 pinctrl_pin_desc 数组的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> npins;                  <span class="comment">// 数组中引脚的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他内部使用字段...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 这是一个 Pin Controller 驱动向 <code>pinctrl</code> Core 注册时提供的 <strong>核心“名片”</strong>。它描述了该 Pin Controller 硬件的 <strong>固有能力和接口</strong>。其中包括它能管理的 <strong>所有物理引脚的列表</strong>（通过 <code>pins</code> 和 <code>npins</code>）以及如何进行引脚复用和配置的操作集合（通过 <code>*_ops</code> 字段）。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 它是 <strong>静态定义</strong> 在 Pin Controller 驱动源代码中，由驱动开发者根据 SoC 硬件手册和驱动实现进行初始化。它 <strong>不直接从设备树获取信息</strong>，而是作为设备树解析的基石。</p>
</li>
</ul>
<h4 id="struct-pinctrl_dev"><a class="markdownIt-Anchor" href="#struct-pinctrl_dev"></a> <code>struct pinctrl_dev</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span> <span class="comment">// 指向其描述 pinctrl_desc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pin Controller 自身管理的 Pin Group 和 Pin Function 信息</span></span><br><span class="line">    <span class="comment">// (这些通常由 pinctrl_ops/pinmux_ops 的 get_XXX 方法返回)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他内部管理字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 用于将所有 pinctrl_dev 实例链到全局列表中</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 这是 <code>pinctrl</code> Core 为每个注册的 Pin Controller 动态创建的 <strong>运行时实例</strong>。它代表了内核中一个活动的 Pin Controller 硬件。<code>pinctrl_Core</code> 通过 <code>pinctrl_dev</code> 来与特定的 Pin Controller 驱动进行通信和操作。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 由 <code>pinctrl</code> Core 在 Pin Controller 驱动的 <code>probe</code> 函数中调用 <code>devm_pinctrl_register()</code> 时 <strong>动态分配内存和初始化</strong>。它会复制 <code>pinctrl_desc</code> 中的关键信息（如 <code>desc</code> 指针）并进行内部管理。</p>
</li>
<li>
<p><strong>关联：</strong> 所有注册的 <code>pinctrl_dev</code> 实例会被组织在一个全局链表（<code>pinctrldev_list</code>）中，供 <code>pinctrl</code> Core 查找和使用。</p>
</li>
</ul>
<h4 id="struct-device_node"><a class="markdownIt-Anchor" href="#struct-device_node"></a> <code>struct device_node</code></h4>
<ul>
<li><strong>定义：</strong> Linux 内核中对设备树中一个节点的抽象表示。</li>
<li><strong>目的：</strong> 设备树中的每个节点（例如 <code>/soc/bus@20e0000</code>, <code>/soc/uart@21e8000</code>, <code>pinctrl_uart2grp</code> 等）都会被解析成一个 <code>struct device_node</code> 实例。它包含了节点的名称、属性（如 <code>compatible</code>, <code>reg</code>, <code>fsl,pins</code> 等）以及子节点。</li>
<li><strong>来源/初始化：</strong> 由内核的 Device Tree 解析器在系统启动早期 <strong>动态生成</strong>。</li>
<li><strong>关联：</strong> <code>/soc/pinctrl@...</code> 节点会触发 Pin Controller 驱动的 <code>probe</code>；Client 设备节点（如 UART）会通过 <code>pinctrl-N</code> 属性引用引脚组节点。</li>
</ul>
<h4 id="struct-pinctrl_map"><a class="markdownIt-Anchor" href="#struct-pinctrl_map"></a> <code>struct pinctrl_map</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dev_name;   <span class="comment">// 关联的设备名称 (如 &quot;serial8250.0&quot;)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *state_name; <span class="comment">// 关联的引脚状态名称 (如 &quot;default&quot;, &quot;idle&quot;)</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span> <span class="comment">// 映射的类型：MUX 还是 CONFIG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_conf_item</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> group;      <span class="comment">// 对应的引脚组ID</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> configs[]; <span class="comment">// 配置参数（对于PIN_MAP_TYPE_CONFIGS_GROUP）</span></span><br><span class="line">    &#125; conf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux_item</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> group;      <span class="comment">// 对应的引脚组ID</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> function;   <span class="comment">// 对应的功能ID</span></span><br><span class="line">    &#125; mux;</span><br><span class="line">    <span class="comment">// 其他内部字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> <code>pinctrl_map</code> 是将 Device Tree 中描述的抽象引脚配置（如 <code>fsl,pins = &lt;...&gt;</code>）<strong>初步解析</strong> 后形成的一种通用表示。它告诉 Core &quot;某个设备在某个状态下，需要某个 Pin Controller 的某个引脚组进行某个复用或配置操作&quot;。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 由 <strong>Pin Controller 驱动的 <code>dt_node_to_map</code> 函数</strong> 在解析设备树中引脚组节点时 <strong>动态分配和填充</strong>。<code>dt_node_to_map</code> 会根据其 SoC 特有的 Device Tree 属性（如 <code>fsl,pins</code>, <code>st,pins</code> 等）来生成一个或多个 <code>pinctrl_map</code>。</p>
</li>
<li>
<p><strong>关联：</strong> 这些 <code>pinctrl_map</code> 实例会被收集到 <code>struct pinctrl</code> 实例的 <code>dt_maps</code> 链表中。</p>
</li>
</ul>
<h4 id="struct-pinctrl_setting"><a class="markdownIt-Anchor" href="#struct-pinctrl_setting"></a> <code>struct pinctrl_setting</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span> <span class="comment">// 关联的 pinctrl_dev 实例</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type;           <span class="comment">// 类型：PIN_MAP_TYPE_MUX_GROUP 或 PIN_MAP_TYPE_CONFIGS_GROUP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> group_id;       <span class="comment">// 引脚组的ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> function_id;    <span class="comment">// 功能的ID (仅对 MUX 类型有效)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *configs;      <span class="comment">// 配置参数数组 (仅对 CONFIG 类型有效)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num_configs;    <span class="comment">// 配置参数数量</span></span><br><span class="line">    <span class="comment">// 其他内部字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> <code>pinctrl_setting</code> 是比 <code>pinctrl_map</code> 更进一步的、<strong>可执行的</strong> 引脚操作单元。它包含了执行某个引脚复用或配置操作所需的所有明确信息（哪个 Pin Controller，哪个引脚组，哪个功能/配置值）。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 由 <strong><code>pinctrl</code> Core 动态分配和填充</strong>。Core 会在内部将 <code>pinctrl_map</code> 列表转换为 <code>pinctrl_setting</code> 列表。这个转换过程包括了将引脚组名称转换为其在 <code>pinctrl_desc.pins</code> 中对应的 <code>group_id</code>。</p>
</li>
<li>
<p><strong>关联：</strong> 多个 <code>pinctrl_setting</code> 实例会被组织在一个 <code>struct pinctrl_state</code> 的 <code>settings</code> 链表中。</p>
</li>
</ul>
<h4 id="struct-pinctrl_state"><a class="markdownIt-Anchor" href="#struct-pinctrl_state"></a> <code>struct pinctrl_state</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pctl</span>;</span>        <span class="comment">// 指向父 pinctrl 句柄</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">// 状态名称 (&quot;default&quot;, &quot;idle&quot; 等)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span>   <span class="comment">// 该状态下需要执行的所有 pinctrl_setting 链表</span></span><br><span class="line">    <span class="comment">// 其他内部字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>      <span class="comment">// 用于链入 pinctrl 句柄的 pinctrl_states 列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 代表 Client 设备在某个 <strong>特定命名状态</strong>（如 &quot;default&quot;、&quot;idle&quot;、&quot;sleep&quot; 等）下所需的所有引脚配置和复用。一个 <code>pinctrl_state</code> 包含了在该状态下需要执行的 <strong>所有 <code>pinctrl_setting</code></strong>。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 由 <code>pinctrl</code> Core 在解析 Client 设备的 Device Tree 时 <strong>动态分配和填充</strong>，特别是解析 <code>pinctrl-names</code> 和 <code>pinctrl-N</code> 属性时。</p>
</li>
<li>
<p><strong>关联：</strong> 存储在 <code>struct pinctrl</code> 实例内部。</p>
</li>
</ul>
<h4 id="struct-pinctrl"><a class="markdownIt-Anchor" href="#struct-pinctrl"></a> <code>struct pinctrl</code></h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>         <span class="comment">// 关联的客户端设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span>   <span class="comment">// 从设备树解析出的 pinctrl_map 列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pinctrl_states</span>;</span> <span class="comment">// 该设备所有 pinctrl_state 列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他内部管理字段</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 这是 <code>pinctrl</code> Core 提供给 <strong>Client 设备驱动</strong> 的一个 <strong>句柄</strong>。每个 Client 设备通过这个句柄来管理其所有的引脚状态。它内部包含了该设备从设备树中解析出的所有引脚映射 (<code>dt_maps</code>) 和组织好的引脚状态 (<code>pinctrl_states</code>)。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 由 <code>pinctrl</code> Core 在 Client 设备驱动调用 <code>devm_pinctrl_get()</code> 时 <strong>动态分配和初始化</strong>。</p>
</li>
<li>
<p><strong>关联：</strong> 每个 Client 设备的 <code>struct device</code> 结构体中包含一个 <code>struct dev_pin_info</code> 成员，其内部存储了指向这个 <code>struct pinctrl</code> 实例的指针。</p>
</li>
</ul>
<h4 id="struct-dev_pin_info-在-struct-device-中"><a class="markdownIt-Anchor" href="#struct-dev_pin_info-在-struct-device-中"></a> <code>struct dev_pin_info</code> (在 <code>struct device</code> 中)</h4>
<ul>
<li>
<p><strong>定义：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>             <span class="comment">// 指向该设备关联的 pinctrl 句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span>       <span class="comment">// 该设备所有 pinctrl_state 的列表 (与 p-&gt;pinctrl_states 相同)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span>     <span class="comment">// 该设备所有 pinctrl_map 的列表 (与 p-&gt;dt_maps 相同</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span> <span class="comment">// 默认状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span>    <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">current_state</span>;</span> <span class="comment">// 当前激活状态</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// struct device &#123;</span></span><br><span class="line"><span class="comment">//    struct dev_pin_info  pin; // 每个设备都有这个成员</span></span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>目的：</strong> 这是 <code>struct device</code> 结构体中的一个内置成员，用于存储与该设备相关的 <code>pinctrl</code> 句柄和其他引脚管理信息。它是 Client 设备驱动最直接的 <code>pinctrl</code> 交互入口。</p>
</li>
<li>
<p><strong>来源/初始化：</strong> 它是 <code>struct device</code> 自身的一部分。在 Client 驱动调用 <code>devm_pinctrl_get()</code> 成功后，返回的 <code>struct pinctrl</code> 实例会被赋值给 <code>struct device.pin.p</code>，并且由 <code>pinctrl</code> Core 管理其内部的 <code>states</code> 和 <code>dt_maps</code> 列表。</p>
</li>
</ul>
<h3 id="pinctrl-子系统的工作流程从初始化到应用"><a class="markdownIt-Anchor" href="#pinctrl-子系统的工作流程从初始化到应用"></a> <code>pinctrl</code> 子系统的工作流程：从初始化到应用</h3>
<p>整个 <code>pinctrl</code> 子系统的工作可以分为几个主要阶段：</p>
<h4 id="阶段一pin-controller-驱动的初始化-静态定义与注册"><a class="markdownIt-Anchor" href="#阶段一pin-controller-驱动的初始化-静态定义与注册"></a> 阶段一：Pin Controller 驱动的初始化 (静态定义与注册)</h4>
<p>这个阶段，主要工作是让 <code>pinctrl</code> Core 知道系统中存在哪些 Pin Controller 硬件，以及它们具备哪些能力。</p>
<ol>
<li>
<p><strong>Pin Controller 驱动的静态定义：</strong></p>
<ul>
<li>在 Pin Controller 驱动的源代码 (<code>.c</code> 文件) 中，开发者根据 SoC 硬件手册，<strong>静态地定义</strong> <code>struct pinctrl_pin_desc</code> 数组（即 <code>pins</code> 数组及其 <code>npins</code> 大小），列出该控制器能管理的所有物理引脚。</li>
<li>同时，<strong>静态地实现</strong> 并定义 <code>struct pinctrl_ops</code>、<code>struct pinmux_ops</code> 和 <code>struct pinconf_ops</code> 结构体中的函数。这些函数包含了与底层 Pin Controller 硬件寄存器直接交互的逻辑。</li>
<li>最后，<strong>静态地初始化</strong> <code>struct pinctrl_desc</code> 实例，将上述所有静态定义的数组和操作函数集关联起来。这个 <code>pinctrl_desc</code> 是对 Pin Controller 硬件能力的全面描述。</li>
</ul>
</li>
<li>
<p><strong>Pin Controller 驱动的 <code>probe</code> 阶段与注册：</strong></p>
<ul>
<li>当 Linux 内核启动并解析设备树时，如果它发现一个符合某个 Pin Controller 驱动 <code>compatible</code> 属性的设备节点（例如，<code>pinctrl@20e0000 &#123; compatible = &quot;fsl,imx6ul-pinctrl&quot;; ... &#125;;</code>），则会加载对应的 Pin Controller 驱动并调用其 <code>platform_driver</code> 的 <code>probe</code> 函数。</li>
<li>在 <code>probe</code> 函数中，Pin Controller 驱动会调用 <code>devm_pinctrl_register(&amp;pdev-&gt;dev, &amp;imx_pinctrl_desc, drv_data);</code>。</li>
<li><code>pinctrl</code> Core 收到这个请求后：
<ul>
<li><strong>动态分配</strong> <code>struct pinctrl_dev</code> 内存并进行初始化。</li>
<li>将 <code>imx_pinctrl_desc</code> 的指针保存到 <code>pinctrl_dev</code> 的 <code>desc</code> 字段中。</li>
<li>将新创建的 <code>pinctrl_dev</code> 实例添加到其内部维护的全局 <code>pinctrldev_list</code> 链表中。</li>
</ul>
</li>
<li>至此，<code>pinctrl</code> Core 已经知道系统中存在哪个 Pin Controller，以及如何通过其 <code>pinctrl_dev</code> 实例调用它所提供(<code>pinctrl_desc</code> 指向的 <code>*_ops</code>)的各种引脚操作服务。</li>
</ul>
</li>
</ol>
<h4 id="阶段二client-设备驱动的初始化与引脚状态解析-动态解析-device-tree"><a class="markdownIt-Anchor" href="#阶段二client-设备驱动的初始化与引脚状态解析-动态解析-device-tree"></a> 阶段二：Client 设备驱动的初始化与引脚状态解析 (动态解析 Device Tree)</h4>
<p>Client 设备驱动在其 <code>probe</code> 函数中，会向 <code>pinctrl</code> 子系统请求获取对其引脚的控制权限。这个阶段，<code>pinctrl</code> Core 会依据设备树信息，为 Client 设备构建其引脚状态图。</p>
<ol>
<li>
<p><strong>Client 驱动请求 <code>pinctrl</code> 句柄：</strong></p>
<ul>
<li>在 Client 设备驱动的 <code>probe</code> 函数中，会调用 <code>pinctrl_get_and_init(struct device *dev, bool init_default)</code> 或 <code>devm_pinctrl_get(struct device *dev)</code>。这通常是驱动对 <code>pinctrl</code> 子系统的第一个调用。</li>
<li>返回值是一个 <code>struct pinctrl *</code> 类型的句柄，这个句柄会被存储在 Client 设备的 <code>struct device.pin.p</code> 成员中。</li>
</ul>
</li>
<li>
<p><strong><code>pinctrl</code> Core 解析设备树并调用 <code>dt_node_to_map</code>：</strong></p>
<ul>
<li><code>pinctrl</code> Core 接收到 <code>pinctrl_get</code> 调用后，会根据 Client 设备的 <code>struct device</code> 关联的 <code>struct device_node</code>，查找其设备树中的相关属性：
<ul>
<li><code>pinctrl-names</code>：此属性列出了该设备支持的引脚命名状态（如 &quot;default&quot;, &quot;idle&quot;）。</li>
<li><code>pinctrl-0</code>, <code>pinctrl-1</code> 等：这些属性指向具体的引脚组节点，如 <code>pinctrl-0 = &lt;&amp;pinctrl_uart2&gt;;</code>。</li>
</ul>
</li>
<li>对于每个引脚组节点（例如 <code>pinctrl_uart2</code>）：
<ul>
<li><code>pinctrl</code> Core 会解析其 <code>phandle</code> (即 <code>&amp;pinctrl_uart2</code> 所指向的实际 Device Tree 节点)，识别出它属于哪个 Pin Controller（通过遍历全局 <code>pinctrldev_list</code> 找到匹配的 <code>pinctrl_dev</code>）。</li>
<li>找到对应的 <code>pinctrl_dev</code> 后，<code>pinctrl</code> Core 会调用该 <code>pinctrl_dev</code> 中其 <code>pinctrl_ops</code> 字段注册的 <strong><code>dt_node_to_map</code> 函数</strong>（这是一个由 Pin Controller 驱动实现的特有函数）。</li>
<li><code>dt_node_to_map</code> 函数的工作是 <strong>解析输入的设备树引脚组节点</strong>（例如 <code>pinctrl_uart2</code> 节点），并提取出其中 SoC 特有的引脚复用和配置信息（如 <code>fsl,pins</code> 属性中的 <code>MX6UL_PAD_UART2_TX_DATA__UART2_TX_DATA 0x1b0b1</code>）。</li>
<li>该函数会根据解析出的信息 <strong>动态分配并返回一个 <code>struct pinctrl_map</code> 数组</strong> 给 <code>pinctrl</code> Core。每个 <code>pinctrl_map</code> 描述一个要进行的复用或配置操作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>pinctrl_setting</code> 和 <code>pinctrl_state</code> 的创建：</strong></p>
<ul>
<li><code>pinctrl</code> Core 拿到 <code>pinctrl_map</code> 数组后，会将其转换为更直接的 <strong>可执行操作</strong> 集合。</li>
<li>对于每个从 <code>dt_node_to_map</code> 返回的 <code>pinctrl_map</code>：
<ul>
<li><code>pinctrl</code> Core 会 <strong>动态分配并初始化一个 <code>struct pinctrl_setting</code></strong>。</li>
<li>将 <code>pinctrl_map</code> 中的信息（引脚组 ID、功能 ID 或配置值）复制到 <code>pinctrl_setting</code> 中，并确保 <code>pctldev</code> 指针指向正确的 Pin Controller 实例。</li>
<li>这些 <code>pinctrl_setting</code> 会被链接到对应的 <code>struct pinctrl_state</code> 的 <code>settings</code> 链表中。</li>
</ul>
</li>
<li>对于设备树中每一个定义的命名状态（如 &quot;default&quot;, &quot;idle&quot;），<code>pinctrl</code> Core 都会 <strong>动态分配并初始化一个 <code>struct pinctrl_state</code></strong>。</li>
<li>这些 <code>pinctrl_state</code> 实例会被存储在 Client 设备的 <code>struct pinctrl</code> 句柄内部（<code>pinctrl-&gt;pinctrl_states</code> 链表）。</li>
</ul>
</li>
</ol>
<p>至此，Client 设备所需要的所有引脚配置，已经从设备树的文本描述，被完全解析并组织成内核中一系列 <code>pinctrl_state</code> 和 <code>pinctrl_setting</code> 结构，等待被激活。</p>
<h4 id="阶段三应用-pinctrl_setting-选择状态与实际硬件绑定"><a class="markdownIt-Anchor" href="#阶段三应用-pinctrl_setting-选择状态与实际硬件绑定"></a> 阶段三：应用 <code>pinctrl_setting</code> (选择状态与实际硬件“绑定”)</h4>
<p>这个阶段是真正让引脚功能复用和电气配置生效的时刻。</p>
<ol>
<li>
<p><strong>Client 驱动激活引脚状态：</strong></p>
<ul>
<li>在 Client 设备的 <code>probe</code> 函数中（通常在其功能启用前）或在运行时需要切换引脚配置时，Client 驱动会调用 <code>pinctrl_select_state(pinctrl_obj, state_handle)</code>，例如 <code>pinctrl_select_state(dev-&gt;pin.p, dev-&gt;pin.default_state);</code>。</li>
</ul>
</li>
<li>
<p><strong><code>pinctrl</code> Core 遍历并调用底层操作函数 (<code>bind</code> 过程)：</strong></p>
<ul>
<li><code>pinctrl_select_state</code> 函数会根据传入的 <code>state_handle</code> 找到对应的 <code>struct pinctrl_state</code> 实例。</li>
<li>接着，<code>pinctrl</code> Core 会 <strong>遍历</strong> 该 <code>pinctrl_state</code> 内部的 <code>settings</code> 链表，执行其中的每一个 <code>struct pinctrl_setting</code>。这个遍历和执行的过程，可以被理解为您提到的“bind”过程——将逻辑配置 <strong>绑定</strong> 到实际的硬件操作上。</li>
<li>对于链表中的每一个 <code>pinctrl_setting</code>：
<ul>
<li><code>pinctrl</code> Core 首先检查 <code>setting-&gt;type</code> 字段（是 <code>PIN_MAP_TYPE_MUX_GROUP</code> 还是 <code>PIN_MAP_TYPE_CONFIGS_GROUP</code>）。</li>
<li><strong>如果是引脚复用 (<code>PIN_MAP_TYPE_MUX_GROUP</code>)：</strong>
<ul>
<li><code>pinctrl</code> Core 会通过 <code>setting-&gt;pctldev</code> 指针找到对应的 <code>struct pinctrl_dev</code> 实例。</li>
<li>然后调用该 <code>pinctrl_dev</code> 中 <code>pinmux_ops</code> 注册的 <strong><code>set_mux</code> 函数</strong>。</li>
<li><code>set_mux</code> 函数（由 Pin Controller 驱动实现）接收引脚组 ID 和功能 ID，并执行 <strong>实际的硬件寄存器写入操作</strong>（例如写入 IOMUXC 模块的 SPR/SION/MUX 寄存器），从而将引脚复用为所需功能。</li>
</ul>
</li>
<li><strong>如果是引脚配置 (<code>PIN_MAP_TYPE_CONFIGS_GROUP</code>)：</strong>
<ul>
<li><code>pinctrl</code> Core 同样通过 <code>setting-&gt;pctldev</code> 找到对应的 <code>struct pinctrl_dev</code> 实例。</li>
<li>然后调用该 <code>pinctrl_dev</code> 中 <code>pinconf_ops</code> 注册的 <strong><code>pin_config_group_set</code> 函数</strong>。</li>
<li><code>pin_config_group_set</code> 函数（由 Pin Controller 驱动实现）接收引脚组 ID 和配置参数，并执行 <strong>实际的硬件寄存器写入操作</strong>（例如写入 Pad Control 模块的 PAD 配置寄存器），从而设置引脚的电气特性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>至此，一个从设备树中定义的引脚配置，经过层层解析和转换，最终通过 Pin Controller 驱动的底层操作函数，成功作用于 SoC 的物理引脚，使得外设能够正常工作。</p>
<h3 id="结构体来源与初始化关系总结表"><a class="markdownIt-Anchor" href="#结构体来源与初始化关系总结表"></a> 结构体来源与初始化关系总结表</h3>
<table>
<thead>
<tr>
<th style="text-align:left">结构体名称</th>
<th style="text-align:left">来源/初始化方式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">主要使用者/存储地</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>pinctrl_pin_desc</code></td>
<td style="text-align:left"><strong>静态定义</strong> 于 Pin Controller 驱动源码中</td>
<td style="text-align:left">描述一个独立的物理引脚（ID、名称）</td>
<td style="text-align:left"><code>pinctrl_desc</code> 的 <code>pins</code> 字段指向它</td>
<td style="text-align:left">反映 SoC 硬件总引脚清单</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl_ops</code></td>
<td style="text-align:left"><strong>静态定义</strong> 于 Pin Controller 驱动源码中</td>
<td style="text-align:left">定义 Pin Controller 核心操作函数（如 <code>dt_node_to_map</code>）</td>
<td style="text-align:left"><code>pinctrl_desc</code> 引用它</td>
<td style="text-align:left">由驱动开发者实现，解析 Device Tree</td>
</tr>
<tr>
<td style="text-align:left"><code>pinmux_ops</code></td>
<td style="text-align:left"><strong>静态定义</strong> 于 Pin Controller 驱动源码中</td>
<td style="text-align:left">定义引脚复用操作函数（如 <code>set_mux</code>）</td>
<td style="text-align:left"><code>pinctrl_desc</code> 引用它</td>
<td style="text-align:left">由驱动开发者实现，直接操作硬件</td>
</tr>
<tr>
<td style="text-align:left"><code>pinconf_ops</code></td>
<td style="text-align:left"><strong>静态定义</strong> 于 Pin Controller 驱动源码中</td>
<td style="text-align:left">定义引脚配置操作函数（如 <code>pin_config_group_set</code>）</td>
<td style="text-align:left"><code>pinctrl_desc</code> 引用它</td>
<td style="text-align:left">由驱动开发者实现，直接操作硬件</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl_desc</code></td>
<td style="text-align:left"><strong>静态定义</strong> 于 Pin Controller 驱动源码中</td>
<td style="text-align:left">Pin Controller 硬件的“蓝图”，描述其所有能力和操作接口</td>
<td style="text-align:left">在 <code>probe</code> 中传给 <code>pinctrl_register</code></td>
<td style="text-align:left">驱动对 Core 的“自我介绍”</td>
</tr>
<tr>
<td style="text-align:left"><code>device_node</code></td>
<td style="text-align:left"><strong>由内核 Device Tree 解析器动态生成</strong> 于系统启动时</td>
<td style="text-align:left">设备树中一个节点的内存表示，包含属性和子节点</td>
<td style="text-align:left"><code>struct device</code> 内部引用，<code>pinctrl</code> Core 用于解析和定位</td>
<td style="text-align:left">设备树的抽象表现</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl_dev</code></td>
<td style="text-align:left"><strong>由 <code>pinctrl</code> Core 动态分配</strong> 于 <code>pinctrl_register</code> 时</td>
<td style="text-align:left">一个 Pin Controller 硬件在内核中的运行时实例，管理相关资源</td>
<td style="text-align:left"><code>pinctrldev_list</code> 全局链表，<code>pinctrl_setting</code> 引用</td>
<td style="text-align:left">Core 通过此实例与特定驱动交互</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl_map</code></td>
<td style="text-align:left"><strong>由 Pin Controller 驱动的 <code>dt_node_to_map</code> 动态生成</strong></td>
<td style="text-align:left">从 Device Tree 节点转换而来的初步引脚配置映射（相对抽象）</td>
<td style="text-align:left">存储在 <code>struct pinctrl</code> 的 <code>dt_maps</code> 链表中</td>
<td style="text-align:left">驱动解析 DT 后的中间产物</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl_setting</code></td>
<td style="text-align:left"><strong>由 <code>pinctrl</code> Core 动态生成</strong>，从 <code>pinctrl_map</code> 转换而来</td>
<td style="text-align:left">表示一个具体的、可执行的引脚复用或配置操作</td>
<td style="text-align:left">存储在 <code>pinctrl_state</code> 的 <code>settings</code> 链表中</td>
<td style="text-align:left">“可执行指令”</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl_state</code></td>
<td style="text-align:left"><strong>由 <code>pinctrl</code> Core 动态分配和生成</strong></td>
<td style="text-align:left">特定命名状态 (<code>default</code>, <code>idle</code>) 下的所有引脚配置集合</td>
<td style="text-align:left">存储在 <code>struct pinctrl</code> 内部的 <code>pinctrl_states</code> 链表</td>
<td style="text-align:left">将多个 <code>pinctrl_setting</code> 归为一个状态</td>
</tr>
<tr>
<td style="text-align:left"><code>pinctrl</code> (句柄)</td>
<td style="text-align:left"><strong>由 <code>pinctrl</code> Core 动态分配和生成</strong> 于 Client 驱动调用 <code>devm_pinctrl_get()</code> 时</td>
<td style="text-align:left">Client 设备与 <code>pinctrl</code> 子系统交互的句柄，管理其所有引脚状态</td>
<td style="text-align:left">存储在 Client 设备的 <code>struct device.pin.p</code> 字段中</td>
<td style="text-align:left">Client 驱动的 APIs 入口</td>
</tr>
<tr>
<td style="text-align:left"><code>dev_pin_info</code></td>
<td style="text-align:left"><strong><code>struct device</code> 内置成员</strong></td>
<td style="text-align:left">存储 Client 设备关联的 <code>pinctrl</code> 句柄及相关引脚管理信息</td>
<td style="text-align:left"><code>struct device</code> 内部的 <code>pin</code> 字段</td>
<td style="text-align:left">设备自身管理引脚的结构，包含了 <code>pinctrl</code> 句柄</td>
</tr>
</tbody>
</table>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><code>pinctrl</code> 子系统通过严格的分层和职责分离，实现了硬件抽象。</p>
<ul>
<li><strong>Pin Controller 驱动</strong> 负责硬件层面的具体操作（读写寄存器），并向 <code>pinctrl</code> Core 暴露其能力 (<code>pinctrl_desc</code>) 和操作接口 (<code>*_ops</code>)。这些是 <strong>静态定义</strong> 的，不依赖设备树。</li>
<li><strong>Device Tree</strong> 负责描述特定板级设计下，各个 Client 设备如何使用和配置引脚（定义引脚组及其属性）。它提供的是 <strong>配置意图</strong>。</li>
<li><strong><code>pinctrl</code> Core</strong> 是整个系统的 <strong>协调者</strong>。它：
<ol>
<li>接收 Pin Controller 驱动的注册 (<code>pinctrl_register</code>)。</li>
<li>根据 Client 设备的设备树配置，调用 Pin Controller 驱动特有的 <code>dt_node_to_map</code> 函数来解析引脚组信息，并从中生成抽象的 <code>pinctrl_map</code> 和可执行的 <code>pinctrl_setting</code>。</li>
<li>在运行时，当 Client 驱动请求激活某个状态时，<code>pinctrl</code> Core 遍历对应的 <code>pinctrl_setting</code> 列表，并调用正确的 Pin Controller 驱动的底层操作函数 (<code>set_mux</code>, <code>pin_config_group_set</code>) 来实际操作硬件。</li>
</ol>
</li>
</ul>
<p>这种设计使得 Client 驱动无需关心底层硬件的复杂性，只需通过 <code>pinctrl</code> APIs 请求引脚状态即可；同时，Pin Controller 驱动也只需实现其硬件接口，而无需了解所有 Client 设备的具体需求。这大大提高了代码的可维护性和复用性。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%9D"><span class="toc-number">1.</span> <span class="toc-text"> 嵌入式学习（九）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-linux-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. Linux pinctrl 子系统深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. pinctrl 子系统核心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%83%8C%E6%99%AF%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 1.1 背景与目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 1.2 核心目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-device-tree-%E4%B8%AD%E7%9A%84-pinctrl-%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. Device Tree 中的 pinctrl 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-pinctrl-%E9%85%8D%E7%BD%AE%E7%AB%AF-%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 2.1 Pinctrl 配置端 (硬件能力描述)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-pinctrl-%E5%BC%95%E7%94%A8%E7%AB%AF-%E8%AE%BE%E5%A4%87%E7%89%B9%E5%AE%9A%E5%BC%95%E8%84%9A%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 2.2 Pinctrl 引用端 (设备特定引脚需求)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-pinctrl-%E5%AE%9E%E7%8E%B0-gpio-%E5%A4%8D%E7%94%A8%E5%8F%8A%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. pinctrl 实现 GPIO 复用及状态切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> 3.1 核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> 3.2 运行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-default-%E4%B8%8E-sleep-%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.3.</span> <span class="toc-text"> 3.3 default 与 sleep 状态切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84core-%E7%A1%AC%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. pinctrl 子系统架构：Core + 硬件驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41-pinctrl-core-%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text"> 4.1 pinctrl Core 的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-struct-pin_control_description"><span class="toc-number">1.1.4.2.</span> <span class="toc-text"> 4.2 struct pin_control_description</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA-gpio-%E5%A4%8D%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5. 与单片机 GPIO 复用对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-linux-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%90%84%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. Linux pinctrl 子系统各个结构体和工作调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 引言与核心概念回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 关键结构体详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_pin_desc"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"> struct pinctrl_pin_desc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_ops"><span class="toc-number">1.2.2.2.</span> <span class="toc-text"> struct pinctrl_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinmux_ops"><span class="toc-number">1.2.2.3.</span> <span class="toc-text"> struct pinmux_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinconf_ops"><span class="toc-number">1.2.2.4.</span> <span class="toc-text"> struct pinconf_ops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_desc"><span class="toc-number">1.2.2.5.</span> <span class="toc-text"> struct pinctrl_desc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_dev"><span class="toc-number">1.2.2.6.</span> <span class="toc-text"> struct pinctrl_dev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-device_node"><span class="toc-number">1.2.2.7.</span> <span class="toc-text"> struct device_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_map"><span class="toc-number">1.2.2.8.</span> <span class="toc-text"> struct pinctrl_map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_setting"><span class="toc-number">1.2.2.9.</span> <span class="toc-text"> struct pinctrl_setting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl_state"><span class="toc-number">1.2.2.10.</span> <span class="toc-text"> struct pinctrl_state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-pinctrl"><span class="toc-number">1.2.2.11.</span> <span class="toc-text"> struct pinctrl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-dev_pin_info-%E5%9C%A8-struct-device-%E4%B8%AD"><span class="toc-number">1.2.2.12.</span> <span class="toc-text"> struct dev_pin_info (在 struct device 中)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%B0%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text"> pinctrl 子系统的工作流程：从初始化到应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80pin-controller-%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-%E9%9D%99%E6%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="toc-number">1.2.3.1.</span> <span class="toc-text"> 阶段一：Pin Controller 驱动的初始化 (静态定义与注册)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8Cclient-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%A3%E6%9E%90-device-tree"><span class="toc-number">1.2.3.2.</span> <span class="toc-text"> 阶段二：Client 设备驱动的初始化与引脚状态解析 (动态解析 Device Tree)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%E5%BA%94%E7%94%A8-pinctrl_setting-%E9%80%89%E6%8B%A9%E7%8A%B6%E6%80%81%E4%B8%8E%E5%AE%9E%E9%99%85%E7%A1%AC%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">1.2.3.3.</span> <span class="toc-text"> 阶段三：应用 pinctrl_setting (选择状态与实际硬件“绑定”)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E6%BA%90%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 结构体来源与初始化关系总结表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&text=嵌入式学习（九）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&is_video=false&description=嵌入式学习（九）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=嵌入式学习（九）&body=Check out this article: https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&title=嵌入式学习（九）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&name=嵌入式学习（九）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/&t=嵌入式学习（九）"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
