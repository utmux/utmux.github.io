<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：一般   深入剖析 Linux pinctrl 子系统：原理、流程与实践  1. pinctrl 子系统核心思想与架构总览 背景： 现代 SoC (System on Chip) 拥有大量的物理引脚，这些引脚往往具备多功能复用（Pin Multiplexing）能力，并且需要精细配置其电气特性（Pin Configuration），如上拉&#x2F;下拉、驱动强度、压摆率等。传统上，设备驱">
<meta property="og:type" content="article">
<meta property="og:title" content="深入剖析 Linux pinctrl子系统：原理、流程与实践">
<meta property="og:url" content="https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：一般   深入剖析 Linux pinctrl 子系统：原理、流程与实践  1. pinctrl 子系统核心思想与架构总览 背景： 现代 SoC (System on Chip) 拥有大量的物理引脚，这些引脚往往具备多功能复用（Pin Multiplexing）能力，并且需要精细配置其电气特性（Pin Configuration），如上拉&#x2F;下拉、驱动强度、压摆率等。传统上，设备驱">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-24T14:19:55.000Z">
<meta property="article:modified_time" content="2025-07-24T14:19:57.521Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>深入剖析 Linux pinctrl子系统：原理、流程与实践</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/07/25/work/%E9%9F%A6%E4%B8%9C%E5%B1%B1Pinctrl%E7%B3%BB%E7%BB%9F%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/07/21/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&text=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&is_video=false&description=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入剖析 Linux pinctrl子系统：原理、流程与实践&body=Check out this article: https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&name=深入剖析 Linux pinctrl子系统：原理、流程与实践&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&t=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-linux-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text"> 深入剖析 Linux pinctrl 子系统：原理、流程与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 1. pinctrl 子系统核心思想与架构总览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.0.1.1.</span> <span class="toc-text"> 总体工作流程图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-device-tree-%E4%B8%AD%E7%9A%84-pinctrl-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.2.</span> <span class="toc-text"> 2. Device Tree 中的 pinctrl 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-pin-controller-%E9%85%8D%E7%BD%AE%E7%AB%AF-%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.0.2.1.</span> <span class="toc-text"> 2.1 Pin Controller 配置端 (硬件能力描述)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-pinctrl-%E5%BC%95%E7%94%A8%E7%AB%AF-%E8%AE%BE%E5%A4%87%E7%89%B9%E5%AE%9A%E5%BC%95%E8%84%9A%E9%9C%80%E6%B1%82"><span class="toc-number">1.0.2.2.</span> <span class="toc-text"> 2.2 Pinctrl 引用端 (设备特定引脚需求)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-pinctrl-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%9C%A8%E7%A4%BA%E4%BE%8B%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">1.0.3.</span> <span class="toc-text"> 3. pinctrl 核心结构体详解与在示例中的体现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-pin-controller-%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93-%E7%94%B1-virtual_pinctrl_driverc-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.3.1.</span> <span class="toc-text"> 3.1 Pin Controller 驱动相关结构体 (由 virtual_pinctrl_driver.c 实现)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-pinctrl-core-%E5%86%85%E9%83%A8%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%84%E4%BD%93-%E7%94%B1-pinctrl-core-%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.3.2.</span> <span class="toc-text"> 3.2 pinctrl Core 内部转换结构体 (由 pinctrl Core 管理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-client-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.3.3.</span> <span class="toc-text"> 3.3 Client 设备驱动相关结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B5%81%E7%A8%8B%E5%90%88%E5%B9%B6"><span class="toc-number">1.0.4.</span> <span class="toc-text"> 4. 驱动编写实践与流程合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1-virtual_pinctrl_driverc-pin-controller-%E9%A9%B1%E5%8A%A8-%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.0.4.1.</span> <span class="toc-text"> 步骤 1: virtual_pinctrl_driver.c (Pin Controller 驱动) 的实现与工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2-virtual_client_driverc-client-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.0.4.2.</span> <span class="toc-text"> 步骤 2: virtual_client_driver.c (Client 设备驱动) 的修改与工作流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.5.</span> <span class="toc-text"> 5. 如何编写一个 pinctrl 子系统的驱动和客户端总结</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        深入剖析 Linux pinctrl子系统：原理、流程与实践
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-24T14:19:55.000Z" class="dt-published" itemprop="datePublished">2025-07-24</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/work/">work</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：一般</p>
<hr />
<h1 id="深入剖析-linux-pinctrl-子系统原理-流程与实践"><a class="markdownIt-Anchor" href="#深入剖析-linux-pinctrl-子系统原理-流程与实践"></a> 深入剖析 Linux <code>pinctrl</code> 子系统：原理、流程与实践</h1>
<h3 id="1-pinctrl-子系统核心思想与架构总览"><a class="markdownIt-Anchor" href="#1-pinctrl-子系统核心思想与架构总览"></a> 1. <code>pinctrl</code> 子系统核心思想与架构总览</h3>
<p><strong>背景：</strong> 现代 SoC (System on Chip) 拥有大量的物理引脚，这些引脚往往具备多功能复用（Pin Multiplexing）能力，并且需要精细配置其电气特性（Pin Configuration），如上拉/下拉、驱动强度、压摆率等。传统上，设备驱动直接操作底层寄存器来完成这些配置，导致代码重复、难以维护、容易冲突且缺乏通用性。</p>
<p><strong><code>pinctrl</code> 子系统目标：</strong> 提供一个统一的、硬件无关的 API，来抽象和集中管理 SoC 上的引脚功能复用和电气特性配置。它将引脚管理从具体设备驱动中剥离，实现 <strong>抽象、集中管理、以及与电源管理框架的集成</strong>。</p>
<p><strong>架构：</strong> <code>pinctrl</code> 子系统采用经典的 <strong>“Core 系统 + 硬件驱动”</strong> 架构，与 I2C、Input 等子系统类似。</p>
<ul>
<li><strong><code>pinctrl</code> Core：</strong> 作为中间层，提供通用 API 给客户端驱动，管理所有注册的 Pin Controller 驱动实例，并处理设备树解析、资源抽象和冲突管理。</li>
<li><strong>Pin Controller 驱动：</strong> 针对特定的 SoC 硬件（如 NXP <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 系列的 IOMUXC 模块）编写，负责实现具体的硬件寄存器操作，将 <code>pinctrl</code> Core 的抽象请求转化为实际的硬件配置。</li>
<li><strong>客户端设备（Client Device）驱动：</strong> 任何需要配置引脚的外设驱动（如 UART, SPI, I2C, GPIO），它们通过 <code>pinctrl</code> Core 的 API 来声明和请求所需的引脚状态，而无需关心底层硬件细节。</li>
</ul>
<h4 id="总体工作流程图"><a class="markdownIt-Anchor" href="#总体工作流程图"></a> 总体工作流程图</h4>
<pre class="mermaid">graph TD
    subgraph 用户空间
        App[用户应用程序]
    end

    subgraph 内核空间
        ClientDriver["Client Device Driver<br>(e.g., virtual_client_driver)"] -->|1. 请求pinctrl句柄| PinctrlCore["pinctrl Core<br>(drivers/pinctrl/core.c)"]
        PinctrlCore -->|2. 调用驱动Ops| PinControllerDriver["Pin Controller Driver<br>(e.g., virtual_pinctrl_driver)"]
        PinctrlCore -->|3. 提供统一API| ClientDriver
    end

    subgraph 驱动层
        PinControllerDriver -->|4. 操作寄存器| Hardware["SoC Hardware<br>(e.g., IOMUXC Registers)"]
    end

    style App fill:#f9f,stroke:#333,stroke-width:2px
    style ClientDriver fill:#ccf,stroke:#333,stroke-width:2px
    style PinctrlCore fill:#cfc,stroke:#333,stroke-width:2px
    style PinControllerDriver fill:#fcc,stroke:#333,stroke-width:2px
    style Hardware fill:#cff,stroke:#333,stroke-width:2px</pre>
<h3 id="2-device-tree-中的-pinctrl-配置"><a class="markdownIt-Anchor" href="#2-device-tree-中的-pinctrl-配置"></a> 2. Device Tree 中的 <code>pinctrl</code> 配置</h3>
<p><code>pinctrl</code> 的配置完全通过 Device Tree (DT) 进行，分为两个主要部分：</p>
<h4 id="21-pin-controller-配置端-硬件能力描述"><a class="markdownIt-Anchor" href="#21-pin-controller-配置端-硬件能力描述"></a> 2.1 Pin Controller 配置端 (硬件能力描述)</h4>
<p>这部分通常位于 SoC 相关的 <code>.dtsi</code> 文件中，描述了 <strong>SoC 芯片固有的引脚控制器硬件的能力</strong>。</p>
<ul>
<li>
<p><strong>Pin Controller 节点：</strong> 对应 SoC 中的引脚控制器硬件。例如，我们 <code>virtual_pinctrl_driver.c</code> 匹配的节点：</p>
  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是在某个 .dtsi 或 .dts 中</span></span><br><span class="line"><span class="title class_">pinctrl@virtual_gpio_base</span> <span class="punctuation">&#123;</span> <span class="comment">// Pin Controller 节点</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;100ask,virtual_pinctrl&quot;</span><span class="punctuation">;</span> <span class="comment">// 匹配 virtual_pinctrl_driver</span></span><br><span class="line">    <span class="meta">#pinctrl-cells = &lt;PROPERTIES&gt;; <span class="comment">// 声明phandle引用时的cell数量，这里实际驱动中没用，但DT标准需要</span></span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 示例：为了方便演示，我们在这个“控制器”节点内部直接定义引脚组</span></span><br><span class="line">    <span class="comment">// 实际上，这些引脚组通常在controller的子节点中定义，并被其他模块引用</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// i2c功能的引脚组定义</span></span><br><span class="line"><span class="symbol">    i2c_pins:</span> <span class="title class_">pinctrl_virtual_i2c</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">groups</span> <span class="operator">=</span> <span class="string">&quot;pin0&quot;</span>, <span class="string">&quot;pin1&quot;</span><span class="punctuation">;</span>     <span class="comment">// 包含pin0和pin1</span></span><br><span class="line">        <span class="attr">functions</span> <span class="operator">=</span> <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;i2c&quot;</span><span class="punctuation">;</span>      <span class="comment">// 将它们都配置为i2c功能</span></span><br><span class="line">        <span class="attr">configs</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x11223344</span>&gt;</span>, <span class="params">&lt;<span class="number">0x55667788</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 对应的电气配置值</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它功能的引脚组定义 (例如，如果设备在不同状态下需要不同配置)</span></span><br><span class="line"><span class="symbol">    gpio_pins:</span> <span class="title class_">pinctrl_virtual_gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">groups</span> <span class="operator">=</span> <span class="string">&quot;pin2&quot;</span>, <span class="string">&quot;pin3&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">functions</span> <span class="operator">=</span> <span class="string">&quot;gpio&quot;</span>, <span class="string">&quot;gpio&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">configs</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x99AABBCC</span>&gt;</span>, <span class="params">&lt;<span class="number">0xDDEEFF00</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>groups</code>：引脚组中包含的引脚名称列表。</li>
<li><code>functions</code>：与 <code>groups</code> 中引脚对应的复用功能名称列表。</li>
<li><code>configs</code>：与 <code>groups</code> 中引脚对应的电气配置值列表。</li>
</ul>
</li>
</ul>
<h4 id="22-pinctrl-引用端-设备特定引脚需求"><a class="markdownIt-Anchor" href="#22-pinctrl-引用端-设备特定引脚需求"></a> 2.2 Pinctrl 引用端 (设备特定引脚需求)</h4>
<p>这部分通常位于具体的板级 <code>.dts</code> 文件中，描述特定板子上某个设备如何引用和使用上方定义的引脚组。</p>
<ul>
<li>具体的设备节点通过 <code>pinctrl-names</code> 和 <code>pinctrl-N</code> 属性来引用上方定义的引脚组。
<ul>
<li>
<p><code>pinctrl-names</code>：定义设备可能需要的引脚状态名称（如 &quot;default&quot;, &quot;sleep&quot;）。</p>
</li>
<li>
<p><code>pinctrl-N</code>：索引到 <code>pinctrl-names</code> 中的名称，指向上面定义的具体引脚组的 <code>phandle</code>。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是在某个 .dts 中，并包含了上面的 pinctrl@virtual_gpio_base 节点</span></span><br><span class="line"><span class="title class_">virtual_i2c_dev</span> <span class="punctuation">&#123;</span> <span class="comment">// 这是一个 Client 设备节点，对应 virtual_client_driver</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;100ask,virtual_i2c&quot;</span><span class="punctuation">;</span> <span class="comment">// 匹配 virtual_client_driver</span></span><br><span class="line">    <span class="comment">// ... 其他设备特有属性 (如 reg, interrupts) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;idle&quot;</span><span class="punctuation">;</span> <span class="comment">// 定义两个状态</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;i2c_pins</span>&gt;</span><span class="punctuation">;</span>          <span class="comment">// &quot;default&quot; 状态使用 i2c_pins</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;gpio_pins</span>&gt;</span><span class="punctuation">;</span>         <span class="comment">// &quot;idle&quot; 状态使用 gpio_pins</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-pinctrl-核心结构体详解与在示例中的体现"><a class="markdownIt-Anchor" href="#3-pinctrl-核心结构体详解与在示例中的体现"></a> 3. <code>pinctrl</code> 核心结构体详解与在示例中的体现</h3>
<p>理解 <code>pinctrl</code> 子的核心在于掌握其内部的关键数据结构如何协同工作。</p>
<h4 id="31-pin-controller-驱动相关结构体-由-virtual_pinctrl_driverc-实现"><a class="markdownIt-Anchor" href="#31-pin-controller-驱动相关结构体-由-virtual_pinctrl_driverc-实现"></a> 3.1 Pin Controller 驱动相关结构体 (由 <code>virtual_pinctrl_driver.c</code> 实现)</h4>
<ul>
<li>
<p><code>struct pinctrl_pin_desc</code></p>
<ul>
<li>
<p><strong>作用：</strong> 描述一个独立的物理引脚。</p>
</li>
<li>
<p><strong>定义：</strong></p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> number;    <span class="comment">// 引脚的唯一ID</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 引脚的可读名称</span></span><br><span class="line">    <span class="type">void</span> *drv_data;         <span class="comment">// 驱动私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li>
<p><strong>示例 (<code>virtual_pinctrl_driver.c</code>)：</strong></p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> <span class="title">pins</span>[] =</span> &#123; <span class="comment">// 静态定义4个虚拟引脚</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;pin0&quot;</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;pin1&quot;</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;pin2&quot;</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="string">&quot;pin3&quot;</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>struct pinctrl_ops</code></p>
<ul>
<li>
<p><strong>作用：</strong> Pin Controller 驱动向 <code>pinctrl</code> Core 提供的关于引脚组管理的通用操作接口。其中 <code>dt_node_to_map</code> 是将设备树信息转换为内部 <code>pinctrl_map</code> 的关键。</p>
</li>
<li>
<p><strong>定义：</strong> 包含 <code>get_groups_count</code>, <code>get_group_name</code>, <code>dt_node_to_map</code> 等函数指针。</p>
</li>
<li>
<p><strong>示例 (<code>virtual_pinctrl_driver.c</code>)：</strong></p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> <span class="title">virtual_pctrl_ops</span> =</span> &#123;</span><br><span class="line">    .get_groups_count = virtual_get_groups_count,</span><br><span class="line">    .get_group_name = virtual_get_group_name,</span><br><span class="line">    .get_group_pins = virtual_get_group_pins,</span><br><span class="line">    .pin_dbg_show = virtual_pin_dbg_show,</span><br><span class="line">    .dt_node_to_map = virtual_dt_node_to_map, <span class="comment">// 核心：设备树解析函数</span></span><br><span class="line">    .dt_free_map = virtual_dt_free_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><strong><code>virtual_dt_node_to_map</code> 函数：</strong> 这是理解设备树如何与驱动关联的关键。它接收一个 <code>device_node</code> (<code>np</code>)，读取 <code>groups</code>、<code>functions</code>、<code>configs</code> 属性，然后动态分配 <code>pinctrl_map</code> 结构体，并填充其中的 <code>type</code> (MUX/CONFIG)、<code>function</code>/<code>configs</code>、<code>group</code>/<code>pin</code> 字段。对于每个引脚，它创建两个 <code>pinctrl_map</code>：一个用于复用，一个用于配置。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>struct pinmux_ops</code></p>
<ul>
<li>
<p><strong>作用：</strong> Pin Controller 驱动提供的关于引脚功能复用（Pin Multiplexing）的操作接口。</p>
</li>
<li>
<p><strong>定义：</strong> 包含 <code>set_mux</code>（最重要，实际执行复用操作）、<code>get_functions_count</code> 等函数指针。</p>
</li>
<li>
<p><strong>示例 (<code>virtual_pinctrl_driver.c</code>)：</strong></p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> <span class="title">virtual_pmx_ops</span> =</span> &#123;</span><br><span class="line">    .get_functions_count = virtual_pmx_get_funcs_count,</span><br><span class="line">    .get_function_name = virtual_pmx_get_func_name,</span><br><span class="line">    .get_function_groups = virtual_pmx_get_groups,</span><br><span class="line">    .set_mux = virtual_pmx_set, <span class="comment">// 核心：实际执行复用切换</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// virtual_pmx_set 模拟了硬件寄存器操作，通过printk打印信息</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>struct pinconf_ops</code></p>
<ul>
<li>
<p><strong>作用：</strong> Pin Controller 驱动提供的关于引脚电气特性配置（Pin Configuration）的操作接口。</p>
</li>
<li>
<p><strong>定义：</strong> 包含 <code>pin_config_set</code>（最重要，实际执行配置操作）、<code>pin_config_group_set</code> 等函数指针。</p>
</li>
<li>
<p><strong>示例 (<code>virtual_pinctrl_driver.c</code>)：</strong></p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> <span class="title">virtual_pinconf_ops</span> =</span> &#123;</span><br><span class="line">    .pin_config_get = virtual_pinconf_get,</span><br><span class="line">    .pin_config_set = virtual_pinconf_set, <span class="comment">// 核心：实际执行电气配置</span></span><br><span class="line">    .pin_config_dbg_show = virtual_pinconf_dbg_show,</span><br><span class="line">    .pin_config_group_dbg_show = virtual_pinconf_group_dbg_show,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// virtual_pinconf_set 模拟了硬件寄存器操作，通过printk打印信息</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>struct pinctrl_desc</code></p>
<ul>
<li>
<p><strong>作用：</strong> Pin Controller 驱动向 <code>pinctrl</code> Core 注册时提供的“名片”，描述其硬件能力和所有操作接口。</p>
</li>
<li>
<p><strong>定义：</strong> 包含 <code>name</code>, <code>owner</code>, <code>pins</code> (物理引脚列表), <code>npins</code>, <code>pctlops</code> (通用操作), <code>pmxops</code> (复用操作), <code>confops</code> (配置操作)。</p>
</li>
<li>
<p><strong>示例 (<code>virtual_pinctrl_driver.c</code>)：</strong></p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 virtual_pinctrl_probe 函数中动态分配和填充</span></span><br><span class="line">pictrl-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line">pictrl-&gt;pins = pins;</span><br><span class="line">pictrl-&gt;npins = ARRAY_SIZE(pins);</span><br><span class="line">pictrl-&gt;pctlops = &amp;virtual_pctrl_ops;</span><br><span class="line">pictrl-&gt;pmxops = &amp;virtual_pmx_ops;</span><br><span class="line">pictrl-&gt;confops = &amp;virtual_pinconf_ops;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>struct pinctrl_dev</code></p>
<ul>
<li><strong>作用：</strong> <code>pinctrl</code> Core 为每个注册的 Pin Controller 动态创建的运行时实例。它是 Core 与特定 Pin Controller 驱动交互的句柄。</li>
<li><strong>初始化：</strong> 在 <code>virtual_pinctrl_probe</code> 中调用 <code>devm_pinctrl_register(&amp;pdev-&gt;dev, pictrl, NULL)</code> 时，由 <code>pinctrl</code> Core 内部创建并返回给 <code>g_pinctrl_dev</code>。</li>
</ul>
</li>
</ul>
<h4 id="32-pinctrl-core-内部转换结构体-由-pinctrl-core-管理"><a class="markdownIt-Anchor" href="#32-pinctrl-core-内部转换结构体-由-pinctrl-core-管理"></a> 3.2 <code>pinctrl</code> Core 内部转换结构体 (由 <code>pinctrl</code> Core 管理)</h4>
<ul>
<li>
<p><code>struct pinctrl_map</code></p>
<ul>
<li><strong>作用：</strong> 将设备树中描述的抽象引脚配置 <strong>初步解析</strong> 后形成的一种通用表示。它告诉 Core &quot;某个设备在某个状态下，需要某个 Pin Controller 的某个引脚组进行某个复用或配置操作&quot;。</li>
<li><strong>来源：</strong> 由 Pin Controller 驱动的 <code>dt_node_to_map</code> 函数动态分配和填充。</li>
<li><strong>示例：</strong> <code>virtual_dt_node_to_map</code> 函数中 <code>new_map</code> 数组的元素。</li>
</ul>
</li>
<li>
<p><code>struct pinctrl_setting</code></p>
<ul>
<li><strong>作用：</strong> 比 <code>pinctrl_map</code> 更进一步的、<strong>可执行的</strong> 引脚操作单元。它包含了执行某个复用或配置所需的所有明确信息（哪个 <code>pinctrl_dev</code>，哪个引脚组 ID，哪个功能 ID/配置值）。</li>
<li><strong>来源：</strong> 由 <code>pinctrl</code> Core 动态分配和填充，将 <code>pinctrl_map</code> 中的名称转换为对应的 ID（例如，将 &quot;pin0&quot; 转换为 0，将 &quot;i2c&quot; 转换为 <code>g_funcs_des</code> 数组的索引）。</li>
<li><strong>关联：</strong> 存储在 <code>struct pinctrl_state</code> 的 <code>settings</code> 链表中。</li>
</ul>
</li>
<li>
<p><code>struct pinctrl_state</code></p>
<ul>
<li><strong>作用：</strong> 代表 Client 设备在某个 <strong>特定命名状态</strong>（如 &quot;default&quot;, &quot;idle&quot;）下所需的所有引脚配置和复用。一个 <code>pinctrl_state</code> 包含了在该状态下需要执行的所有 <code>pinctrl_setting</code>。</li>
<li><strong>来源：</strong> 由 <code>pinctrl</code> Core 在解析 Client 设备的 Device Tree 时动态分配和填充，特别是解析 <code>pinctrl-names</code> 和 <code>pinctrl-N</code> 属性时。</li>
<li><strong>关联：</strong> 存储在 <code>struct pinctrl</code> 实例的 <code>pinctrl_states</code> 链表中。</li>
</ul>
</li>
<li>
<p><code>struct pinctrl</code></p>
<ul>
<li><strong>作用：</strong> <code>pinctrl</code> Core 提供给 <strong>Client 设备驱动</strong> 的一个 <strong>句柄</strong>。每个 Client 设备通过这个句柄来管理其所有的引脚状态。</li>
<li><strong>来源：</strong> 由 <code>pinctrl</code> Core 在 Client 设备驱动调用 <code>devm_pinctrl_get()</code> 时动态分配和初始化。</li>
<li><strong>关联：</strong> Client 设备的 <code>struct device</code> 结构体中的 <code>pin.p</code> 成员指向它。</li>
</ul>
</li>
</ul>
<h4 id="33-client-设备驱动相关结构体"><a class="markdownIt-Anchor" href="#33-client-设备驱动相关结构体"></a> 3.3 Client 设备驱动相关结构体</h4>
<ul>
<li>
<p><code>struct device</code></p>
<ul>
<li><strong>作用：</strong> 内核中对所有设备的通用抽象。每个 <code>platform_device</code> 都包含一个 <code>struct device</code>。</li>
<li><strong>成员：</strong> 包含一个 <code>struct dev_pin_info pin</code> 成员，用于存储与该设备相关的 <code>pinctrl</code> 句柄。</li>
</ul>
</li>
<li>
<p><code>struct dev_pin_info</code> (内嵌在 <code>struct device</code> 中)</p>
<ul>
<li><strong>作用：</strong> 存储 Client 设备关联的 <code>pinctrl</code> 句柄及相关引脚管理信息。</li>
<li><strong>成员：</strong> <code>struct pinctrl *p</code> 指向该设备关联的 <code>pinctrl</code> 句柄，还有 <code>default_state</code>, <code>init_state</code>, <code>current_state</code> 等。</li>
</ul>
</li>
</ul>
<h3 id="4-驱动编写实践与流程合并"><a class="markdownIt-Anchor" href="#4-驱动编写实践与流程合并"></a> 4. 驱动编写实践与流程合并</h3>
<p>我们将这两个驱动文件合并在一个流程中进行讲解和修改。</p>
<h4 id="步骤-1-virtual_pinctrl_driverc-pin-controller-驱动-的实现与工作流"><a class="markdownIt-Anchor" href="#步骤-1-virtual_pinctrl_driverc-pin-controller-驱动-的实现与工作流"></a> 步骤 1: <code>virtual_pinctrl_driver.c</code> (Pin Controller 驱动) 的实现与工作流</h4>
<p>这个驱动负责定义一个虚拟的 <code>pinctrl</code> 硬件，包括其能管理的引脚、支持的功能以及如何执行复用和配置操作。</p>
<p><strong>代码分析要点：</strong></p>
<ul>
<li><strong><code>pins[]</code>：</strong> 定义了 4 个名为 &quot;pin0&quot; 到 &quot;pin3&quot; 的虚拟物理引脚。</li>
<li><strong><code>g_funcs_des[]</code>：</strong> 定义了 3 个虚拟功能：&quot;gpio&quot;（所有引脚）, &quot;i2c&quot;（pin0, pin1）, &quot;uart&quot;（pin2, pin3）。这模拟了引脚的功能分组。</li>
<li><strong><code>virtual_pctrl_ops</code>：</strong>
<ul>
<li><code>.get_groups_count</code>, <code>.get_group_name</code>, <code>.get_group_pins</code>：这些函数用于 Core 查询 Pin Controller 支持的引脚组信息。在本例中，每个 <code>pinctrl_pin_desc</code> 对应一个引脚组。</li>
<li><code>.dt_node_to_map</code>：<strong>核心函数</strong>。它解析设备树中引脚组节点 (<code>i2c_pins</code>, <code>gpio_pins</code>) 的 <code>groups</code>, <code>functions</code>, <code>configs</code> 属性。
<ul>
<li>对于 <code>groups = &quot;pin0&quot;, &quot;pin1&quot;; functions = &quot;i2c&quot;, &quot;i2c&quot;; configs = &lt;0x11223344&gt;, &lt;0x55667788&gt;;</code></li>
<li>它会为 &quot;pin0&quot; 生成一个 <code>PIN_MAP_TYPE_MUX_GROUP</code> map (功能 &quot;i2c&quot;) 和一个 <code>PIN_MAP_TYPE_CONFIGS_PIN</code> map (配置 0x11223344)。</li>
<li>同时为 &quot;pin1&quot; 生成类似的两个 map。</li>
<li>最终，一个设备树引脚组节点可能转换为多个 <code>pinctrl_map</code> 条目（每个引脚通常对应一个 MUX 和一个 CONFIG map）。</li>
</ul>
</li>
<li><code>.dt_free_map</code>：清理 <code>dt_node_to_map</code> 分配的内存。</li>
</ul>
</li>
<li><strong><code>virtual_pmx_ops</code>：</strong>
<ul>
<li><code>.set_mux</code>：<code>virtual_pmx_set</code> 模拟了将特定引脚复用为某个功能的操作。它通过 <code>printk</code> 打印信息，表示该引脚的功能已被切换。在真实硬件驱动中，这里会是写 IOMUXC 寄存器。</li>
</ul>
</li>
<li><strong><code>virtual_pinconf_ops</code>：</strong>
<ul>
<li><code>.pin_config_set</code>：<code>virtual_pinconf_set</code> 模拟了设置引脚电气特性的操作。它将配置值保存到 <code>g_configs</code> 数组，并通过 <code>printk</code> 打印。在真实硬件驱动中，这里会是写 PAD_CTRL 寄存器。</li>
</ul>
</li>
<li><strong><code>virtual_pinctrl_probe</code>：</strong>
<ul>
<li>这是驱动的入口，当设备树中 <code>compatible = &quot;100ask,virtual_pinctrl&quot;</code> 的节点被匹配时调用。</li>
<li>它分配并填充 <code>struct pinctrl_desc</code>（<code>pictrl</code>），将其与 <code>pins</code> 数组、<code>virtual_pctrl_ops</code>, <code>virtual_pmx_ops</code>, <code>virtual_pinconf_ops</code> 关联起来。</li>
<li>最后调用 <code>devm_pinctrl_register</code> 将此 Pin Controller 注册到 <code>pinctrl</code> Core，返回 <code>struct pinctrl_dev</code> 指针。</li>
</ul>
</li>
</ul>
<p><strong>Pin Controller 驱动初始化流程图：</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Kernel as `Kernel`
    participant VP_D as `virtual_pinctrl_driver.c`
    participant Core as `pinctrl Core`

    Kernel->>VP_D: `virtual_pinctrl_init()` (module_init)
    VP_D->>VP_D: `platform_driver_register(&virtual_pinctrl_driver)`
    Kernel->>VP_D: `virtual_pinctrl_probe()` (根据DT匹配)
    VP_D->>VP_D: 静态定义 `pins[]`, `g_funcs_des[]`, `virtual_pmx_ops`, `virtual_pinconf_ops`等
    VP_D->>VP_D: 动态分配 `pinctrl_desc` (pictrl)
    VP_D->>VP_D: 填充 pictrl (name, pins, npins, pctlops, pmxops, confops)
    VP_D->>Core: `devm_pinctrl_register(&pdev->dev, pictrl, NULL)`
    Core->>Core: 分配/初始化 `struct pinctrl_dev` (g_pinctrl_dev)
    Core->>Core: 将 `pinctrl_dev` 加入全局链表
    Core-->>VP_D: 返回 `pinctrl_dev` 指针
    VP_D-->>Kernel: `virtual_pinctrl_probe()` 完成</pre>
<hr />
<h4 id="步骤-2-virtual_client_driverc-client-设备驱动-的修改与工作流"><a class="markdownIt-Anchor" href="#步骤-2-virtual_client_driverc-client-设备驱动-的修改与工作流"></a> 步骤 2: <code>virtual_client_driver.c</code> (Client 设备驱动) 的修改与工作流</h4>
<p>为了让 <code>virtual_client_driver</code> 成为一个真正的 <code>pinctrl</code> 客户端，我们需要修改其 <code>probe</code> 函数，使其能够获取 <code>pinctrl</code> 句柄并选择引脚状态。</p>
<p><strong>修改后的 <code>virtual_client_driver.c</code> 示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mfd/syscon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pinctrl/machine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pinctrl/pinconf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pinctrl/pinctrl.h&gt;</span> <span class="comment">// 引入 pinctrl 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pinctrl/pinmux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/regmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">virtual_client_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;100ask,virtual_i2c&quot;</span>, &#125;, <span class="comment">// 匹配设备树中的 &quot;100ask,virtual_i2c&quot;</span></span><br><span class="line">	&#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtual_client_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>, *<span class="title">idle_state</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s %s %d: Probing virtual i2c client...\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取 pinctrl 句柄</span></span><br><span class="line">    <span class="comment">// devm_pinctrl_get 会解析设备树中该设备节点下的 pinctrl-names 和 pinctrl-N 属性</span></span><br><span class="line">    <span class="comment">// 并构建 pinctrl、pinctrl_state 和 pinctrl_setting 结构体</span></span><br><span class="line">    p = devm_pinctrl_get(&amp;pdev-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get pinctrl handle.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line">    &#125;</span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Successfully got pinctrl handle.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查找并获取特定的引脚状态 (例如 &quot;default&quot; 和 &quot;idle&quot;)</span></span><br><span class="line">    default_state = pinctrl_lookup_state(p, PINCTRL_STATE_DEFAULT); <span class="comment">// PINCTRL_STATE_DEFAULT 即 &quot;default&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(default_state)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to lookup default pinctrl state.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// default 状态通常是设备启动时必须的，查找失败可能表示DT配置错误</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(default_state);</span><br><span class="line">    &#125;</span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Successfully lookup default pinctrl state.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    idle_state = pinctrl_lookup_state(p, <span class="string">&quot;idle&quot;</span>); <span class="comment">// 查找自定义的 &quot;idle&quot; 状态</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(idle_state)) &#123;</span><br><span class="line">        dev_warn(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to lookup idle pinctrl state (optional).\n&quot;</span>);</span><br><span class="line">        <span class="comment">// &quot;idle&quot; 状态可能不是强制的，此处选择警告而不是错误</span></span><br><span class="line">        idle_state = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Successfully lookup idle pinctrl state.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 激活 &quot;default&quot; 状态</span></span><br><span class="line">    <span class="comment">// pinctrl_select_state 会遍历 default_state 中的所有 pinctrl_setting，</span></span><br><span class="line">    <span class="comment">// 并调用 Pin Controller 驱动(virtual_pinctrl_driver)中相应的 set_mux 和 pin_config_set 函数</span></span><br><span class="line">    ret = pinctrl_select_state(p, default_state);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to select default pinctrl state: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Selected default pinctrl state (i2c pins activated).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. (可选) 演示切换到 &quot;idle&quot; 状态</span></span><br><span class="line">    <span class="comment">// 假设在设备的 suspend/resume 流程中会切换到 idle 状态</span></span><br><span class="line">    <span class="keyword">if</span> (idle_state) &#123;</span><br><span class="line">        dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Demonstrating switching to idle state...\n&quot;</span>);</span><br><span class="line">        ret = pinctrl_select_state(p, idle_state);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to select idle pinctrl state: %d\n&quot;</span>, ret);</span><br><span class="line">            <span class="comment">// 这里可以根据实际需求决定是否返回错误</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Selected idle pinctrl state (gpio pins activated).\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 演示结束后，切换回默认状态 (通常在真实PM流程中由PM core处理)</span></span><br><span class="line">        dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Switching back to default state for normal operation...\n&quot;</span>);</span><br><span class="line">        ret = pinctrl_select_state(p, default_state);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to switch back to default state: %d\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">	printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">virtual_client_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// devm_pinctrl_get 申请的资源会自动在 remove 时释放，无需手动调用 devm_pinctrl_put</span></span><br><span class="line">	printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">virtual_client_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= virtual_client_probe,</span><br><span class="line">	.remove		= virtual_client_remove,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;100ask_virtual_client&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(virtual_client_of_match),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">virtual_client_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">	printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="comment">/* 1.1 注册一个platform_driver */</span></span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;virtual_client_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">virtual_client_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="comment">/* 2.1 反注册platform_driver */</span></span><br><span class="line">	platform_driver_unregister(&amp;virtual_client_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(virtual_client_init);</span><br><span class="line">module_exit(virtual_client_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Client 驱动 Client 初始化与状态切换流程图：</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Client as `virtual_client_driver.c`
    participant Core as `pinctrl Core`
    participant VPD as `virtual_pinctrl_driver.c`
  
    Client->>Core: `devm_pinctrl_get(&pdev->dev)`
    Note over Core: 1. 解析`pinctrl-names`和`pinctrl-N`属性<br>2. 识别`phandle`对应的Pin Controller (VPD)
    Core->>VPD: 调用`virtual_pctrl_ops.dt_node_to_map(np)`
    VPD->>VPD: 解析`groups, functions, configs`属性<br>为每个引脚生成2个`pinctrl_map` (MUX/CONF)
    VPD-->>Core: 返回`pinctrl_map`列表
    Core->>Core: 将`pinctrl_map`转换为`pinctrl_setting` (名称->ID)
    Core->>Core: 将`pinctrl_setting`组织到`pinctrl_state`中
    Core->>Core: 将`pinctrl_state`挂载到设备的`pinctrl`句柄下
    Core-->>Client: 返回`pinctrl`句柄
  
    Client->>Core: `pinctrl_lookup_state(p, "default")`
    Core-->>Client: 返回`default_state`句柄
  
    Client->>Core: `pinctrl_select_state(p, default_state)`
    Core->>Core: 遍历`default_state`的`settings`链表
    loop for each setting
        alt Setting Type is MUX
            Core->>VPD: 调用`virtual_pmx_ops.set_mux(func_id, group_id)`
            VPD->>VPD: `printk("set %s as %s", ...)` (模拟硬件操作)
        else Setting Type is CONFIG
            Core->>VPD: 调用`virtual_pinconf_ops.pin_config_set(pin_id, configs, num_configs)`
            VPD->>VPD: `printk("config %s as 0x%lx", ...)` (模拟硬件操作)
        end
    end
    Core-->>Client: `pinctrl_select_state()`完成</pre>
<h3 id="5-如何编写一个-pinctrl-子系统的驱动和客户端总结"><a class="markdownIt-Anchor" href="#5-如何编写一个-pinctrl-子系统的驱动和客户端总结"></a> 5. 如何编写一个 <code>pinctrl</code> 子系统的驱动和客户端总结</h3>
<p><strong>总结流程：</strong></p>
<ol>
<li><strong>确定物理引脚：</strong> 在 <code>pinctrl</code> 驱动中，使用 <code>struct pinctrl_pin_desc</code> 数组静态定义 SoC 上所有由该控制器管理的物理引脚。</li>
<li><strong>实现 Pin Controller 的操作集：</strong> 实现 <code>pinctrl_ops</code> (通用引脚组管理和 DT 解析)、<code>pinmux_ops</code> (复用功能切换) 和 <code>pinconf_ops</code> (电气特性配置)。
<ul>
<li><strong>关键是 <code>dt_node_to_map</code>：</strong> 负责将设备树中特定格式的引脚组描述 (<code>fsl,pins</code> 或我们示例中的 <code>groups/functions/configs</code>) 转换为 Core 通用的 <code>pinctrl_map</code> 数组。</li>
<li><strong>关键是 <code>set_mux</code> 和 <code>pin_config_set</code>：</strong> 这些函数是驱动操作底层硬件寄存器，实现引脚复用和配置的地方。</li>
</ul>
</li>
<li><strong>注册 Pin Controller 驱动：</strong> 在 <code>probe</code> 函数中，分配并填充 <code>struct pinctrl_desc</code>，然后调用 <code>devm_pinctrl_register</code> 将其注册到 <code>pinctrl</code> Core。</li>
<li><strong>编写设备树：</strong>
<ul>
<li><strong>Pin Controller 节点：</strong> 定义 <code>compatible</code> 属性匹配你的 <code>pinctrl</code> 驱动，并在其内部或子节点定义引脚组及其复用/配置属性（注意使用 <code>dt_node_to_map</code> 能解析的格式）。</li>
<li><strong>Client 设备节点：</strong> 定义 <code>compatible</code> 属性匹配你的客户端驱动，并使用 <code>pinctrl-names</code> 和 <code>pinctrl-N</code> 属性引用上方定义的引脚组。</li>
</ul>
</li>
<li><strong>编写客户端驱动：</strong>
<ul>
<li>在 <code>probe</code> 函数中，调用 <code>devm_pinctrl_get(&amp;pdev-&gt;dev)</code> 获取设备特有的 <code>pinctrl</code> 句柄。</li>
<li>通过 <code>pinctrl_lookup_state(p, &quot;state_name&quot;)</code> 查找所需的引脚状态。</li>
<li>通过 <code>pinctrl_select_state(p, state_handle)</code> 激活该状态，触发 Core 调用 Pin Controller 驱动中的 <code>set_mux</code> 和 <code>pin_config_set</code>。</li>
</ul>
</li>
</ol>
<p><strong>核心思想：通过分层和抽象，将硬件细节封装在 Pin Controller 驱动中，将板级配置描述在设备树中，而 Client 驱动只需通过统一的 API 接口来使用引脚。这大大提高了驱动代码的可移植性和可维护性。</strong></p>
<hr />

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-linux-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text"> 深入剖析 Linux pinctrl 子系统：原理、流程与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 1. pinctrl 子系统核心思想与架构总览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.0.1.1.</span> <span class="toc-text"> 总体工作流程图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-device-tree-%E4%B8%AD%E7%9A%84-pinctrl-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.2.</span> <span class="toc-text"> 2. Device Tree 中的 pinctrl 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-pin-controller-%E9%85%8D%E7%BD%AE%E7%AB%AF-%E7%A1%AC%E4%BB%B6%E8%83%BD%E5%8A%9B%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.0.2.1.</span> <span class="toc-text"> 2.1 Pin Controller 配置端 (硬件能力描述)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-pinctrl-%E5%BC%95%E7%94%A8%E7%AB%AF-%E8%AE%BE%E5%A4%87%E7%89%B9%E5%AE%9A%E5%BC%95%E8%84%9A%E9%9C%80%E6%B1%82"><span class="toc-number">1.0.2.2.</span> <span class="toc-text"> 2.2 Pinctrl 引用端 (设备特定引脚需求)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-pinctrl-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%9C%A8%E7%A4%BA%E4%BE%8B%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">1.0.3.</span> <span class="toc-text"> 3. pinctrl 核心结构体详解与在示例中的体现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-pin-controller-%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93-%E7%94%B1-virtual_pinctrl_driverc-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.3.1.</span> <span class="toc-text"> 3.1 Pin Controller 驱动相关结构体 (由 virtual_pinctrl_driver.c 实现)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-pinctrl-core-%E5%86%85%E9%83%A8%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%84%E4%BD%93-%E7%94%B1-pinctrl-core-%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.3.2.</span> <span class="toc-text"> 3.2 pinctrl Core 内部转换结构体 (由 pinctrl Core 管理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-client-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.3.3.</span> <span class="toc-text"> 3.3 Client 设备驱动相关结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B5%81%E7%A8%8B%E5%90%88%E5%B9%B6"><span class="toc-number">1.0.4.</span> <span class="toc-text"> 4. 驱动编写实践与流程合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1-virtual_pinctrl_driverc-pin-controller-%E9%A9%B1%E5%8A%A8-%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.0.4.1.</span> <span class="toc-text"> 步骤 1: virtual_pinctrl_driver.c (Pin Controller 驱动) 的实现与工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2-virtual_client_driverc-client-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.0.4.2.</span> <span class="toc-text"> 步骤 2: virtual_client_driver.c (Client 设备驱动) 的修改与工作流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.5.</span> <span class="toc-text"> 5. 如何编写一个 pinctrl 子系统的驱动和客户端总结</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&text=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&is_video=false&description=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入剖析 Linux pinctrl子系统：原理、流程与实践&body=Check out this article: https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&title=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&name=深入剖析 Linux pinctrl子系统：原理、流程与实践&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/24/work/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20Linux%20pinctrl%20%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/&t=深入剖析 Linux pinctrl子系统：原理、流程与实践"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
