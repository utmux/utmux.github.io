<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="天气：晴天 心情：一般   嵌入式学习（三）  1. pinctrl 和 gpio 系统使用  1. pinctrl 子系统概述及其在 i.MX6UL 中的体现 什么是 pinctrl？ pinctrl (Pin Control) 是 Linux 内核中用于管理引脚复用 (Pin Multiplexing)、引脚配置 (Pin Configuration) 和引脚分组 (Pin Grouping)">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式学习（三）">
<meta property="og:url" content="https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/index.html">
<meta property="og:site_name" content="混吃等死">
<meta property="og:description" content="天气：晴天 心情：一般   嵌入式学习（三）  1. pinctrl 和 gpio 系统使用  1. pinctrl 子系统概述及其在 i.MX6UL 中的体现 什么是 pinctrl？ pinctrl (Pin Control) 是 Linux 内核中用于管理引脚复用 (Pin Multiplexing)、引脚配置 (Pin Configuration) 和引脚分组 (Pin Grouping)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-08T11:47:32.000Z">
<meta property="article:modified_time" content="2025-07-08T14:07:17.750Z">
<meta property="article:author" content="YQX">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>嵌入式学习（三）</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/07/10/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/07/04/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&text=嵌入式学习（三）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&is_video=false&description=嵌入式学习（三）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=嵌入式学习（三）&body=Check out this article: https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&name=嵌入式学习（三）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&t=嵌入式学习（三）"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%89"><span class="toc-number">1.</span> <span class="toc-text"> 嵌入式学习（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-pinctrl-%E5%92%8C-gpio-%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. pinctrl 和 gpio 系统使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%B6%E5%9C%A8-imx6ul-%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. pinctrl 子系统概述及其在 i.MX6UL 中的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-imx6ul-%E7%9A%84-device-tree-%E8%AE%BE%E5%A4%87%E6%A0%91-%E4%B8%AD-pinctrl-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. i.MX6UL 的 Device Tree (设备树) 中 pinctrl 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-gpio-%E5%9C%A8-device-tree-%E8%AE%BE%E5%A4%87%E6%A0%91-%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. GPIO 在 Device Tree (设备树) 中的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-linux-%E5%86%85%E6%A0%B8%E4%B8%AD-gpio-%E7%9A%84-c-%E8%AF%AD%E8%A8%80-api-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. Linux 内核中 GPIO 的 C 语言 API 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E7%8E%B0%E4%BB%A3-api-gpio-descriptor-api"><span class="toc-number">1.1.4.1.</span> <span class="toc-text"> 推荐的现代 API (GPIO Descriptor API)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%97%E7%95%99%E7%9A%84%E6%97%A7%E5%BC%8F-api-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%86%E4%BB%8D%E5%8F%AF%E7%94%A8"><span class="toc-number">1.1.4.2.</span> <span class="toc-text"> 遗留的旧式 API (不推荐但仍可用)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%8D%E5%90%8C%E8%8A%AF%E7%89%87%E9%97%B4-gpio-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5. 不同芯片间 GPIO 使用方法的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9C%A8%E5%AE%9E%E9%99%85%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B8%8A%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C-lcd"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 在实际的硬件上配置运行 LCD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#imx6ul-lcd-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text"> i.MX6UL LCD 驱动开发详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E8%84%9A%E9%85%8D%E7%BD%AE-pinctrl"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 1. 引脚配置 (Pinctrl)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 2. 时钟配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-lcd-timing-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.1.3.</span> <span class="toc-text"> 3. LCD Timing 参数获取与解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.1.4.</span> <span class="toc-text"> 4. 寄存器设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BE%85%E5%8A%A9%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.1.5.</span> <span class="toc-text"> 5. 辅助小知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E7%BC%93%E5%86%B2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text"> 3. 多缓冲优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-framebuffer-%E5%A4%9A%E7%BC%93%E5%86%B2doubletriple-buffering%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> Linux Framebuffer 多缓冲（Double&#x2F;Triple Buffering）机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-framebuffer-var-variable-screen-information-%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 1. Framebuffer var (Variable Screen Information) 的关键作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8Fkernel-space%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.2.</span> <span class="toc-text"> 2. 驱动程序（Kernel Space）配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8Fuser-space%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.3.</span> <span class="toc-text"> 3. 应用程序（User Space）使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BF%BB%E8%BD%AC%E6%B5%81%E7%A8%8B-%E7%A1%AC%E4%BB%B6%E8%BD%AF%E4%BB%B6%E5%8D%8F%E5%90%8C"><span class="toc-number">1.3.1.4.</span> <span class="toc-text"> 4. 完整的翻转流程 (硬件&#x2F;软件协同)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A1%A5%E5%85%85%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.5.</span> <span class="toc-text"> 5. 补充与高级概念</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        嵌入式学习（三）
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">YQX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-08T11:47:32.000Z" class="dt-published" itemprop="datePublished">2025-07-08</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/work/">work</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>天气：晴天 心情：一般</p>
<hr />
<h1 id="嵌入式学习三"><a class="markdownIt-Anchor" href="#嵌入式学习三"></a> 嵌入式学习（三）</h1>
<h2 id="1-pinctrl-和-gpio-系统使用"><a class="markdownIt-Anchor" href="#1-pinctrl-和-gpio-系统使用"></a> 1. pinctrl 和 gpio 系统使用</h2>
<h3 id="1-pinctrl-子系统概述及其在-imx6ul-中的体现"><a class="markdownIt-Anchor" href="#1-pinctrl-子系统概述及其在-imx6ul-中的体现"></a> 1. <code>pinctrl</code> 子系统概述及其在 i.MX6UL 中的体现</h3>
<p><strong>什么是 <code>pinctrl</code>？</strong><br />
<code>pinctrl</code> (Pin Control) 是 Linux 内核中用于管理引脚复用 (Pin Multiplexing)、引脚配置 (Pin Configuration) 和引脚分组 (Pin Grouping) 的一个通用子系统。它的核心目标是：</p>
<ul>
<li><strong>引脚复用 (Multiplexing)</strong>：一个物理引脚通常可以承担多种功能（如 GPIO、UART、SPI、I2C 等）。<code>pinctrl</code> 负责在这些功能之间进行切换。</li>
<li><strong>引脚配置 (Configuration)</strong>：一个引脚在选定某个功能后，可能还需要进行额外的电气特性配置，例如：
<ul>
<li>上拉/下拉电阻 (Pull-up/Pull-down)</li>
<li>驱动强度 (Drive Strength)</li>
<li>压摆率 (Slew Rate)</li>
<li>开漏/推挽输出 (Open-drain/Push-pull)</li>
<li>输入延迟 (Input Delay)</li>
</ul>
</li>
<li><strong>引脚分组 (Grouping)</strong>：将一组相关联的引脚进行分组管理，方便驱动程序一次性配置。</li>
</ul>
<p><strong>为什么需要 <code>pinctrl</code>？</strong><br />
现代 SoC（System on Chip）芯片的引脚功能高度复杂和灵活。如果没有统一的机制来管理，每个外设驱动程序都维护一套自己的引脚配置逻辑将导致代码冗余、难以维护和迁移。<code>pinctrl</code> 子系统抽象了底层的硬件差异，为上层驱动提供了统一的接口。</p>
<p><strong>i.MX6UL 中的 <code>pinctrl</code> (IOMUXC)</strong><br />
对于 NXP <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 系列芯片，负责引脚复用和配置的硬件模块叫做 <strong>IOMUXC (IO MUX Controller)</strong>。i.MX6UL 也不例外。当你使用 PinTool 生成配置时，实际上就是在为 IOMUXC 编写配置值。</p>
<ul>
<li>每个物理引脚在 IOMUXC 中都有对应的寄存器，用于控制其复用模式（MODE）和电气特性（PAD 配置）。</li>
<li>通常，一个引脚会有一个主功能（如 GPIO），同时具备多个备用功能。在设备树中，你需要指定该引脚应该工作在哪个模式下（例如，是作为 GPIO 还是作为 UART 的某个信号）。</li>
</ul>
<hr />
<h3 id="2-imx6ul-的-device-tree-设备树-中-pinctrl-配置"><a class="markdownIt-Anchor" href="#2-imx6ul-的-device-tree-设备树-中-pinctrl-配置"></a> 2. i.MX6UL 的 Device Tree (设备树) 中 <code>pinctrl</code> 配置</h3>
<p>设备树是 Linux 内核用于描述硬件拓扑和配置的工具。在设备树中，<code>pinctrl</code> 配置通常嵌套在 SoC 的根节点下，或者特定的 IOMUX 控制器节点下（如 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 的 <code>&amp;iomuxc</code> 节点）。</p>
<p><strong>基本结构：</strong></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常在soc下找到iomuxc节点</span></span><br><span class="line"><span class="variable">&amp;iomuxc</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span> <span class="comment">// 定义一个默认的pinctrl状态</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_hog_1</span> <span class="variable">&amp;pinctrl_my_device_cfg</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 引用多个pinctrl组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义GPIO相关的pinctrl组</span></span><br><span class="line"><span class="symbol">    pinctrl_hog_1:</span> <span class="title class_">hoggrp_1</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">            // 格式：&lt;PAD_NAME_IN_SOC__FUNCTION_NAME  PAD_CONFIG_VALUE&gt;</span></span><br><span class="line">            MX6UL_PAD_GPIO1_IO00__GPIO1_IO00        <span class="number">0x10B0</span> <span class="comment">// GPIO1_IO00，配置为GPIO功能，并设置上拉/下拉、驱动等</span></span><br><span class="line">            MX6UL_PAD_GPIO1_IO01__GPIO1_IO01        <span class="number">0x10B0</span></span><br><span class="line">            <span class="comment">// ... 更多GPIO引脚</span></span><br><span class="line">        &gt;<span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义我的UART外设的pinctrl组</span></span><br><span class="line"><span class="symbol">    pinctrl_my_device_cfg:</span> <span class="title class_">mydevicegrp</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">            MX6UL_PAD_UART1_TX_DATA__UART1_TX       <span class="number">0x110B1</span> // UART1 TX引脚，配置为UART功能</span></span><br><span class="line"><span class="params">            MX6UL_PAD_UART1_RX_DATA__UART1_RX       <span class="number">0x110B1</span> // UART1 RX引脚，配置为UART功能</span></span><br><span class="line"><span class="params">        &gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要使用这些引脚的外设节点中引用pinctrl组</span></span><br><span class="line"><span class="variable">&amp;uart1</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_my_device_cfg</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 引用上面定义的UART引脚组</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于GPIO，如果是非特定外设使用的GPIO（如Led、Button），可以这样引用：</span></span><br><span class="line"><span class="comment">// 也可以在gpio controller节点下直接定义pinctrl属性</span></span><br><span class="line"><span class="variable">&amp;gpio1</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_hog_1</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 引用GPIO组，注意这里是GPIO控制器本身的pinctrl</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><strong>关键点解释：</strong></p>
<ul>
<li><strong><code>&amp;iomuxc</code></strong>: 这是 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 芯片 IOMUXC 硬件控制器的设备树节点引用。所有的引脚配置都应该放在这个节点下。</li>
<li><strong><code>pinctrl-names</code> 和 <code>pinctrl-0</code></strong>:
<ul>
<li><code>pinctrl-names</code> 定义了引脚状态的名称列表，例如 &quot;default&quot;, &quot;sleep&quot;, &quot;idle&quot; 等。</li>
<li><code>pinctrl-0</code>, <code>pinctrl-1</code>... 则对应这些名称，其值是一个或多个 <code>pinctrl</code> 组的引用 (<code>&lt;pinctrl_group_node&gt;</code>)。驱动程序可以根据需要切换到不同的引脚状态（例如进入低功耗时切换到 &quot;sleep&quot; 状态的引脚配置）。</li>
</ul>
</li>
<li><strong><code>pinctrl_hog_1: hoggrp_1 &#123; ... &#125;</code></strong>: 这是一个自定义的 <code>pinctrl</code> 组节点。<code>hoggrp_1</code> 是该组的标签，用于在其他地方引用。</li>
<li><strong><code>fsl,pins</code></strong>: 这是 NXP <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 系列芯片特有的属性，用于定义引脚的复用和配置。
<ul>
<li><strong><code>MX6UL_PAD_GPIO1_IO00__GPIO1_IO00</code></strong>: 这部分非常重要。它由 PinTool 生成，<code>MX6UL_PAD_XXXX__YYYY</code> 的含义是：
<ul>
<li><code>MX6UL_PAD_XXXX</code>：表示物理的 PAD 名称（或 IOMUXC 寄存器名称）。</li>
<li><code>__YYYY</code>：表示该 PAD 被配置为什么功能。在这里，<code>__GPIO1_IO00</code> 表示它被配置为 GPIO1 的第 00 个引脚。如果这里是 <code>__UART1_TX</code>，则表示配置为 UART1 的发送引脚。</li>
</ul>
</li>
<li><strong><code>0x10B0</code></strong>: 这是该引脚的电气配置值，由一系列位组成，控制着上拉/下拉、驱动强度、压摆率等。同样地，PinTool 会根据您的选择生成这个值。
<ul>
<li>例如，<code>0x10B0</code> 可能表示：<code>DSE=medium</code> (驱动强度), <code>SRE=fast</code> (压摆率), <code>PUE=enable</code> (上拉/下拉选择), <code>PUS=100K_OHM_PU</code> (上拉 100K 欧姆), <code>ODE=disable</code> (开漏禁用), <code>HYS=enable</code> (施密特触发器使能)。具体含义需要查阅 i.MX6UL 的参考手册（RM）IOMUXC 章节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="3-gpio-在-device-tree-设备树-中的表示"><a class="markdownIt-Anchor" href="#3-gpio-在-device-tree-设备树-中的表示"></a> 3. GPIO 在 Device Tree (设备树) 中的表示</h3>
<p>即使是 GPIO，它也需要通过 <code>pinctrl</code> 来指定哪个物理引脚被设置为 GPIO 功能。一旦设置完毕，如何在设备树中表示一个特定的 GPIO 引脚呢？</p>
<p>对于 GPIO，设备树通常有两种表示方式：</p>
<ol>
<li>
<p><strong><code>gpios</code> 属性</strong>：最常见的方式，用于在某个设备节点中引用一个或多个 GPIO。</p>
 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">my_button</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;gpio-keys&quot;</span><span class="punctuation">;</span> <span class="comment">// 例如一个按键设备</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">button-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> <span class="number">2</span> GPIO_ACTIVE_LOW</span></span><br><span class="line"><span class="params">                    <span class="variable">&amp;gpio1</span> <span class="number">3</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span> <span class="comment">// GPIO控制器，引脚号，标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pinmux for these GPIOs is handled by the pinctrl_my_buttongrp node referenced by &amp;gpio1</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">my_led</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;gpio-leds&quot;</span><span class="punctuation">;</span> <span class="comment">// 例如一个LED灯设备</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">led-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio5</span> <span class="number">1</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span> <span class="comment">// GPIO5的第一个引脚，高电平有效</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><code>gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_LOW&gt;</code>：
<ul>
<li><code>&amp;gpio1</code>：GPIO 控制器的 <code>phandle</code> 引用。它指向设备树中 GPIO1 控制器的节点。</li>
<li><code>2</code>：<strong>GPIO 引脚编号</strong>。这通常是相对于该 GPIO 控制器（如 GPIO1）的逻辑编号，而不是整个 SoC 的全局物理引脚编号。对于 i.MX6UL，GPIO1_IO00 就是 0，GPIO1_IO01 就是 1，以此类推。</li>
<li><code>GPIO_ACTIVE_LOW</code>：这是 GPIO 的标志位，表示该引脚在低电平时是“有效”的。<code>GPIO_ACTIVE_HIGH</code> 表示高电平有效。这些标志位在内核头文件 <code>&lt;dt-bindings/gpio/gpio.h&gt;</code> 中定义。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>gpio-hog</code> (GPIO Holding)</strong>：如果一个 GPIO 引脚是固定的功能（例如一个电源使能引脚，或者一个固定的 LED），并且不需要一个特定的内核驱动程序去控制它，你可以使用 <code>gpio-hog</code> 来直接在设备树中控制其初始状态。</p>
 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在GPIO控制器节点下</span></span><br><span class="line"><span class="variable">&amp;gpio1</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_hog_gpio</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 引用配置为GPIO功能的pinctrl组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过gpio-hog直接控制一个GPIO的初始状态</span></span><br><span class="line">    <span class="title class_">power_enable_gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">gpio-hog</span><span class="punctuation">;</span> <span class="comment">// 声明为gpio-hog</span></span><br><span class="line">        <span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span> <span class="comment">// GPIO1的第10个引脚（GPIO1_IO10），高电平有效</span></span><br><span class="line">        <span class="attr">output-high</span><span class="punctuation">;</span> <span class="comment">// 定义初始状态为输出高电平</span></span><br><span class="line">        <span class="attr">line-name</span> <span class="operator">=</span> <span class="string">&quot;Power Enable&quot;</span><span class="punctuation">;</span> <span class="comment">// 可选：指定GPIO名称</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><code>gpio-hog</code>：一个空属性，表示这个 GPIO 将被设备树本身“持有”和管理。</li>
<li><code>gpios = &lt;10 GPIO_ACTIVE_HIGH&gt;</code>：这里的 <code>10</code> 是相对于 <code>&amp;gpio1</code> 的引脚编号。</li>
<li><code>output-high</code> / <code>output-low</code> / <code>input</code>：定义该 GPIO 的初始方向和输出状态。</li>
<li><code>line-name</code>：为该 GPIO 提供一个可读的名称，方便在 <code>sysfs</code> 或调试时识别。</li>
</ul>
</li>
</ol>
<p><strong>总结 GPIO 设备树写法：</strong><br />
您说得没错，<code>gpios = &lt;&amp;gpioX Y Z&gt;</code> 这种写法在不同的芯片上确实非常相似，因为它是一种通用且标准化的表达方式。变化主要体现在 <code>&amp;gpioX</code> 指向的具体 GPIO 控制器名称和其内部的引脚编号规则上。</p>
<hr />
<h3 id="4-linux-内核中-gpio-的-c-语言-api-使用"><a class="markdownIt-Anchor" href="#4-linux-内核中-gpio-的-c-语言-api-使用"></a> 4. Linux 内核中 GPIO 的 C 语言 API 使用</h3>
<p>在 Linux 内核中，推荐使用基于描述符的 GPIO API (<code>gpiod_*</code>)，而不是传统的旧式 API (<code>gpio_*</code>)。新的 API 提供了更好的错误处理、资源管理和代码可读性。</p>
<p>您提到的 <code>get_gpio_dev</code> 和 <code>set_gpio</code> 可能是某个特定板级支持包 (BSP) 或者旧驱动中封装的函数，在标准 Linux 内核中最新的 API 如下：</p>
<h4 id="推荐的现代-api-gpio-descriptor-api"><a class="markdownIt-Anchor" href="#推荐的现代-api-gpio-descriptor-api"></a> 推荐的现代 API (GPIO Descriptor API)</h4>
<p>这个 API 以 <code>struct gpio_desc *</code> (GPIO Descriptor) 作为核心，代表一个 GPIO 引脚。</p>
<ol>
<li>
<p><strong>包含头文件</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span> <span class="comment">// 包含 gpiod_* 系列函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span>       <span class="comment">// 通常需要struct device</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>在 <code>probe</code> 函数中获取 GPIO 描述符</strong><br />
通常在设备驱动的 <code>probe</code> 函数中进行。<code>devm_</code> 前缀的函数会自动管理资源的分配和释放（在设备 <code>remove</code> 时自动释放）。</p>
<ul>
<li>
<p><strong>通过 <code>gpios</code> 属性（推荐，健壮性高）：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">led_gpio</span>;</span></span><br><span class="line"><span class="comment">// 获取名为 &quot;led&quot; 的 GPIO，并设置为输出高电平（如果有默认状态）</span></span><br><span class="line"><span class="comment">// 如果设备树中是  `led-gpios = &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;;`</span></span><br><span class="line"><span class="comment">// 则 `led_gpio = devm_gpiod_get(dev, &quot;led&quot;, GPIOD_OUT_HIGH);`</span></span><br><span class="line"><span class="comment">// 第一个参数是 `struct device *dev`，第二个参数是设备树中 gpios 属性的别名（如果有），如果没有就传 NULL 并使用索引。</span></span><br><span class="line">led_gpio = devm_gpiod_get_optional(dev, <span class="string">&quot;led&quot;</span>, GPIOD_OUT_LOW); <span class="comment">// 获取名为&quot;led&quot;的GPIO，并默认输出低电平</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(led_gpio)) &#123;</span><br><span class="line">    <span class="comment">// 如果出错，或者GPIO不存在但允许可选，GPIOD_GET_OPTIONAL会返回NULL而不是错误码</span></span><br><span class="line">    <span class="keyword">if</span> (PTR_ERR(led_gpio) == -EPROBE_DEFER)</span><br><span class="line">        <span class="keyword">return</span> -EPROBE_DEFER; <span class="comment">// 依赖还未准备好，稍后重试</span></span><br><span class="line">    dev_err(dev, <span class="string">&quot;Failed to get LED GPIO: %ld\n&quot;</span>, PTR_ERR(led_gpio));</span><br><span class="line">    <span class="comment">// return PTR_ERR(led_gpio); // 如果不是可选的，则返回错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者处理成可选GPIO，不返回错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!led_gpio) &#123;</span><br><span class="line">    dev_info(dev, <span class="string">&quot;LED GPIO not specified, skipping LED functionality\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 没有配置LED GPIO，可以继续执行其他功能</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>通过索引（老式或非命名 GPIO）：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">btn_gpio</span>;</span></span><br><span class="line"><span class="comment">// 获取设备树 `gpios` 属性的第一个 GPIO (索引 0)，并设置为输入</span></span><br><span class="line"><span class="comment">// 通常用于没有命名（如 `key-gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_LOW&gt;;`）</span></span><br><span class="line">btn_gpio = devm_gpiod_get_index_optional(dev, <span class="literal">NULL</span>, <span class="number">0</span>, GPIOD_IN);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(btn_gpio)) &#123;</span><br><span class="line">    <span class="comment">// 错误处理同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>GPIOD_OUT_HIGH</code>, <code>GPIOD_OUT_LOW</code>, <code>GPIOD_IN</code>: 这些 <code>gpiod_flags</code> 参数用于指定 GPIO 的默认方向和输出状态（如果是输出）。</p>
</li>
</ul>
</li>
<li>
<p><strong>设置 GPIO 方向</strong><br />
可以在获取时设置，也可以单独设置：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为输出，初始值为 1 (高电平)</span></span><br><span class="line">ret = gpiod_direction_output(led_gpio, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123; <span class="comment">/* error handling */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为输入</span></span><br><span class="line">ret = gpiod_direction_input(btn_gpio);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123; <span class="comment">/* error handling */</span> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gpiod_direction_output()</code> 和 <code>gpiod_direction_input()</code> 会自动处理底层细节。</li>
</ul>
</li>
<li>
<p><strong>读写 GPIO 值</strong></p>
<ul>
<li>
<p><strong>输出：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为低电平</span></span><br><span class="line">gpiod_set_value_cansleep(led_gpio, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置为高电平</span></span><br><span class="line">gpiod_set_value_cansleep(led_gpio, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gpiod_set_value_cansleep()</code>：这是一个阻塞函数，如果底层硬件操作需要睡眠（如 I2C/SPI GPIO 扩展器），它会睡眠。通常推荐使用此函数。</li>
<li><code>gpiod_set_value()</code>：非阻塞版本，仅用于可以原子操作的 GPIO。</li>
</ul>
</li>
<li>
<p><strong>输入：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = gpiod_get_value_cansleep(btn_gpio);</span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123; <span class="comment">/* error reading */</span> &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 按键按下 (假设是低电平有效)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 按键弹起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gpiod_get_value_cansleep()</code>：阻塞读取 GPIO 值。</li>
<li><code>gpiod_get_value()</code>：非阻塞读取。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>GPIO 中断</strong><br />
GPIO 也可以作为中断源。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> irq = gpiod_to_irq(btn_gpio); <span class="comment">// 将GPIO描述符转换为中断号</span></span><br><span class="line"><span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123; <span class="comment">/* error */</span> &#125;</span><br><span class="line"></span><br><span class="line">ret = devm_request_irq(dev, irq, my_btn_isr, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">                       <span class="string">&quot;my_button_irq&quot;</span>, my_driver_data);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123; <span class="comment">/* error handling */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>示例代码 (用于学习，通常在实际驱动中会更复杂)：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在结构体中，方便管理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">power_gpio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">status_led_gpio</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    data = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    platform_set_drvdata(pdev, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取电源控制GPIO</span></span><br><span class="line">    data-&gt;power_gpio = devm_gpiod_get(dev, <span class="string">&quot;power&quot;</span>, GPIOD_OUT_HIGH); <span class="comment">// 设备树中 power-gpios = &lt;&amp;gpio1 10 GPIO_ACTIVE_HIGH&gt;;</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(data-&gt;power_gpio)) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to get power GPIO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(data-&gt;power_gpio);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始设置电源输出高电平 (已在 devm_gpiod_get 中指定)</span></span><br><span class="line">    <span class="comment">// gpiod_set_value_cansleep(data-&gt;power_gpio, 1); // 也可以在这里再次显式设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态指示灯GPIO (可选)</span></span><br><span class="line">    data-&gt;status_led_gpio = devm_gpiod_get_optional(dev, <span class="string">&quot;status-led&quot;</span>, GPIOD_OUT_LOW); <span class="comment">// status-led-gpios = &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;;</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(data-&gt;status_led_gpio)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(data-&gt;status_led_gpio) == -EPROBE_DEFER)</span><br><span class="line">            <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">        dev_warn(dev, <span class="string">&quot;Status LED GPIO not found or error: %ld\n&quot;</span>, PTR_ERR(data-&gt;status_led_gpio));</span><br><span class="line">        data-&gt;status_led_gpio = <span class="literal">NULL</span>; <span class="comment">// 确保为NULL，以便后续判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;status_led_gpio) &#123;</span><br><span class="line">        <span class="comment">// 点亮LED作为初始化成功指示</span></span><br><span class="line">        gpiod_set_value_cansleep(data-&gt;status_led_gpio, <span class="number">1</span>); <span class="comment">// 假设是高电平有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_info(dev, <span class="string">&quot;My device probed successfully!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">data</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// devm_ 函数会自动释放GPIO，这里不需要显式调用 gpiod_put()</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;status_led_gpio) &#123;</span><br><span class="line">        gpiod_set_value_cansleep(data-&gt;status_led_gpio, <span class="number">0</span>); <span class="comment">// 关闭LED</span></span><br><span class="line">    &#125;</span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;My device removed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 平台驱动注册等</span></span><br></pre></td></tr></table></figure>
<h4 id="遗留的旧式-api-不推荐但仍可用"><a class="markdownIt-Anchor" href="#遗留的旧式-api-不推荐但仍可用"></a> 遗留的旧式 API (不推荐但仍可用)</h4>
<ul>
<li><code>gpio_request(unsigned gpio, const char *label)</code>: 请求一个 GPIO 引脚。</li>
<li><code>gpio_free(unsigned gpio)</code>: 释放一个 GPIO 引脚。</li>
<li><code>gpio_direction_output(unsigned gpio, int value)</code>: 设置 GPIO 为输出，并赋初值。</li>
<li><code>gpio_direction_input(unsigned gpio)</code>: 设置 GPIO 为输入。</li>
<li><code>gpio_set_value(unsigned gpio, int value)</code>: 设置输出 GPIO 的值。</li>
<li><code>gpio_get_value(unsigned gpio)</code>: 获取输入 GPIO 的值。</li>
<li><code>gpio_to_irq(unsigned gpio)</code>: 将 GPIO 号转换为中断号。</li>
</ul>
<p><strong>为什么不推荐？</strong></p>
<ul>
<li><strong>资源管理缺乏健壮性</strong>：需要手动 <code>request</code> 和 <code>free</code>，容易忘记释放导致资源泄漏。<code>devm_gpiod_get</code> 可以自动管理。</li>
<li><strong>灵活性差</strong>：无法通过设备树中的 <code>line-name</code> 等属性来引用 GPIO。代码中只能硬编码 GPIO 编号。</li>
<li><strong>API 不统一</strong>：不同架构可能对 <code>gpio_get_value</code> 等有不同的实现，而 <code>gpiod_*</code> 提供了原子性和睡眠兼容性等更丰富的特性。</li>
<li><strong>兼容性问题</strong>：对于使用 GPIO 扩展器（通过 I2C/SPI 连接）的 GPIO，<code>gpio_*</code> 可能无法工作或效率低下，而 <code>gpiod_*</code> 统一了接口。</li>
</ul>
<p>您提到的 <code>get_gpio_dev</code> 和 <code>set_gpio</code> 很可能就是为了兼容旧代码或特定项目便捷而封装的函数，其内部可能调用了这些旧式 API 或简单的宏。</p>
<hr />
<h3 id="5-不同芯片间-gpio-使用方法的异同"><a class="markdownIt-Anchor" href="#5-不同芯片间-gpio-使用方法的异同"></a> 5. 不同芯片间 GPIO 使用方法的异同</h3>
<p>您观察到的现象是正确的：</p>
<ul>
<li>
<p><strong>设备树写法 (<code>gpios = &lt;&amp;gpioX Y Z&gt;</code>) 在语义上是高度一致的。</strong></p>
<ul>
<li><code>&amp;gpioX</code>: 这个是不同之处。它会指向不同 SoC 上的特定 GPIO 控制器实例（例如，i.MX6UL 可能有 <code>&amp;gpio1</code> 到 <code>&amp;gpio5</code>）。不同厂商的芯片对 GPIO 控制器的命名会有差异，但机制是一样的。</li>
<li><code>Y</code>: GPIO 引脚号。不同芯片内部的 GPIO 控制器编号规则可能不同，但都是指相对于该控制器的第 Y 个引脚。</li>
<li><code>Z</code>: GPIO 标志位。这些标志位 (<code>GPIO_ACTIVE_LOW</code>, <code>GPIO_ACTIVE_HIGH</code> 等) 是由内核定义并跨平台通用的。</li>
</ul>
</li>
<li>
<p><strong>Linux 内核 C 语言 API (<code>gpiod_*</code>) 是非常一致的。</strong></p>
<ul>
<li>这是 Linux GPIO 子系统设计的核心优势：它提供了一套高度抽象和统一的 API，使得上层驱动程序无需关心底层硬件的具体实现。</li>
<li>这意味着，一个为 i.MX6UL 编写的使用 <code>gpiod_set_value_cansleep()</code> 的驱动，如果在另一个使用同样 API 规范的 ARM SoC（如树莓派、全志）上运行，只要设备树配置正确，其 GPIO 操作部分的代码基本无需修改就能正常工作。</li>
<li>底层驱动（GPIO 控制器驱动）负责将 <code>gpiod_*</code> 的通用请求翻译成对应 SoC 的 GPIO 硬件寄存器操作。</li>
</ul>
</li>
</ul>
<p><strong>总结来说：</strong> <code>pinctrl</code> 负责物理引脚的复用和电气配置，它因芯片而异，NXP PinTool 就是为此服务的。而 <code>GPIO</code> 更多是作为一个引脚功能，它在设备树中的抽象表示（<code>gpios</code> 属性）和在内核 C 代码中的使用 API (<code>gpiod_*</code>) 则是高度标准化的，这极大地提高了驱动代码的可移植性。</p>
<hr />
<h2 id="2-在实际的硬件上配置运行-lcd"><a class="markdownIt-Anchor" href="#2-在实际的硬件上配置运行-lcd"></a> 2. 在实际的硬件上配置运行 LCD</h2>
<h3 id="imx6ul-lcd-驱动开发详解"><a class="markdownIt-Anchor" href="#imx6ul-lcd-驱动开发详解"></a> i.MX6UL LCD 驱动开发详解</h3>
<h4 id="1-引脚配置-pinctrl"><a class="markdownIt-Anchor" href="#1-引脚配置-pinctrl"></a> 1. 引脚配置 (Pinctrl)</h4>
<p>您提及的“设置各种引脚功能和 GPIO 功能”是正确的，并且其优先级最高。这是所有硬件外设正常工作的基础。</p>
<ul>
<li>
<p><strong>Pinctrl 的核心作用：</strong></p>
<ul>
<li><strong>引脚复用 (Pin Multiplexing/Muxing)：</strong> 确定一个物理引脚作为哪种功能使用（例如，是作为 LCD 数据线、控制线，还是作为普通的 GPIO）。对于 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 系列，这由 IOMUXC 模块管理。</li>
<li><strong>引脚电气特性配置 (Pad Configuration)：</strong> 配置引脚的电气参数，如上拉/下拉、驱动强度、压摆率、施密特触发等。这对于高速信号（如 LCD 数据线、时钟线）尤为重要，直接影响信号质量和稳定性。</li>
</ul>
</li>
<li>
<p><strong>工具生成与设备树：</strong> 您使用的 NXP PinTool（或称 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> Pin Configurator）是自动生成设备树 <code>pinctrl</code> 配置的强大工具。它将简化复杂的 IOMUXC 寄存器配置，直接输出 <code>fsl,pins</code> 等格式的代码段。</p>
</li>
<li>
<p><strong>在设备树中的表现：</strong></p>
  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;iomuxc</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ... 其他pinctrl组</span></span><br><span class="line"><span class="symbol">    pinctrl_lcd_panel:</span> <span class="title class_">lcdpanelgrp</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">fsl,pins</span> <span class="operator">=</span> <span class="params">&lt;</span></span><br><span class="line"><span class="params">            // MX6UL_PAD_&lt;PAD_NAME&gt;</span>__<span class="params">&lt;FUNCTION&gt;</span> <span class="params">&lt;PAD_CONFIG_VALUE&gt;</span></span><br><span class="line">            MX6UL_PAD_LCD_CLK__LCD_CLK       <span class="number">0x10B0</span> <span class="comment">// LCD 时钟</span></span><br><span class="line">            MX6UL_PAD_LCD_DATA00__LCD_DATA00 <span class="number">0x10B0</span> <span class="comment">// LCD 数据线</span></span><br><span class="line">            MX6UL_PAD_LCD_HSYNC__LCD_HSYNC   <span class="number">0x10B0</span> <span class="comment">// 水平同步信号</span></span><br><span class="line">            MX6UL_PAD_LCD_VSYNC__LCD_VSYNC   <span class="number">0x10B0</span> <span class="comment">// 垂直同步信号</span></span><br><span class="line">            MX6UL_PAD_LCD_ENABLE__LCD_ENABLE <span class="number">0x10B0</span> <span class="comment">// 使能信号</span></span><br><span class="line">            <span class="comment">// ... 更多LCD数据线和控制线</span></span><br><span class="line">            <span class="comment">// 如果LCD需要额外的GPIO（如背光PWM控制引脚或复位引脚）</span></span><br><span class="line">            MX6UL_PAD_GPIO1_IO02__GPIO1_IO02 <span class="number">0x10B0</span> <span class="comment">// LCD背光控制GPIO</span></span><br><span class="line">            MX6UL_PAD_GPIO_AD_B0_09__GPIO1_IO09 <span class="number">0x10B0</span> <span class="comment">// 复位GPIO</span></span><br><span class="line">        &gt;<span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;lcdif</span> <span class="punctuation">&#123;</span> <span class="comment">// i.MX的LCD接口控制器节点</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_lcd_panel</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 引用LCD相关的pinctrl组</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="comment">// ... 其他LCD参数，如时序、分辨率等</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;backlight</span> <span class="punctuation">&#123;</span> <span class="comment">// 如果背光是独立设备驱动</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;pwm-backlight&quot;</span><span class="punctuation">;</span> <span class="comment">// 或 &quot;gpio-backlight&quot;</span></span><br><span class="line">    <span class="attr">pwms</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;</span>pwmX <span class="number">0</span> <span class="number">5000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 假设通过PWM控制</span></span><br><span class="line">    <span class="comment">// gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_HIGH&gt;; // 假设通过GPIO控制</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_lcd_panel</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 或者独立的背光pinctrl组</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>总结：</strong> 引脚配置是硬件层面的基础，确保正确的信号能够传输到 LCD 面板。</p>
</li>
</ul>
<h4 id="2-时钟配置"><a class="markdownIt-Anchor" href="#2-时钟配置"></a> 2. 时钟配置</h4>
<p>您对时钟的理解非常接近，但需要更精确地划分和说明。对于 LCD 驱动，通常涉及到以下几类时钟：</p>
<ol>
<li>
<p><strong>LCD 控制器总线时钟 (LCDIF bus clock)：</strong></p>
<ul>
<li>这通常是 CPU 访问 LCD 控制器（LCDIF）内部寄存器所使用的时钟。在 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 系列中，这可能通过 <strong>AHB/AXI 或 IPG (Inter-Peripheral Generic) 总线</strong> 提供。这些总线连接 CPU、DMA、RAM 以及各种外设的寄存器接口。</li>
<li>您提到的 <strong>AXI 时钟</strong> 确实是高速且用于大带宽设备互联的，LCD 控制器内部的 DMA 通常跑在 AXI 或 AHB 上，用于从内存中搬运帧数据到显示控制器。</li>
<li><strong>APB 时钟</strong> 通常用于低速外设的寄存器访问，延迟确实可能较低，但带宽也更小。对于 LCD 控制器寄存器，一般通过 AHB/AXI 或 IPG 来访问，<strong>而并非通过 APB 传输像素数据</strong>。</li>
<li><strong>作用：</strong> 确保 CPU 和 DMA 能够正确、高效地读写 LCD 控制器内部寄存器，以及从 DDR 读取帧缓存数据。</li>
</ul>
</li>
<li>
<p><strong>LCD 像素时钟 (Pixel Clock/LVDS Clock)：</strong></p>
<ul>
<li>这是 <strong>最关键</strong> 的时钟，它直接决定了 LCD 面板的刷新率和显示数据的传输速度。每一个像素数据通常都会与一个像素时钟周期相关联。</li>
<li>这个时钟频率必须精确地与 LCD 面板的时序要求匹配。</li>
<li>在 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 芯片中，像素时钟通常来源于一个专用的硬件 <strong>PLL (Phase Locked Loop)</strong>，例如 <code>PLL_VPU</code> (或 <code>PLL_VIDEO</code>)，然后通过分频和门控生成最终的像素时钟送给 LCDIF 模块和 LCD 面板。</li>
<li><strong>作用：</strong> 驱动 LCD 面板的物理像素点更新。</li>
</ul>
</li>
</ol>
<p><strong>时钟配置流程：</strong></p>
<ol>
<li>
<p><strong>设备树中声明时钟依赖：</strong> 在 LCD 控制器节点（如 <code>&amp;lcdif</code>）或 LCD 面板节点中，通过 <code>clocks</code> 和 <code>clock-names</code> 属性声明所需的时钟。</p>
 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;lcdif</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;clks</span> IMX6UL_CLK_LCDIF_PIX&gt;</span>, <span class="comment">/* 像素时钟 */</span></span><br><span class="line">             <span class="params">&lt;<span class="variable">&amp;clks</span> IMX6UL_CLK_LCDIF_APB&gt;</span>, <span class="comment">/* 总线访问时钟 */</span></span><br><span class="line">             <span class="params">&lt;<span class="variable">&amp;clks</span> IMX6UL_CLK_LDB_DI1&gt;</span><span class="punctuation">;</span>   <span class="comment">/* LDB/DI接口时钟，如果有使用 */</span></span><br><span class="line">    <span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;lcdif_apb&quot;</span>, <span class="string">&quot;di1&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>驱动代码中获取并使能时钟：</strong> 在 LCD 驱动的 <code>probe</code> 函数中，使用 <code>devm_clk_get()</code> 获取时钟句柄，然后使用 <code>clk_prepare_enable()</code> 使能时钟。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在驱动数据结构中定义时钟句柄</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">pix_clk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">bus_clk</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_lcd_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> *<span class="title">data</span> =</span> dev_get_drvdata(dev);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取像素时钟</span></span><br><span class="line">    data-&gt;pix_clk = devm_clk_get(dev, <span class="string">&quot;pix&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(data-&gt;pix_clk)) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to get pix clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(data-&gt;pix_clk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总线时钟 (例如APB或AHB时钟)</span></span><br><span class="line">    data-&gt;bus_clk = devm_clk_get(dev, <span class="string">&quot;lcdif_apb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(data-&gt;bus_clk)) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to get bus clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(data-&gt;bus_clk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能时钟</span></span><br><span class="line">    ret = clk_prepare_enable(data-&gt;pix_clk);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to enable pix clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = clk_prepare_enable(data-&gt;bus_clk);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="comment">// 如果 bus_clk 使能失败，要先关闭 pix_clk</span></span><br><span class="line">        clk_disable_unprepare(data-&gt;pix_clk);</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to enable bus clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 设置像素时钟频率 (仅对特定时钟源需要)</span></span><br><span class="line">    <span class="comment">// 例如：ret = clk_set_rate(data-&gt;pix_clk, panel_info-&gt;pixel_clock_hz);</span></span><br><span class="line">    <span class="comment">// 通常在 imx 系列中，像素时钟的设置是由 LCDIF 的驱动更深层处理的，</span></span><br><span class="line">    <span class="comment">// 我们只获取并使能即可，频率会在 LCDIF 内部寄存器配置时生效。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_lcd_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> *<span class="title">data</span> =</span> dev_get_drvdata(pdev);</span><br><span class="line">    clk_disable_unprepare(data-&gt;bus_clk);</span><br><span class="line">    clk_disable_unprepare(data-&gt;pix_clk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-lcd-timing-参数获取与解析"><a class="markdownIt-Anchor" href="#3-lcd-timing-参数获取与解析"></a> 3. LCD Timing 参数获取与解析</h4>
<p>您提到从设备树获取 LCD 的各种 timing 参数，并在驱动程序内部解析到结构体中，这完全符合 Linux 设备树驱动开发的最佳实践。</p>
<ul>
<li>
<p><strong>设备树中 LCD 面板节点通常包含的参数：</strong></p>
  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">panel</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;panel-simple&quot;</span>, <span class="string">&quot;my-custom-lcd-panel&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">backlight</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;backlight</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 引用背光控制器</span></span><br><span class="line">    <span class="attr">width-mm</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">154</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">height-mm</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">86</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">port</span> <span class="punctuation">&#123;</span> <span class="comment">// DSI或DPI（并行LCD）接口的端口定义</span></span><br><span class="line"><span class="symbol">        panel_in:</span> <span class="title class_">endpoint</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">remote-endpoint</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;lcdif_out</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="punctuation">&#125;;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要：视频时序参数（VESA DMT标准或自定义）</span></span><br><span class="line">    <span class="title class_">display-timings</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">native-mode</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;timing0</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 默认使用哪个时序</span></span><br><span class="line"><span class="symbol">        timing0:</span> <span class="title class_">imx-timing</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">60000000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 像数时钟频率 (Hz)</span></span><br><span class="line">            <span class="attr">hactive</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">800</span>&gt;</span><span class="punctuation">;</span>     <span class="comment">// 水平有效像素</span></span><br><span class="line">            <span class="attr">vactive</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">480</span>&gt;</span><span class="punctuation">;</span>     <span class="comment">// 垂直有效像素</span></span><br><span class="line">            <span class="attr">hfront-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">40</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 水平前端消隐</span></span><br><span class="line">            <span class="attr">hback-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">80</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">// 水平后端消隐</span></span><br><span class="line">            <span class="attr">hsync-len</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">48</span>&gt;</span><span class="punctuation">;</span>    <span class="comment">// 水平同步脉冲宽度</span></span><br><span class="line">            <span class="attr">vfront-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">15</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 垂直前端消隐</span></span><br><span class="line">            <span class="attr">vback-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">22</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">// 垂直后端消隐</span></span><br><span class="line">            <span class="attr">vsync-len</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span>&gt;</span><span class="punctuation">;</span>     <span class="comment">// 垂直同步脉冲宽度</span></span><br><span class="line">            <span class="attr">hsync-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">// 水平同步信号高/低有效</span></span><br><span class="line">            <span class="attr">vsync-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">// 垂直同步信号高/低有效</span></span><br><span class="line">            <span class="attr">de-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span>     <span class="comment">// 数据使能信号高/低有效</span></span><br><span class="line">            <span class="attr">pixelclk-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 像素时钟高/低有效</span></span><br><span class="line">        <span class="punctuation">&#125;;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line">    <span class="comment">// ... 其他可能的参数，如接口类型（rgb888, rgb565等）、电源序列等</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>驱动中的解析：</strong></p>
<ul>
<li>
<p>在驱动的 <code>probe</code> 函数中，通过 <code>of_get_display_timings()</code> 或手动 <code>of_property_read_u32()</code> 等函数读取这些属性。</p>
</li>
<li>
<p>这些参数通常会被解析到一个 <code>struct fb_videomode</code> (framebuffer 视频模式) 或自定义的结构体中，例如：</p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_display_timing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span> <span class="comment">// for struct fb_videomode</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">panel_node</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">display_timings</span> *<span class="title">timings</span>;</span> <span class="comment">// 新的Linux内核建议使用这个</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> <span class="title">current_mode</span>;</span> <span class="comment">// 将timings转换为fb_videomode</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_lcd_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> *<span class="title">data</span> =</span> dev_get_drvdata(dev);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    data-&gt;panel_node = of_parse_phandle(dev-&gt;of_node, <span class="string">&quot;panel-node&quot;</span>, <span class="number">0</span>); <span class="comment">// 假设panel节点是lcdif的child或通过phandle关联</span></span><br><span class="line">    <span class="keyword">if</span> (!data-&gt;panel_node) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to get panel node\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取显示时序</span></span><br><span class="line">    data-&gt;timings = of_get_display_timings(data-&gt;panel_node);</span><br><span class="line">    <span class="keyword">if</span> (!data-&gt;timings) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to get display timings\n&quot;</span>);</span><br><span class="line">        of_node_put(data-&gt;panel_node);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将display_timings转换为fb_videomode，方便后续处理</span></span><br><span class="line">    ret = of_get_videomode(data-&gt;timings, &amp;data-&gt;current_mode, OF_USE_NATIVE_MODE);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to convert display timings to videomode\n&quot;</span>);</span><br><span class="line">        of_node_put(data-&gt;panel_node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时，data-&gt;current_mode 包含了详细的LCD时序信息</span></span><br><span class="line">    dev_dbg(dev, <span class="string">&quot;LCD timing: %dx%d@%dHz, pixel_clock=%lu\n&quot;</span>,</span><br><span class="line">            data-&gt;current_mode.xres, data-&gt;current_mode.yres,</span><br><span class="line">            data-&gt;current_mode.refresh, data-&gt;current_mode.pixclock);</span><br><span class="line"></span><br><span class="line">    of_node_put(data-&gt;panel_node); <span class="comment">// 释放节点引用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-寄存器设置"><a class="markdownIt-Anchor" href="#4-寄存器设置"></a> 4. 寄存器设置</h4>
<p>这是 LCD 驱动的核心操作，您提到的“结构体映射到某个偏移量”是正确的概念，但在 Linux 内核中，具体实现通常是通过 <strong><code>ioremap()</code></strong> 将物理寄存器地址映射到内核的虚拟地址空间，然后通过指针或 <code>readl</code>/<code>writel</code> 函数访问。</p>
<ul>
<li>
<p><strong>获取寄存器基址：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span> <span class="comment">// for ioremap, iounmap, readl, writel</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> __iomem *reg_base; <span class="comment">// 映射后的寄存器基地址</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_lcd_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">imx_lcd_data</span> *<span class="title">data</span> =</span> dev_get_drvdata(dev);</span><br><span class="line">    <span class="comment">// ... 其他初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LCDIF的寄存器资源</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span> =</span> platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to get LCDIF memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将物理地址映射到虚拟地址</span></span><br><span class="line">    data-&gt;reg_base = devm_ioremap_resource(dev, res);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(data-&gt;reg_base)) &#123;</span><br><span class="line">        dev_err(dev, <span class="string">&quot;Failed to ioremap LCDIF registers\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(data-&gt;reg_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 现在可以通过 data-&gt;reg_base + offset 来访问寄存器</span></span><br><span class="line">    <span class="comment">// 例如： writel_relaxed(value, data-&gt;reg_base + LCDIF_CR_OFFSET);</span></span><br><span class="line">    <span class="comment">// 或者定义一个结构体来直接访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>寄存器配置流程 (简化示例)：</strong><br />
一旦获取了 <code>reg_base</code>，就可以开始配置 LCDIF 的各个寄存器。这些寄存器很多，通常围绕以下几个方面：</p>
<ol>
<li><strong>复位与使能：</strong> 首先通常需要将控制器置于复位状态，然后解除复位。</li>
<li><strong>接口模式配置：</strong> 配置为 RGB 并行模式、MCU 模式、或 LVDS 等。</li>
<li><strong>显示时序寄存器：</strong> 根据解析到的 <code>timing</code> 参数，设置水平/垂直分辨率、同步脉冲宽度、前后消隐这些寄存器。
<ul>
<li><code>LCDIF_HSYN_PULSE_WIDTH</code>, <code>LCDIF_VSYN_PULSE_WIDTH</code></li>
<li><code>LCDIF_H_PERIOD</code>, <code>LCDIF_V_PERIOD</code></li>
<li><code>LCDIF_H_PULSE_START_POINT</code>, <code>LCDIF_V_PULSE_START_POINT</code></li>
<li><code>LCDIF_SIZE</code> (分辨率)</li>
</ul>
</li>
<li><strong>极性配置：</strong> 根据 <code>timing</code> 参数中的 <code>hsync-active</code>, <code>vsync-active</code>, <code>de-active</code>, <code>pixelclk-active</code> 等，设置相应信号的极性。</li>
<li><strong>像素格式与数据源：</strong> 例如，配置为 RGB565、RGB888 等，设定帧缓存的起始地址、DMA 模式等。</li>
<li><strong>FIFO 配置：</strong> 配置 LCDIF 内部的 FIFO 阈值，确保数据流畅传输不欠载。</li>
<li><strong>中断配置：</strong> 使能或禁用各种中断（如帧结束、FIFO 欠载/溢出）。</li>
<li><strong>（可选）伽马、颜色校正等：</strong> 如果 LCDIF 支持高级功能。</li>
</ol>
<p><strong>使能控制器：</strong><br />
在所有上述配置完成后，最后一步就是设置 LCD 控制器的 <strong>使能 (Enable) 寄存器或某个控制位</strong>。<br />
例如：<br />
<code>writel_relaxed(readl_relaxed(data-&gt;reg_base + LCDIF_CR_OFFSET) | LCDIF_CR_ENABLE_MASK, data-&gt;reg_base + LCDIF_CR_OFFSET);</code></p>
<p>此时，LCD 控制器将开始按设定的时序输出信号，如果帧缓存数据也已准备好，屏幕就会点亮并显示内容。</p>
</li>
</ul>
<h4 id="5-辅助小知识"><a class="markdownIt-Anchor" href="#5-辅助小知识"></a> 5. 辅助小知识</h4>
<p>您提炼的小知识点非常实用，下面给出具体的路径和命令：</p>
<ul>
<li>
<p><strong>在 Linux 中查看设备树运行时信息：</strong><br />
在 Linux 文件系统中，运行时加载的设备树的二进制表示（DTB）会被解析并呈现为一个虚拟文件系统，您可以通过以下路径查看：<br />
<code>cd /sys/firmware/devicetree/base/</code><br />
然后使用 <code>ls -l</code> 或 <code>cat</code> 命令查看其中的节点和属性。例如：</p>
<ul>
<li><code>ls -l /sys/firmware/devicetree/base/soc/aips-bus@02000000/lcdif@02040000/</code> (查看 LCDIF 节点)</li>
<li><code>cat /sys/firmware/devicetree/base/compatible</code> (查看根节点的兼容性)
<ul>
<li>您可以在这个目录下通过 <code>find . -name &quot;compatible&quot; | xargs grep &quot;imx&quot;</code> 来尝试查找包含 &quot;imx&quot; 兼容性的节点。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>查看系统已加载的驱动：</strong></p>
<ul>
<li><strong>查看已加载的内核模块：</strong><br />
<code>lsmod</code><br />
这会列出所有动态加载的内核模块及其依赖关系。</li>
<li><strong>查看平台总线上的驱动绑定情况：</strong><br />
对于平台设备（如 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 的 LCDIF 控制器），它们通常注册在 <code>platform</code> 总线上。您可以查看哪些驱动被注册，以及哪些设备已绑定到特定驱动：<br />
<code>ls -l /sys/bus/platform/drivers/</code><br />
例如，找到您的 LCDIF 驱动目录（如 <code>imx-lcdif</code> 或 <code>imx-drm</code>），进入后会有 <code>bind</code>, <code>unbind</code> 以及已绑定设备的符号链接。<br />
<code>ls -l /sys/bus/platform/drivers/imx-lcdif/</code></li>
</ul>
</li>
<li>
<p><strong>查看设备与驱动的匹配情况：</strong><br />
您说的 <code>compatible</code> 属性是关键。当设备树中的一个设备节点的 <code>compatible</code> 属性与某个驱动的 <code>of_match_table</code> (在驱动源码中定义) 中列出的字符串匹配时，该驱动就会被内核尝试用于该设备。<br />
例如，一个设备树节点：</p>
  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">lcdif@02040000</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fsl,imx6ul-lcdif&quot;</span>, <span class="string">&quot;fsl,imx6ul-pxp&quot;</span><span class="punctuation">;</span> <span class="comment">// 兼容性列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>对应的驱动源码中會有類似如下的匹配表：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx_lcdif_dt_ids</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;fsl,imx6ul-lcdif&quot;</span>, &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, imx_lcdif_dt_ids);</span><br></pre></td></tr></table></figure>
<p>当它们匹配时，驱动的 <code>probe</code> 函数就会被调用。</p>
</li>
</ul>
<hr />
<h2 id="3-多缓冲优化"><a class="markdownIt-Anchor" href="#3-多缓冲优化"></a> 3. 多缓冲优化</h2>
<h3 id="linux-framebuffer-多缓冲doubletriple-buffering机制详解"><a class="markdownIt-Anchor" href="#linux-framebuffer-多缓冲doubletriple-buffering机制详解"></a> Linux Framebuffer 多缓冲（Double/Triple Buffering）机制详解</h3>
<p><strong>核心原理：消除屏幕撕裂 (Tearing) 与平滑动画</strong></p>
<p>多缓冲（Double Buffering 或 Triple Buffering）的根本目的是为了 <strong>消除屏幕撕裂 (Screen Tearing)</strong> 现象，并提供流畅的动画体验。当显示控制器正在将当前帧的图像数据发送到屏幕时（例如，从“前台缓冲区”读取），如果应用程序同时修改这个缓冲区，就会导致屏幕上显示的是一部分旧图像和一部分新图像，从而出现撕裂线。</p>
<p>通过使用多个缓冲区（例如，一个“前台缓冲区”用于显示，一个或多个“后台缓冲区”用于应用程序绘制），应用程序可以在后台缓冲区不干扰显示的情况下完成绘制。一旦绘制完成，驱动程序会原子性地将后台缓冲区切换为新的前台缓冲区，这个切 り 替 わりの 动作通常与屏幕的垂直同步信号（VSync）对齐，从而确保每一帧都是完整的，没有撕裂。</p>
<hr />
<h4 id="1-framebuffer-var-variable-screen-information-的关键作用"><a class="markdownIt-Anchor" href="#1-framebuffer-var-variable-screen-information-的关键作用"></a> 1. Framebuffer <code>var</code> (Variable Screen Information) 的关键作用</h4>
<p>您提到的 <code>fb_var_screeninfo</code>（通常在代码中简称为 <code>var</code>）是该机制的核心。它定义了帧缓冲设备的 <strong>当前可变显示模式</strong>。</p>
<ul>
<li>
<p><strong><code>y_virtual</code> (或 <code>xres_virtual</code>):</strong></p>
<ul>
<li><strong>作用：</strong> 定义了帧缓冲设备 <strong>虚拟分辨率</strong> 的高度（或宽度）。在多缓冲模式下，<code>y_virtual</code> 会被设置为 <code>yres * N</code>，其中 <code>yres</code> 是屏幕的物理垂直分辨率，<code>N</code> 是缓冲区数量（例如，双缓冲 <code>N=2</code>，三缓冲 <code>N=3</code>）。</li>
<li><strong>概念：</strong> 显存中实际分配的内存区域，它的高度是物理屏幕高度的 N 倍，所有缓冲区是连续排列在这个大内存块中的。</li>
<li><strong>您的描述：</strong> <code>y_virtual</code> 是正确的，但 <code>buffer的个数是通过显存地址/分辨率*bpp来进行设置</code> 这种说法不准确。
<ul>
<li><strong>更正：</strong> Buffer 的个数（N）是由驱动设计或应用程序需求决定的。显存的大小 <strong>需要足以容纳 N 个物理分辨率大小的缓冲区</strong>。即：<code>total_mem_size = xres * yres * (bits_per_pixel / 8) * N</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>x_offset</code> 和 <code>y_offset</code>:</strong></p>
<ul>
<li><strong>作用：</strong> 定义了从帧缓冲虚拟内存区域的起点开始，<strong>当前显示帧的起始位置</strong> 的坐标。</li>
<li><strong>您的描述：</strong> <code>var_offset</code> 是指 <code>y_offset</code>（或 <code>x_offset</code>）。应用程序通过改变 <code>y_offset</code>（或 <code>x_offset</code>）来告诉显示硬件，下一帧要从显存的哪个位置开始读取数据。</li>
<li><strong>示例：</strong>
<ul>
<li>Buffer 0 (前台)：<code>y_offset = 0</code></li>
<li>Buffer 1 (后台)：<code>y_offset = yres</code></li>
<li>Buffer 2 (后台)：<code>y_offset = yres * 2</code> (针对三缓冲)</li>
</ul>
</li>
<li><strong>底层触发：</strong> 当应用程序通过 <code>ioctl</code> 命令设置 <code>y_offset</code> 时，Linux Framebuffer 子系统会捕获这个请求，并调用设备驱动的特定操作 (<code>fb_ops-&gt;fb_pan_display</code>)。</li>
</ul>
</li>
</ul>
<hr />
<h4 id="2-驱动程序kernel-space配置"><a class="markdownIt-Anchor" href="#2-驱动程序kernel-space配置"></a> 2. 驱动程序（Kernel Space）配置</h4>
<p>驱动程序负责初始化帧缓冲区、分配显存、设置默认显示模式，并实现与硬件交互的函数。</p>
<ol>
<li>
<p><strong>显存分配：</strong></p>
<ul>
<li>
<p><strong>方式：</strong> 驱动程序需要为整个虚拟屏幕分配一块足够大的物理连续内存。</p>
<ul>
<li><strong>推荐：</strong> 使用 CMA (Contiguous Memory Allocator) 或 <code>dma_alloc_coherent()</code> 来分配。这对于 DMA（例如 LCD 控制器从内存读取像素数据）传输效率最高。</li>
<li><code>vmalloc()</code> 或 <code>kmalloc()</code> 也可以，但 <code>vmalloc()</code> 分配的是虚拟连续物理不一定连续的内存，可能需要额外的 CPU/MMU 开销进行地址转换，或不适合 DMA。</li>
</ul>
</li>
<li>
<p><strong>驱动代码：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 fb_info 是帧缓冲器的核心结构体，通过 platform_device 注册</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="type">void</span> *buffer;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_video_mem_size = info-&gt;var.xres * info-&gt;var.yres * (info-&gt;var.bits_per_pixel / <span class="number">8</span>) * num_buffers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如使用 CMA 分配</span></span><br><span class="line">buffer = dma_alloc_coherent(info-&gt;device, total_video_mem_size, &amp;info-&gt;fix.smem_start, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">info-&gt;screen_buffer = buffer; <span class="comment">// 记录内核虚拟地址</span></span><br><span class="line">info-&gt;fix.smem_len = total_video_mem_size; <span class="comment">// 记录总显存长度</span></span><br><span class="line"><span class="comment">// info-&gt;fix.smem_start 已经由 dma_alloc_coherent 设置为物理地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将物理地址 ioremap 到内核可访问的虚拟地址区域</span></span><br><span class="line">info-&gt;screen_base = ioremap(info-&gt;fix.smem_start, info-&gt;fix.smem_len);</span><br><span class="line"><span class="keyword">if</span> (!info-&gt;screen_base) &#123;</span><br><span class="line">    <span class="comment">// 错误处理，并释放dma_alloc_coherent的内存</span></span><br><span class="line">    dma_free_coherent(info-&gt;device, total_video_mem_size, buffer, info-&gt;fix.smem_start);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>设置 <code>fb_info-&gt;var</code> 参数：</strong></p>
<ul>
<li>在驱动的 <code>probe</code> 函数中初始化 <code>fb_info-&gt;var</code> 结构体，包括：
<ul>
<li><code>xres</code>, <code>yres</code>: 屏幕物理分辨率。</li>
<li><code>xres_virtual</code>, <code>yres_virtual</code>: 虚拟分辨率。对于双缓冲，<code>yres_virtual = yres * 2</code>。</li>
<li><code>bits_per_pixel</code>: 每像素位数（如 16, 24, 32）。</li>
<li><code>red</code>, <code>green</code>, <code>blue</code>, <code>transp</code> fields: 颜色位域信息。</li>
<li><code>accel_flags</code>: 加速标志，若硬件支持 2D 加速，可以在这里设置。</li>
<li><code>sync</code>: 同步信号极性。</li>
<li><code>pixclock</code>: 像素时钟周期（ps）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>实现 <code>fb_ops-&gt;fb_pan_display</code> 操作：</strong></p>
<ul>
<li>
<p>这是帧缓冲驱动的核心之一。当应用程序调用 <code>FBIOPAN_DISPLAY</code> <code>ioctl</code> 时，内核会调用这个回调函数。</p>
</li>
<li>
<p>在这个函数中，驱动需要根据传入的 <code>fb_var_screeninfo</code> 中的 <code>x_offset</code> 和 <code>y_offset</code>，<strong>计算出对应缓冲区的物理地址</strong>。</p>
</li>
<li>
<p>然后，将这个新的物理地址 <strong>写入显示控制器（如 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> 的 LCDIF）的帧缓存地址寄存器</strong>。</p>
</li>
<li>
<p><strong>示例 (<code>fb_pan_display</code> 伪代码):</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_fb_pan_display</span><span class="params">(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> new_physical_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset_x_bytes = var-&gt;xoffset * (var-&gt;bits_per_pixel / <span class="number">8</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset_y_bytes = var-&gt;yoffset * info-&gt;fix.line_length; <span class="comment">// line_length 是每行字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的物理地址</span></span><br><span class="line">    new_physical_addr = info-&gt;fix.smem_start + offset_y_bytes + offset_x_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用硬件相关的函数，更新显示控制器寄存器指向新的缓冲区地址</span></span><br><span class="line">    <span class="comment">// 例如 (针对 i.MX LCDIF):</span></span><br><span class="line">    imx_lcdif_set_framebuffer_addr(info, new_physical_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 fb_info 内部的 var 结构体，反映当前显示的位置</span></span><br><span class="line">    info-&gt;var.xoffset = var-&gt;xoffset;</span><br><span class="line">    info-&gt;var.yoffset = var-&gt;yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 drivers/video/fbdev/imx/imxfb.c 或相关显示控制器驱动中实现</span></span><br><span class="line"><span class="comment">// 然后在 fb_ops 结构体中注册:</span></span><br><span class="line"><span class="comment">// .fb_pan_display = imx_fb_pan_display,</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>注册 Framebuffer 设备：</strong><br />
最后，调用 <code>register_framebuffer(info)</code> 将帧缓冲设备注册到内核。</p>
</li>
</ol>
<hr />
<h4 id="3-应用程序user-space使用"><a class="markdownIt-Anchor" href="#3-应用程序user-space使用"></a> 3. 应用程序（User Space）使用</h4>
<p>应用程序通过标准的 Linux 文件 I/O 和 <code>ioctl</code> 接口与帧缓冲设备交互。</p>
<ol>
<li>
<p><strong>打开帧缓冲设备：</strong><br />
<code>fd = open(&quot;/dev/fb0&quot;, O_RDWR);</code></p>
</li>
<li>
<p><strong>获取帧缓冲信息：</strong></p>
<ul>
<li><strong>可见屏幕信息 (<code>var</code>)：</strong> <code>ioctl(fd, FBIOGET_VSCREENINFO, &amp;var);</code></li>
<li><strong>固定屏幕信息 (<code>fix</code>)：</strong> <code>ioctl(fd, FBIOGET_FSCREENINFO, &amp;fix);</code></li>
<li><code>fix.smem_len</code> 提供了整个显存的总大小。</li>
<li><code>fix.line_length</code> 提供了每行像素的字节数 (<code>xres * bits_per_pixel / 8</code>)。</li>
</ul>
</li>
<li>
<p><strong>计算缓冲区信息：</strong></p>
<ul>
<li><strong>单个缓冲区大小：</strong> <code>buffer_size = var.xres * var.yres * (var.bits_per_pixel / 8);</code></li>
<li><strong>计算缓冲区数量：</strong> <code>num_buffers = fix.smem_len / buffer_size;</code> (这是应用程序验证或确认驱动分配的方式)</li>
<li><strong>设置 <code>y_virtual</code>：</strong> 应用程序可以主动设置 <code>y_virtual</code> 为 <code>var.yres * num_buffers</code>。<br />
<code>var.yres_virtual = var.yres * num_buffers;</code><br />
<code>ioctl(fd, FBIOPUT_VSCREENINFO, &amp;var);</code> // 这会更新内核的 var，但不会触发 pan_display</li>
</ul>
</li>
<li>
<p><strong>内存映射 (mmap)：</strong><br />
将帧缓冲的显存映射到应用程序的虚拟地址空间，以便直接访问像素数据。<br />
<code>uint8_t *fbp = (uint8_t *)mmap(0, fix.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</code></p>
</li>
<li>
<p><strong>绘制图像：</strong><br />
应用程序计算后台缓冲区的起始地址，然后向那里写入像素数据。</p>
<ul>
<li><strong>后台缓冲区地址计算：</strong> <code>current_back_buffer_y_offset = (current_front_buffer_y_offset + var.yres) % var.yres_virtual;</code></li>
<li><code>uint8_t *back_buffer_ptr = fbp + current_back_buffer_y_offset * fix.line_length;</code></li>
<li>应用程序将图像数据写入 <code>back_buffer_ptr</code>。</li>
</ul>
</li>
<li>
<p><strong>缓冲区翻转 (Buffer Flipping) - 使用 <code>FBIOPAN_DISPLAY</code>：</strong><br />
一旦后台缓冲区绘制完成，应用程序通过 <code>ioctl</code> 调用 <code>FBIOPAN_DISPLAY</code> 来切换显示到新的后台缓冲区。</p>
<ul>
<li><strong>设置新的 <code>y_offset</code>：</strong><br />
<code>var.yoffset = current_back_buffer_y_offset;</code></li>
<li><strong>调用 IOCTL：</strong><br />
<code>ioctl(fd, FBIOPAN_DISPLAY, &amp;var);</code></li>
<li><strong>您的描述：</strong> 您提到 <code>ioctrl使用PANDISPLAY</code>，正确的 <code>ioctl</code> 命令是 <code>FBIOPAN_DISPLAY</code>。</li>
</ul>
</li>
</ol>
<hr />
<h4 id="4-完整的翻转流程-硬件软件协同"><a class="markdownIt-Anchor" href="#4-完整的翻转流程-硬件软件协同"></a> 4. 完整的翻转流程 (硬件/软件协同)</h4>
<ol>
<li><strong>应用程序请求翻转：</strong> 应用程序计算出下一个要显示的后台缓冲区的 <code>y_offset</code>，并将其设置到 <code>fb_var_screeninfo</code> 结构中。然后调用 <code>ioctl(fd, FBIOPAN_DISPLAY, &amp;var);</code>。</li>
<li><strong>内核 Framebuffer 子系统处理：</strong> 内核接收到 <code>FBIOPAN_DISPLAY</code> 请求后，会检查 <code>fb_var_screeninfo</code> 的合法性，然后调用帧缓冲驱动预先注册的 <code>fb_ops-&gt;fb_pan_display</code> 回调函数。</li>
<li><strong>驱动程序更新硬件：</strong>
<ul>
<li><code>fb_pan_display</code> 函数根据 <code>var-&gt;yoffset</code> 计算出新的显示缓冲区的 <strong>物理起始地址</strong> (例如，<code>info-&gt;fix.smem_start + var-&gt;yoffset * info-&gt;fix.line_length</code>)。</li>
<li>将计算出的物理地址写入 <a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> LCDIF 控制器（或任何其他显示控制器）的 <strong>帧缓冲地址寄存器</strong> (例如，<a target="_blank" rel="noopener" href="http://i.MX">i.MX</a> LCDIF 的 <code>LCDIF_SAR</code> 或其 DMA 起始地址寄存器)。</li>
<li><strong>非常关键的一步：</strong> 驱动程序通常会配置硬件，使其在接收到下一个 <strong>垂直同步 (VSync) 信号时才实际切换</strong> 到新的帧地址。这样可以确保画面切换是原子性的，避免撕裂。</li>
<li><strong>您的描述：</strong> <code>再写入vsync信号，等待vsync刷新，此时就是新地址了</code>。
<ul>
<li><strong>更正：</strong> 硬件 <strong>生成</strong> <code>vsync</code> 信号，驱动程序 <strong>等待</strong>（或硬件异步地在下个 vsync 时）切换。不是驱动程序“写入 vsync 信号”。驱动程序设置一个标志位或寄存器，告诉显示控制器在下一个 VSync 到来时，将显示源指向新的地址。</li>
</ul>
</li>
</ul>
</li>
<li><strong>硬件刷新：</strong> 当显示控制器检测到下一个 VSync 信号时，它会原子性地将内部的帧缓冲读取指针切换到新的地址，并从那里开始读取像素数据发送到屏幕。此时，屏幕就会显示新的图像，而应用程序可以安全地在另一个后台缓冲区继续绘制下一帧。</li>
</ol>
<h4 id="5-补充与高级概念"><a class="markdownIt-Anchor" href="#5-补充与高级概念"></a> 5. 补充与高级概念</h4>
<ul>
<li>
<p><strong>三缓冲 (Triple Buffering)：</strong></p>
<ul>
<li>引入第三个缓冲区是为了进一步解耦 CPU/GPU 的渲染速度与显示器的刷新速度。</li>
<li>当应用程序绘制完第一帧到 Buffer 1 并提交显示后，它可以立即开始绘制第二帧到 Buffer 2。即使显示器还没完成 Buffer 0 的显示，Buffer 1 也还没来得及切换，应用程序也可以继续工作，减少等待。</li>
<li>这对于渲染复杂场景，需要更多 CPU/GPU 时间的应用程序尤其有用。</li>
<li>在 <code>fb_var_screeninfo</code> 中，<code>y_virtual</code> 将是 <code>yres * 3</code>。</li>
</ul>
</li>
<li>
<p><strong>DMA (Direct Memory Access)：</strong></p>
<ul>
<li>LCD 控制器通常通过 DMA 直接从内存中读取帧缓冲数据，而不需要 CPU 干预。这需要分配的显存是物理连续的（<code>dma_alloc_coherent</code> 的原因）。</li>
</ul>
</li>
<li>
<p><strong>DRM/KMS (Direct Rendering Manager / Kernel ModeSetting)：</strong></p>
<ul>
<li>这是 Linux 内核更现代、更强大的显示管理框架，超越了传统的 Framebuffer。</li>
<li>DRM/KMS 提供了更高级的抽象，支持多层合成（overlay）、硬件加速、多屏幕管理、原子模式设置等。</li>
<li>在 DRM/KMS 中，帧缓冲切换通常由 <code>drm_mode_set_config</code> 或 <code>drm_atomic_commit</code> 等 API 完成，底层仍由驱动实现对硬件寄存器的操作，但对用户空间和更上层（如 Wayland/Xorg）的接口更加规范和强大。如果您是新项目，推荐优先考虑 DRM/KMS。</li>
</ul>
</li>
<li>
<p><strong>内存对齐：</strong> 帧缓冲地址和行长通常需要满足一定的对齐要求（如 32 字节或 64 字节对齐），这取决于硬件设计。在驱动中分配内存和计算 <code>line_length</code> 时需要考虑。</p>
</li>
</ul>
<hr />

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B8%89"><span class="toc-number">1.</span> <span class="toc-text"> 嵌入式学习（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-pinctrl-%E5%92%8C-gpio-%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 1. pinctrl 和 gpio 系统使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pinctrl-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%B6%E5%9C%A8-imx6ul-%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1. pinctrl 子系统概述及其在 i.MX6UL 中的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-imx6ul-%E7%9A%84-device-tree-%E8%AE%BE%E5%A4%87%E6%A0%91-%E4%B8%AD-pinctrl-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2. i.MX6UL 的 Device Tree (设备树) 中 pinctrl 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-gpio-%E5%9C%A8-device-tree-%E8%AE%BE%E5%A4%87%E6%A0%91-%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. GPIO 在 Device Tree (设备树) 中的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-linux-%E5%86%85%E6%A0%B8%E4%B8%AD-gpio-%E7%9A%84-c-%E8%AF%AD%E8%A8%80-api-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4. Linux 内核中 GPIO 的 C 语言 API 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E7%8E%B0%E4%BB%A3-api-gpio-descriptor-api"><span class="toc-number">1.1.4.1.</span> <span class="toc-text"> 推荐的现代 API (GPIO Descriptor API)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%97%E7%95%99%E7%9A%84%E6%97%A7%E5%BC%8F-api-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%86%E4%BB%8D%E5%8F%AF%E7%94%A8"><span class="toc-number">1.1.4.2.</span> <span class="toc-text"> 遗留的旧式 API (不推荐但仍可用)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%8D%E5%90%8C%E8%8A%AF%E7%89%87%E9%97%B4-gpio-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5. 不同芯片间 GPIO 使用方法的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9C%A8%E5%AE%9E%E9%99%85%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B8%8A%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C-lcd"><span class="toc-number">1.2.</span> <span class="toc-text"> 2. 在实际的硬件上配置运行 LCD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#imx6ul-lcd-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text"> i.MX6UL LCD 驱动开发详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E8%84%9A%E9%85%8D%E7%BD%AE-pinctrl"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 1. 引脚配置 (Pinctrl)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 2. 时钟配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-lcd-timing-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.1.3.</span> <span class="toc-text"> 3. LCD Timing 参数获取与解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.1.4.</span> <span class="toc-text"> 4. 寄存器设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BE%85%E5%8A%A9%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.1.5.</span> <span class="toc-text"> 5. 辅助小知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E7%BC%93%E5%86%B2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text"> 3. 多缓冲优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-framebuffer-%E5%A4%9A%E7%BC%93%E5%86%B2doubletriple-buffering%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> Linux Framebuffer 多缓冲（Double&#x2F;Triple Buffering）机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-framebuffer-var-variable-screen-information-%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 1. Framebuffer var (Variable Screen Information) 的关键作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8Fkernel-space%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.2.</span> <span class="toc-text"> 2. 驱动程序（Kernel Space）配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8Fuser-space%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.3.</span> <span class="toc-text"> 3. 应用程序（User Space）使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BF%BB%E8%BD%AC%E6%B5%81%E7%A8%8B-%E7%A1%AC%E4%BB%B6%E8%BD%AF%E4%BB%B6%E5%8D%8F%E5%90%8C"><span class="toc-number">1.3.1.4.</span> <span class="toc-text"> 4. 完整的翻转流程 (硬件&#x2F;软件协同)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A1%A5%E5%85%85%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.5.</span> <span class="toc-text"> 5. 补充与高级概念</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&text=嵌入式学习（三）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&is_video=false&description=嵌入式学习（三）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=嵌入式学习（三）&body=Check out this article: https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&title=嵌入式学习（三）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&name=嵌入式学习（三）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://utmux.github.io/2025/07/08/work/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/&t=嵌入式学习（三）"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    YQX
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/utmux">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- Mermaid Support -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
